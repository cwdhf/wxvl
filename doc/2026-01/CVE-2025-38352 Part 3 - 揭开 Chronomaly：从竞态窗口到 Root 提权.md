#  CVE-2025-38352 Part 3 - æ­å¼€ Chronomalyï¼šä»ç«æ€çª—å£åˆ° Root ææƒ  
Faraz
                    Faraz  securitainment   2026-01-26 05:37  
  
<table><thead><tr style="border-top-width: 1px;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><th style="font-weight: bold;border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">åŸæ–‡é“¾æ¥</span></section></th><th style="font-weight: bold;border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">ä½œè€…</span></section></th></tr></thead><tbody><tr style="border-top-width: 1px;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><td style="border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">https://faith2dxy.xyz/2026-01-03/cve_2025_38352_analysis_part_3/</span></section></td><td style="border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">Faraz</span></section></td></tr></tbody></table>  
åœ¨ ç¬¬ä¸€ç¯‡æ–‡ç«  ä¸­ï¼Œæˆ‘å¸¦ä½ ä¸€æ­¥æ­¥æ„é€ äº†ä¸€ä¸ªç”¨äºè§¦å‘ CVE-2025-38352 çš„ proof-of-conceptã€‚è¿™ä¸ªæœ€åˆçš„ PoC é€šè¿‡ä¸€ä¸ª kernel patch å°†ç«äº‰çª—å£äººä¸ºå»¶é•¿äº†Â 500  
msã€‚  
  
åœ¨ ç¬¬äºŒç¯‡æ–‡ç«  ä¸­ï¼Œæˆ‘å±•ç¤ºäº†å¦‚ä½•æŠ›å¼ƒ kernel patchï¼Œè½¬è€Œåœ¨ userland å»¶é•¿ç«äº‰çª—å£ã€‚  
  
åœ¨è¿™ç¯‡æœ€ç»ˆç« é‡Œï¼Œæˆ‘ä¼šå¸¦ä½ å®Œæ•´èµ°ä¸€é Chronomaly çš„ exploit development æµç¨‹ï¼šä»å¤±è´¥çš„æƒ³æ³•ï¼Œåˆ°æœ€ç»ˆå¥æ•ˆçš„ç­–ç•¥ï¼Œä»¥åŠä¸­é—´æ‰€æœ‰çš„å°è¯•ã€‚  
  
é‚£ä¹ˆï¼Œæˆ‘ä»¬å°±æ¥æ­å¼€Â Chronomaly  
çš„é¢çº±å§ã€‚  
## Exploit ä¸æ¼”ç¤º  
  
å¦‚æœä½ åªæ˜¯æ¥æ‰¾ Chronomaly exploitï¼Œæœ¬ä»“åº“é‡Œå·²ç»ç»™å‡ºï¼Œé“¾æ¥å¦‚ä¸‹ã€‚ä»£ç éå¸¸è¯¦ç»†ï¼ŒåŒ…å«å¤§é‡æ³¨é‡Šã€‚æˆ‘å·²ç»å°½å¯èƒ½åšäº†ç®€åŒ–ï¼Œä½†å®ƒä¾ç„¶ç›¸å½“å¤æ‚ï¼›å¦‚æœä½ æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿ç§ä¿¡æˆ‘ã€‚  
  
https://github.com/farazsth98/chronomaly  
  
ä»¥åŠä¸€ä¸ª demoï¼š  
  
![demo](https://mmbiz.qpic.cn/mmbiz_gif/hoiaQy7WhTCPaZqqxK9GYFKIeFLPqibZSk6Gb8FWCcKIoW2KDTdRfyCwcNLCujs2I34nicvOdqcUDuZauVFvFSMOQ/640?wx_fmt=gif&from=appmsg "")  
  
demo  
  
å…³äºå¦‚ä½•é…ç½®ä¸è¿è¡Œ exploit çš„æ‰€æœ‰ç»†èŠ‚ï¼Œéƒ½åœ¨ä¸Šè¿°ä»“åº“é‡Œã€‚  
## ç®€ä»‹  
  
åœ¨é˜…è¯»æœ¬æ–‡ä¹‹å‰ï¼Œæˆ‘å¼ºçƒˆå»ºè®®ä½ å…ˆè¯» part 1 ä¸ part 2ï¼Œä»¥åŠ @streypaws çš„è¿™ç¯‡åšå®¢ hereã€‚å®ƒä»¬èƒ½æä¾›å®Œæ•´ä¸Šä¸‹æ–‡ï¼Œå› ä¸ºæœ¬æ–‡å°†ä» part 2 çš„æ”¶å°¾å¤„ç»§ç»­å±•å¼€ã€‚  
  
æˆ‘è¿˜å°†æœ¬æ–‡çš„ç»“æ„å°½é‡è´´è¿‘çœŸå®çš„ exploit development è¿‡ç¨‹ã€‚è¿™æ„å‘³ç€å…¶ä¸­ä¸€äº›ç« èŠ‚ä¼šä»‹ç»å¤±è´¥çš„æƒ³æ³•ä¸ç­–ç•¥ã€‚å¦‚æœä½ æ›´æƒ³ç›´æ¥è·³åˆ°ç»“è®ºï¼Œæˆ‘ä¼šåœ¨è¿™äº›ç« èŠ‚é‡Œæä¾›é“¾æ¥ï¼Œè·³è½¬åˆ°æœ€ç»ˆå¯ç”¨ç­–ç•¥çš„å¯¹åº”éƒ¨åˆ†ã€‚  
  
å¦å¤–éœ€è¦è¯´æ˜ï¼šå‰ä¸¤ç¯‡æ–‡ç« æ˜¯ä»¥ kernelÂ **v6.12.33**  
ä¸ºèƒŒæ™¯ç¼–å†™çš„ã€‚æ­¤åæˆ‘åˆ‡æ¢åˆ°äº†Â **v5.10.157**  
ï¼Œå› ä¸ºå®ƒæ›´æ¥è¿‘çœŸå®æ˜“å—å½±å“ Android è®¾å¤‡å¯èƒ½è¿è¡Œçš„ kernel ç‰ˆæœ¬ã€‚  
## å›é¡¾ï¼šæˆ‘ä»¬åœåœ¨äº†å“ªé‡Œ  
  
åœ¨ part 2 çš„ç»“å°¾ï¼Œæˆ‘å±•ç¤ºäº†ä¸€ä¸ªå¯ç”¨çš„ PoCï¼Œå®ƒèƒ½åœ¨Â handle_posix_cpu_timers()  
ä¸­å»¶é•¿ç«äº‰çª—å£ã€‚  
### PoC å¦‚ä½•å·¥ä½œ  
  
ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘çš„æ­¥éª¤å¦‚ä¸‹ï¼š  
1. é…ç½® 18 ä¸ª stalling timersï¼Œä»¥åŠ 1 ä¸ª UAF timer (handle_posix_cpu_timers()  
åœ¨ä¸€æ¬¡ä¸­æ–­ä¸­å¤„ç†çš„ firing timers æ•°é‡ä¸Šé™ä¸º 19)ã€‚  
  
1. ç¡®ä¿è¿™äº› timers åœ¨åŒä¸€æ—¶åˆ»è§¦å‘ã€‚  
  
1. ç¡®ä¿åœ¨Â handle_posix_cpu_timers()  
å†…ï¼Œstalling timers ä¼šåœ¨ UAF timer ä¹‹å‰è¢«â€œcollectâ€è¿›åˆ—è¡¨ã€‚  
  
1. æ¯ä¸ª timer å‘è¿›ç¨‹ä¸­çš„æ‰€æœ‰ threads å‘é€Â SIGUSR1  
signalã€‚  
  
1. åˆ›å»ºå°½å¯èƒ½å¤šçš„ threadsã€‚ç¡®ä¿å®ƒä»¬éƒ½ blockÂ SIGUSR1  
ï¼Œå¹¶è®©å®ƒä»¬é€šè¿‡å¯¹ pipe æ‰§è¡Œ read æ¥é˜»å¡ (ç­‰ä»·äºï¼šä¸æ¶ˆè€— CPU çš„ sleep)ã€‚  
  
1. åœ¨è´Ÿè´£è§¦å‘æ¼æ´çš„ child process ä¸­è®¾ç½® racer thread (å‰æ–‡ç§°ä¸º "reapee" thread)ã€‚  
  
1. è§¦å‘æ¼æ´éœ€è¦åœ¨Â do_notify()  
å”¤é†’ ptracing parent process ä¹‹åï¼Œè¿›å…¥Â handle_posix_cpu_timer()  
å»å¤„ç† firing timersã€‚  
  
1. **ç¡®ä¿ racer thread è¢« parent process ptraceã€‚**  
1. åœ¨ parent ä¸­å¯¹ racer thread è°ƒç”¨Â waitpid()  
è¿›è¡Œ reapã€‚å¦‚æœæ—¶æœºæ­£ç¡®ï¼Œthread ä¼šåœ¨æ‰§è¡ŒÂ handle_posix_cpu_timers()  
æ—¶è¢« reapã€‚  
  
1. åœ¨ child process ä¸­è°ƒç”¨Â usleep()  
ç¡ä¸€æ®µä»»æ„æ—¶é—´ï¼Œç„¶åå¯¹ UAF timer è°ƒç”¨Â timer_delete()  
ã€‚usleep()  
çš„ä½œç”¨æ˜¯è®©Â timer_delete()  
è½åœ¨ç«äº‰çª—å£é‡Œã€‚  
  
1. timers è§¦å‘æ—¶ï¼Œsend_sigqueue()  
ä¼šè°ƒç”¨Â complete_signal()  
ï¼Œåè€…ä¼šéå†è¿›ç¨‹ä¸­çš„æ¯ä¸ª threadï¼Œå¹¶æ£€æŸ¥å“ªä¸ª thread èƒ½æ¥æ”¶è¯¥ signalã€‚  
  
æœ¬è´¨ä¸Šï¼Œè¿™ä¸ª PoC ä¼šåˆ›å»º 11,000+ ä¸ª stalling threadsï¼Œè¿™æ„å‘³ç€ï¼šå¯¹äºÂ handle_posix_cpu_timers()  
åœ¨ä¸€æ¬¡ä¸­æ–­ä¸­å¤„ç†çš„ 19 ä¸ª timers ä¸­çš„æ¯ä¸€ä¸ªï¼Œcomplete_signal()  
éƒ½ä¼šå¾ªç¯ ~11,000 æ¬¡ã€‚è¿™æ ·å°±æŠŠç«äº‰çª—å£æ‹‰é•¿åˆ°äº†Â 4-5  
msï¼Œè¶³å¤Ÿè®©æˆ‘ä»¬é‡Šæ”¾ UAF timer å¹¶è§¦å‘ UAFã€‚  
### æ²¡æœ‰ä»€ä¹ˆæ˜¯å®Œç¾çš„  
  
å³ä¾¿ PoC èƒ½è·‘é€šï¼Œä»ç„¶æœ‰ä¸å°‘é—®é¢˜éœ€è¦ç»§ç»­è§£å†³â€¦â€¦  
1. 4-5  
ms å¬èµ·æ¥ä»ç„¶ä¸å¤Ÿé•¿ã€‚æˆ‘èƒ½å¦æŠŠç«äº‰çª—å£å†æ‹‰é•¿ä¸€äº›ï¼Ÿ  
  
1. æˆ‘ç”¨æ¥â€œå®šæ—¶â€è§¦å‘Â timer_delete()  
çš„é€»è¾‘å¾ˆè„†å¼± â€”â€” ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åº”è¯¥æœ‰åŠæ³•çŸ¥é“ racer thread åœ¨Â handle_posix_cpu_timers()  
çš„ç«äº‰çª—å£é‡ŒÂ å…·ä½“å¤„äºä»€ä¹ˆæ—¶å€™  
ã€‚  
  
1. åˆ é™¤ timer ä¼šæ¸…æ‰Â timer->sigq  
ä¸Šçš„Â SIGQUEUE_PREALLOC  
æ ‡å¿—ï¼Œä»è€Œè§¦å‘Â send_sigqueue()  
å†…çš„Â BUG_ON()  
ã€‚ä¸ºäº†ç»§ç»­èµ°å‘ exploitationï¼Œæˆ‘å¿…é¡»æƒ³åŠæ³•ç»•è¿‡è¿™ä¸€ç‚¹ã€‚  
  
1. æˆ‘ä»¬è¯¥å¦‚ä½•åˆ¤æ–­è‡ªå·±æ˜¯å¦èµ¢å¾—äº†ç«äº‰ï¼Œå¹¶ä¸”æ­£åœ¨Â handle_posix_cpu_timers()  
å†…å¤„ç†ä¸€ä¸ªå·²é‡Šæ”¾çš„ timer?  
  
ä¸‹é¢æˆ‘ä»¬å°±ä¸€èµ·èµ°å®Œ Chronomaly çš„æœ€ç»ˆ exploit development è¿‡ç¨‹ã€‚  
## è®©ç«äº‰çª—å£æ›´é•¿  
  
æˆ‘çš„ç¬¬ä¸€ä¸ªç›®æ ‡ï¼Œæ˜¯å°½å¯èƒ½æŠŠç«äº‰çª—å£æ‹‰åˆ°æœ€é•¿ã€‚  
### æšä¸¾å¯ç”¨é€‰é¡¹  
  
æˆ‘ä¼šæŠŠæ‰€æœ‰â€œèƒ½å»¶é•¿ç«äº‰çª—å£â€çš„é€‰é¡¹éƒ½è¿‡ä¸€éã€‚æˆ‘ä»¬å·²ç»çŸ¥é“ï¼šhandle_posix_cpu_timers()  
ä¼šå¯¹å®ƒå¤„ç†çš„ 19 ä¸ª timers é€ä¸ªè°ƒç”¨Â cpu_timer_fire()  
ã€‚é—®é¢˜æ˜¯ï¼š**æˆ‘ä»¬æœ‰å“ªäº›åŠæ³•èƒ½å¢åŠ Â cpu_timer_fire()çš„æ‰§è¡Œæ—¶é—´ï¼Ÿ**  
  
cpu_timer_fire()  
ä¼šè°ƒç”¨Â posix_timer_event()  
ï¼Œè€Œåè€…åªä¼šè°ƒç”¨Â send_sigqueue()  
(code)ã€‚é‚£ä¹ˆåœ¨è¿™é‡Œæˆ‘ä»¬æœ‰å“ªäº›å»¶é•¿ç«äº‰çª—å£çš„é€‰é¡¹ï¼Ÿ  
1. ä¼šè°ƒç”¨Â prepare_signal()  
ã€‚è¯¥å‡½æ•°ä¼šå¯¹ stop signals ä¸Â SIGCONT  
åšç‰¹æ®Šå¤„ç†ï¼›åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œå®ƒéƒ½ä¼šåƒÂ complete_signal()  
ä¸€æ ·éå†è¿›ç¨‹ä¸­çš„æ‰€æœ‰ threadsã€‚  
  
1. ä¼šè°ƒç”¨Â signalfd_notify()  
ï¼Œç”¨äºå”¤é†’åœ¨è¯¥ signal çš„Â signalfd  
ä¸Šç­‰å¾…çš„ waitersã€‚  
  
1. complete_signal()  
æˆ‘ä»¬ä¹‹å‰å·²ç»åˆ†æè¿‡äº†ã€‚  
  
complete_signal()  
å·²ç»è®²è¿‡äº†ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥çœ‹çœ‹Â prepare_signal()  
ä¸Â signalfd_notify()  
ã€‚  
### é€‰é¡¹ 1 -Â prepare_signal()  
  
æŸ¥çœ‹Â prepare_signal()  
(code)ï¼Œå…¶é€»è¾‘å¤§è‡´å¦‚ä¸‹ï¼š  
1. å¦‚æœè¯¥è¿›ç¨‹æ­£å¤„äº group exit çš„æ­»äº¡è¿‡ç¨‹ä¸­ï¼Œåˆ™è¿”å›Â sig == SIGKILL  
ã€‚è¿™ä¸é€‚ç”¨äºæˆ‘ä»¬ã€‚  
  
1. å¦‚æœè¦å‘é€çš„ signal æ˜¯Â SIGSTOP  
ã€SIGTTIN  
ã€SIGTSTP  
æˆ–Â SIGTTOU  
ï¼Œå®ƒä¼šè¢«å½“ä½œ stop signal å¤„ç†ï¼šéå†æ¯ä¸ª threadï¼Œå¹¶ä» pending list ä¸­ç§»é™¤Â SIGCONT  
ã€‚  
  
1. å¦‚æœè¦å‘é€çš„ signal æ˜¯Â SIGCONT  
ï¼Œåˆ™éå†æ‰€æœ‰ threadsï¼Œç§»é™¤ä¸Šè¿°å››ä¸ª stop signalsï¼Œç„¶åæŠŠå®ƒä»¬å”¤é†’ã€‚  
  
1. å¦‚æœè¯¥ signal å½“å‰æ²¡æœ‰è¢« ignoreï¼Œåˆ™è¿”å› trueï¼›å¦åˆ™è¿”å› falseã€‚  
  
ç”±äºç¬¬ 2 æ­¥æˆ–ç¬¬ 3 æ­¥ (äº’æ–¥ï¼ŒåŒä¸€æ—¶åˆ»åªèƒ½å‘ç”Ÿå…¶ä¸€) éƒ½ä¼šéå†æ‰€æœ‰ threadsï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œéå†ä¸€æ¬¡ threadsï¼Œç„¶ååœ¨Â complete_signal()  
é‡Œå†éå†ä¸€æ¬¡ã€‚è¿™æ ·ç­‰ä»·äºæŠŠç«äº‰çª—å£ç¿»å€ã€‚  
  
ä½†â€¦â€¦è¿˜èƒ½æ›´è¿›ä¸€æ­¥å—ï¼Ÿ  
### é€‰é¡¹ 2 -Â signalfd_notify()  
  
signalfd_notify()  
(code) å¾ˆç®€å•ï¼šå®ƒä¼šè°ƒç”¨Â wake_up(&tsk->sighand->signalfd_wqh)  
æ¥å”¤é†’åœ¨ç›®æ ‡ task çš„Â signalfd  
waitqueue ä¸Šç¡çœ çš„æ‰€æœ‰ waitersã€‚  
  
ä¸€å¼€å§‹æˆ‘å¿½ç•¥äº†è¿™ä¸ªå‡½æ•°ï¼Œå› ä¸ºæˆ‘æ²¡çœ‹åˆ°æ˜æ˜¾çš„ loopsã€‚ä½†æ·±å…¥ä¸‹å»æˆ‘å‘ç°ï¼Œå®ƒæœ€ç»ˆä¼šè°ƒç”¨Â __wake_up_common()  
(code)ï¼Œè€Œåè€…ä¼šåƒä¸‹é¢è¿™æ ·éå† waitqueue ä¸Šçš„æ‰€æœ‰ waiters:  
```
list_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {// Handle the waiter}
```  
  
æˆ‘æ³¨æ„åˆ°Â signalfd  
æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ª file descriptorï¼Œå› æ­¤å®ƒå¿…é¡»ç”±ä¸€ä¸ªÂ struct file  
æ¥æ”¯æ’‘ã€‚äºæ˜¯æˆ‘å»æ‰¾Â tsk->sighand->signalfd_wqh  
çš„äº¤å‰å¼•ç”¨ï¼Œå‘ç°Â signalfd_poll()  
ä¼šè°ƒç”¨Â poll_wait()  
ï¼Œå¹¶æŠŠÂ wait_queue_head_t *  
å‚æ•°è®¾ç½®ä¸ºÂ current->sighand->signalfd_wqh  
ã€‚  
```
static__poll_tsignalfd_poll(structÂ file *file, poll_table *wait){structÂ signalfd_ctx *ctx = file->private_data;__poll_tÂ events =Â 0;poll_wait(file, &current->sighand->signalfd_wqh,Â wait);// [ ... ]returnÂ events;}staticinlinevoidpoll_wait(structÂ file * filp,Â wait_queue_head_tÂ * wait_address, poll_table *p){ifÂ (p && p->_qproc && wait_address)Â  p->_qproc(filp, wait_address, p);}
```  
  
è¿™è®©æˆ‘ç«‹åˆ»æƒ³èµ· Jann Horn çš„é‚£ç¯‡åšå®¢ "Racing against the clock -- hitting a tiny kernel race window"ã€‚åœ¨æ–‡ç« ä¸­ä»–è§£é‡Šé“ï¼šä½ å¯ä»¥åˆ›å»º 500 ä¸ª epoll instancesï¼ŒæŠŠåŒä¸€ä¸ª file descriptor dup 100 æ¬¡ï¼Œç„¶åè®©è¿™ 500 ä¸ª epoll instances éƒ½å»ç›‘å¬æ¯ä¸€ä¸ª dup å‡ºæ¥çš„ file descriptorsã€‚æœ€ç»ˆæ•ˆæœæ˜¯ï¼šè¯¥ file descriptor çš„ waitqueue ä¼šç´¯ç§¯åˆ°Â 500 * 100 = 50,000  
ä¸ª waitqueue entriesï¼›ä¸€æ—¦Â timerfd  
åˆ°æœŸå¹¶åœ¨ç«äº‰çª—å£å†…è¢«å¤„ç†ï¼Œè¿™äº› entries éƒ½éœ€è¦è¢«é€šçŸ¥ã€‚  
  
å½“ç„¶ï¼Œæˆ‘ä»¬è¿™é‡Œç”¨çš„ä¸æ˜¯Â timerfd  
(POSIX CPU timer æ˜¯ä¸€ä¸ªÂ struct k_itimer  
)ï¼Œä½†æ—¢ç„¶è¿™é‡Œå­˜åœ¨ä¼šè¢«é€šçŸ¥çš„Â signalfd  
ï¼Œé‚£è¿™ä¸ªæ€è·¯æ˜¯å¦ä¹Ÿèƒ½æˆç«‹ï¼Ÿ  
  
æˆ‘å…ˆæ²¿ç€Â epoll_ctl(..., EPOLL_CTL_ADD, ...)  
çš„ä»£ç è·¯å¾„è·Ÿäº†ä¸€éï¼Œçœ‹çœ‹å®ƒå…·ä½“æ€ä¹ˆè¿ä½œã€‚æˆ‘æ³¨æ„åˆ°å®ƒæœ€ç»ˆä¼šå¯¹Â struct file *  
è°ƒç”¨Â vfs_poll()  
ï¼Œè¿›è€Œèµ°åˆ°Â signalfd_poll() -> poll_wait()  
ã€‚åœ¨Â poll_wait()  
ä¸­ï¼Œp->_qproc  
è¢«è®¾ç½®ä¸ºÂ ep_ptable_queue_proc()  
ï¼Œå®ƒä¼šåˆ›å»ºä¸€ä¸ª waitqueue entryï¼Œå¹¶æŠŠå®ƒæ’å…¥åˆ°ä¼ å…¥çš„Â wait_queue_head_t *  
ä¸­ï¼  
  
å®Œç¾ï¼å¦‚æœæˆ‘èƒ½åŠ åˆ° 50,000 ä¸ª waitqueue entriesï¼Œå°±èƒ½æŠŠä¹‹å‰çš„ç«äº‰çª—å£å»¶é•¿åˆ° 5 å€ä»¥ä¸Š (è€Œä¸”Â wake_up()  
çš„ä»£ç è·¯å¾„æ¯”Â complete_signal()  
é‡Œå•çº¯éå† threads æ›´å¤æ‚ã€æ›´è€—æ—¶)ã€‚  
  
æœ€ç»ˆ exploit ä¸­å®ç°å¦‚ä¸‹ï¼š  
```
// Set up signalfds for `SIGUSR1` and `SIGUSR2`sigset_tÂ block_mask;sigemptyset(&block_mask);sigaddset(&block_mask, SIGUSR1);sigusr1_sfds[0] = SYSCHK(signalfd(-1, &block_mask, SFD_CLOEXEC | SFD_NONBLOCK));sigemptyset(&block_mask);sigaddset(&block_mask, SIGUSR2);sigusr2_sfds[0] = SYSCHK(signalfd(-1, &block_mask, SFD_CLOEXEC | SFD_NONBLOCK));// Block the signalssigemptyset(&block_mask);sigaddset(&block_mask, SIGUSR1);sigaddset(&block_mask, SIGUSR2);sigprocmask(SIG_BLOCK, &block_mask,Â NULL);// Create epoll instancesforÂ (intÂ i =Â 0; i < EPOLL_COUNT; i++) {Â  Â  epoll_fds[i] =Â SYSCHK(epoll_create1(EPOLL_CLOEXEC));}// Duplicate sfds, index 0 is the originalforÂ (intÂ i =Â 1; i < SFD_DUP_COUNT; i++) {Â  Â  sigusr1_sfds[i] =Â SYSCHK(dup(sigusr1_sfds[0]));Â  Â  sigusr2_sfds[i] =Â SYSCHK(dup(sigusr2_sfds[0]));}// Setup epoll watchers nowstructÂ epoll_event ev = {0};ev.events = EPOLLIN;forÂ (intÂ i =Â 0; i < EPOLL_COUNT; i++) {forÂ (intÂ j =Â 0; j < SFD_DUP_COUNT; j++) {Â  Â  Â  Â  ev.data.fdÂ = sigusr1_sfds[j];SYSCHK(epoll_ctl(epoll_fds[i], EPOLL_CTL_ADD, sigusr1_sfds[j], &ev));Â  Â  Â  Â  ev.data.fdÂ = sigusr2_sfds[j];SYSCHK(epoll_ctl(epoll_fds[i], EPOLL_CTL_ADD, sigusr2_sfds[j], &ev));Â  Â  }}
```  
> **æ³¨æ„**  
> signals è¦ä¹ˆå¿…é¡»è¢« blockï¼Œè¦ä¹ˆå¿…é¡»å®‰è£… signal handlerã€‚å¦åˆ™ signal åŸºæœ¬ä¼šè¡¨ç°å¾—åƒÂ SIGKILL  
ä¸€æ ·ã€‚æˆ‘å‘ç°æœ€ç®€å•çš„åšæ³•æ˜¯ç›´æ¥ block signals (å¹¶åœ¨åç»­é€šè¿‡Â read()  
ä»Â signalfd  
ä¸­æŠŠæ¯ä¸ª signal drain æ‰)ã€‚  
  
  
ç”¨æˆ‘çš„ kernel profiling patch æµ‹è¯•åå‘ç°ï¼šç«äº‰çª—å£ç°åœ¨å˜æˆäº†Â 31-34  
ms! è¿™æ˜¯å·¨å¤§çš„æå‡ã€‚  
  
ä¸ºäº†ç®€åŒ– PoCï¼Œæˆ‘ç§»é™¤äº†ä¹‹å‰ä¸ºäº†é€šè¿‡Â complete_signal()  
å»¶é•¿ç«äº‰çª—å£è€Œåˆ›å»ºçš„ ~11,000 ä¸ª threadsã€‚æœ€ç»ˆçš„ç«äº‰çª—å£å¹³å‡ä¸ºÂ 24-26  
msï¼Œæˆ‘å·²ç»å¾ˆæ»¡æ„äº†ã€‚  
  
è¿›å…¥ä¸‹ä¸€æ­¥ï¼  
## åœ¨ç«äº‰çª—å£å†…åˆ é™¤ Timer  
  
æˆ‘çš„ç¬¬äºŒä¸ªç›®æ ‡ï¼Œæ˜¯ç¡®ä¿åªè¦è¿›å…¥ç«äº‰çª—å£ï¼Œæˆ‘å°±èƒ½Â æ¯æ¬¡  
éƒ½åœ¨çª—å£å†…å¯¹ UAF timer è°ƒç”¨Â timer_delete()  
ã€‚ç›®å‰ï¼Œå³ä¾¿è¿›å…¥äº†ç«äº‰çª—å£ï¼Œchild process ä¸­é‚£å¥—è„†å¼±çš„Â usleep()  
å»¶è¿Ÿé€»è¾‘ä»ç„¶å¯èƒ½è®©Â timer_delete()  
è°ƒå¾—å¤ªæ—© (ç”±äºç«äº‰çª—å£æœ‰Â 24-26  
msï¼Œåè€Œå‡ ä¹ä¸å¯èƒ½è°ƒå¾—å¤ªæ™š)ã€‚  
  
åœ¨å®ç°Â signalfd  
çš„â€œå»¶é•¿ç«äº‰çª—å£â€é€»è¾‘ä¹‹åï¼Œæˆ‘çªç„¶çµå…‰ä¸€ç°â€¦â€¦  
  
å½“Â handle_posix_cpu_timers()  
å¼€å§‹å¤„ç†ç¬¬ä¸€ä¸ª stall timer æ—¶ï¼Œå®ƒæœ€ç»ˆä¼šè°ƒç”¨Â signalfd_notify()  
(ä¸Šæ–‡å·²è§£é‡Š)ã€‚è¿™ä¼šå”¤é†’æ‰€æœ‰æ­£åœ¨ poll è¯¥Â signalfd  
çš„ waitersâ€¦â€¦  
  
é‚£æˆ‘ä¸ºä»€ä¹ˆä¸ç›´æ¥åˆ›å»ºä¸€ä¸ª threadï¼Œå» poll ä¸€ä¸ªä¸ºÂ SIGUSR1  
åˆ›å»ºçš„Â signalfd  
(stall timers æ­£æ˜¯å‘é€è¿™ä¸ª signal)? å½“å®ƒç¬¬ä¸€æ¬¡è¢«å”¤é†’æ—¶ï¼Œå¦‚æœç«‹åˆ»å¯¹ UAF timer è°ƒç”¨Â timer_delete()  
ï¼Œé‚£è¿™æ¬¡åˆ é™¤å°±å¿…ç„¶å‘ç”Ÿåœ¨ç«äº‰çª—å£å†…ï¼  
  
æˆ‘åœ¨Â free_timer_thread  
ä¸­å®ç°äº†è¿™å¥—é€»è¾‘ï¼Œå®ƒä¼šè°ƒç”¨Â free_func()  
handler function:  
```
voidfree_func(void) {// [ ... ]structÂ pollfd pfd = {Â  Â  Â  Â  .fdÂ = sigusr1_sfds[0],Â  Â  Â  Â  .eventsÂ = POLLINÂ  Â  };// Poll for SIGUSR1.forÂ (;;) {intÂ ret =Â poll(&pfd,Â 1,Â 0);// Got SIGUSR1 from the first stall timer, in race window now.ifÂ (pfd.reventsÂ & POLLIN) {SYSCHK(timer_delete(uaf_timer));break;Â  Â  Â  Â  }// [ ... ]Â  Â  }}
```  
  
è¿™ä¸ªå‡½æ•° (åœ¨å½“æ—¶) çš„å”¯ä¸€ç›®çš„ï¼Œå°±æ˜¯è¢«ç¬¬ä¸€ä¸ª stall timer çš„Â SIGUSR1  
signal å”¤é†’åç«‹åˆ»åˆ é™¤ UAF timerï¼Œç„¶åé€€å‡ºã€‚  
  
æœ‰æ„æ€çš„æ˜¯ï¼Œè¿™ä¹ˆåšä¼šå¯¼è‡´Â timer_wait_running()  
(code) é‡Œçš„è¿™ä¸ª warning é¢‘ç¹å‘½ä¸­ï¼š  
```
staticstructÂ k_itimer *timer_wait_running(structÂ k_itimer *timer,unsignedlongÂ *flags){// [ ... ]ifÂ (!WARN_ON_ONCE(!kc->timer_wait_running))Â  kc->timer_wait_running(timer);// [ ... ]}
```  
  
å½“Â posix_cpu_timer_del()  
è¿”å›Â TIMER_RETRY  
æ—¶ï¼Œtimer_delete()  
ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼›åœ¨æ»¡è¶³ä»¥ä¸‹æ¡ä»¶æ—¶å°±ä¼šå‘ç”Ÿï¼š  
1. timers å½“å‰æ­£ç”±Â handle_posix_cpu_timer()  
å¤„ç†ã€‚  
  
1. æˆ‘ä»¬å¹¶æ²¡æœ‰åœ¨Â exit_notify()  
ä¹‹åè¿›å…¥Â handle_posix_cpu_timers()  
ï¼Œå› æ­¤è¯¥ task æ— æ³•è¢« ptracing parent process å›æ”¶ã€‚  
  
1. posix_cpu_timer_del()  
æ³¨æ„åˆ° timer æ­£åœ¨ firingï¼Œäºæ˜¯è¿”å›Â TIMER_RETRY  
ã€‚  
  
1. timer_delete()  
è°ƒç”¨Â timer_wait_running()  
ã€‚  
  
åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¯¹äºé€šè¿‡Â CLOCK_THREAD_CPUTIME_ID  
åˆ›å»ºçš„ POSIX CPU timers (æœ¬ exploit éœ€è¦è¿™ç§ timer)ï¼Œkc->timer_wait_running  
è¿™ä¸ªå‡½æ•°æŒ‡é’ˆä¸ºÂ NULL  
ã€‚  
  
æˆ‘è§‰å¾—è¿™æŒºæœ‰è¶£ï¼šè¿™æ˜¯ä¸€ä¸ªæ— ä¼¤å¤§é›…çš„å° bugï¼Œä½†å®ƒå®é™…ä¸Šæš—ç¤º kernel developers åœ¨è¿™é‡Œåšäº†ä¸€ä¸ªæ— æ•ˆå‡è®¾ â€”â€” ä»–ä»¬è®¤ä¸ºå¯¹ POSIX CPU timers è°ƒç”¨ timer ç›¸å…³ syscalls æ—¶ä¸å¯èƒ½è¿”å›Â TIMER_RETRY  
ã€‚æ˜¾ç„¶è¿™ä¸ªå‡è®¾æ˜¯é”™çš„ï¼Œä¸è¿‡å…ˆä¸å±•å¼€äº†ã€‚  
  
åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å·²ç»å»¶é•¿äº†ç«äº‰çª—å£ï¼Œå¹¶å®ç°äº†ç«äº‰çª—å£æ£€æµ‹é€»è¾‘ï¼Œç¡®ä¿ UAF timer æ€»èƒ½åœ¨çª—å£å†…è¢«åˆ é™¤ã€‚  
  
æ¥ä¸‹æ¥æ˜¯ä»€ä¹ˆï¼Ÿ  
## å°æ’æ›²ï¼šä¸€ä¸ªå¤±è´¥çš„æƒ³æ³•  
  
å¦‚æœä½ æƒ³è·³è¿‡è¿™ä¸€èŠ‚ï¼Œå¯ä»¥ ç‚¹å‡»è¿™é‡Œ ç›´æ¥è¿›å…¥ä¸‹ä¸€èŠ‚ã€‚  
  
ä¸€å¼€å§‹æˆ‘æ³¨æ„åˆ°ï¼šstruct k_itimer  
å¹¶ä¸ä¼šç«‹åˆ»è¢«é‡Šæ”¾ï¼Œè€Œæ˜¯é€šè¿‡ RCU é‡Šæ”¾ (code):  
```
staticvoidrelease_posix_timer(structÂ k_itimer *tmr,Â intÂ it_id_set){// [ ... ]call_rcu(&tmr->rcu, k_itimer_rcu_free);}staticvoidk_itimer_rcu_free(structÂ rcu_head *head){structÂ k_itimer *tmr =Â container_of(head,Â structÂ k_itimer, rcu);kmem_cache_free(posix_timers_cache, tmr);}
```  
  
çœ‹åˆ°è¿™é‡Œæ—¶ï¼Œæˆ‘çš„ç¬¬ä¸€ä¸ªæƒ³æ³•æ˜¯ï¼šèƒ½ä¸èƒ½æŠŠç«äº‰çª—å£å»¶é•¿åˆ°è¶³å¤Ÿé•¿ï¼Œè®© timer åœ¨çª—å£å†…é€šè¿‡ RCU å®Œå…¨é‡Šæ”¾ï¼Ÿä½†æ— è®ºæˆ‘æ€ä¹ˆå°è¯•ï¼ŒRCU free éƒ½â€œæ­»æ´»â€ä¸åœ¨ç«äº‰çª—å£é‡Œå‘ç”Ÿã€‚æˆ‘ç”šè‡³åœ¨æ„è¯†åˆ° timer æ ¹æœ¬æ²¡è¢« free ä¹‹å‰ï¼Œå°±å·²ç»ä¸ºÂ struct k_itimer  
åšäº†å®Œæ•´çš„ cross-cachingã€‚  
  
æœ€åæˆ‘æ”¾å¼ƒäº†è¿™ä¸ªæƒ³æ³•ã€‚äº‹åæƒ³æƒ³ï¼Œè¿™æ¡è·¯æœ¬æ¥å°±ä¸å¤ªåˆç†ï¼šå°±ç®—æˆ‘èƒ½èµ°é€šï¼Œæˆ‘ä¹Ÿå¿…é¡»æ‰¾åˆ°ä¸€ä¸ªå¯¹è±¡æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š  
1. åœ¨Â timer->sigq  
offset å¤„æœ‰ä¸€ä¸ªæœ‰æ•ˆæŒ‡é’ˆã€‚  
  
1. åœ¨Â timer->it_lock  
offset å¤„æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„Â spin_lock  
ã€‚  
  
1. timer->sigq  
æŒ‡å‘çš„å†…å­˜å¿…é¡»åœ¨Â timer->sigq->flags  
offset å¤„è®¾ç½®Â SIGQUEUE_PREALLOC  
flagã€‚  
  
1. å¯èƒ½è¿˜æœ‰ä¸€äº›æˆ‘æ²¡æƒ³åˆ°çš„æ¡ä»¶â€¦â€¦  
  
æ€»ä¹‹ï¼Œè¿™çœ‹èµ·æ¥æä¸å¯èƒ½æ˜¯æ­£ç¡®çš„ exploitation è·¯çº¿ã€‚å› æ­¤åœ¨æµªè´¹äº†å¾ˆå¤šå°æ—¶ä¹‹åï¼Œæˆ‘ç»ˆäºå†³å®šæ¢æ–¹å‘ï¼šå» targetÂ timer->sigq  
å¯¹è±¡ â€”â€” å®ƒä¼šé€šè¿‡Â release_posix_timer()  
ç«‹å³é‡Šæ”¾ï¼Œè€Œä¸æ˜¯èµ° RCUã€‚  
## ç»•è¿‡Â BUG_ON()  
  
æœ¬èŠ‚åç»­çš„å°èŠ‚ä¼šä»‹ç»ä¸€äº›å¤±è´¥çš„æƒ³æ³•ã€‚å¦‚æœä½ æƒ³ç›´æ¥è·³åˆ°å¯ç”¨ç­–ç•¥ï¼Œå¯ä»¥é€‰æ‹©ä»¥ä¸‹ä»»ä¸€é€‰é¡¹ï¼š  
1. å¯ç”¨ç­–ç•¥ï¼Œä½†ä»ä¼šå¶å‘è§¦å‘Â BUG_ON()  
â€” ç‚¹å‡»è¿™é‡Œã€‚  
  
1. å®Œå…¨å¯ç”¨ç­–ç•¥ï¼Œå½»åº•ç»•è¿‡Â BUG_ON()  
â€” ç‚¹å‡»è¿™é‡Œã€‚  
  
### BUG_ON()çš„æ¥æº  
  
åœ¨Â send_sigqueue()  
(code) ä¸­ï¼Œæˆ‘ä»¬å‘½ä¸­çš„Â BUG_ON()  
æ˜¯è¿™å¥ï¼Œå…¶ä¸­Â q  
å°±æ˜¯Â timer->sigq  
å¯¹è±¡ã€‚  
```
BUG_ON(!(q->flags & SIGQUEUE_PREALLOC));
```  
  
æŸ¥æ‰¾Â SIGQUEUE_PREALLOC  
çš„äº¤å‰å¼•ç”¨å¯ä»¥çœ‹åˆ°ï¼šå½“Â do_timer_create()  
é€šè¿‡è°ƒç”¨Â sigqueue_alloc()  
ä¸ºÂ timer->sigq  
åˆ†é…ä¸€ä¸ªÂ sigqueue  
å¯¹è±¡æ—¶ï¼Œè¯¥æ ‡å¿—ä¼šè¢«è®¾ç½® (code):  
```
structÂ sigqueue *sigqueue_alloc(void){structÂ sigqueue *q =Â __sigqueue_alloc(-1, current, GFP_KERNEL,Â 0);ifÂ (q)Â  q->flags |= SIGQUEUE_PREALLOC;returnÂ q;}
```  
  
éšåï¼Œå½“é€šè¿‡Â timer_delete()  
åˆ é™¤ timer æ—¶ï¼Œrelease_posix_timer()  
ä¼šè°ƒç”¨Â sigqueue_free()  
ï¼Œå®ƒä¼šåšä¸¤ä»¶äº‹ (code):  
1. æ— æ¡ä»¶æ¸…é™¤Â timer->sigq  
ä¸Šçš„Â SIGQUEUE_PREALLOC  
æ ‡å¿—ã€‚  
  
1. åªæœ‰å½“Â timer->sigq  
ä¸åœ¨æŸä¸ª task çš„ pending list ä¸­æ—¶æ‰é‡Šæ”¾å®ƒ (å®ƒä¼šåœ¨Â send_sigqueue()  
ä¸­è¢«åŠ å…¥ pending list)ã€‚  
  
```
voidsigqueue_free(structÂ sigqueue *q){// [ ... ]Â q->flags &= ~SIGQUEUE_PREALLOC;// [ ... ]}
```  
  
é—®é¢˜å°±å¾ˆæ˜æ˜¾äº†ï¼šå½“æˆ‘ä»¬åœ¨ç«äº‰çª—å£å†…é€šè¿‡Â timer_delete()  
é‡Šæ”¾ timer æ—¶ï¼ŒSIGQUEUE_PREALLOC  
æ ‡å¿—ä¼šè¢«æ¸…æ‰ï¼›éšååŒä¸€ä¸ª timer çš„Â sigq  
å†è¢«ä¼ å…¥Â send_sigqueue()  
æ—¶ï¼Œå°±ä¼šè§¦å‘Â BUG_ON()  
ã€‚  
  
é‚£ä¹ˆï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆç»•è¿‡è¿™ä¸ªÂ BUG_ON()  
?  
### ç¬¬ä¸€ä¸ªæƒ³æ³•ï¼šé‡æ–°åˆ†é…ä¸€ä¸ªæ–° Timer  
  
æˆ‘çš„ç¬¬ä¸€ä¸ªæƒ³æ³•æ˜¯ï¼šåœ¨ç«äº‰çª—å£é‡Œç›´æ¥é‡æ–°åˆ†é…ä¸€ä¸ªæ–°çš„ timerã€‚ç”±äºæ–° timer ä¹Ÿä¼šåˆ†é…è‡ªå·±çš„Â timer->sigq  
ï¼Œå¦‚æœèƒ½è®©å®ƒå¤ç”¨Â uaf_timer->sigq  
çš„é‚£å—å†…å­˜ï¼Œæˆ‘ä»¬å°±èƒ½é‡æ–°è®¾ç½®Â SIGQUEUE_PREALLOC  
æ ‡å¿—ï¼Œä»è€Œå½»åº•ç»•è¿‡Â BUG_ON()  
ã€‚  
  
è€ƒè™‘åˆ° SLUB allocator çš„å·¥ä½œæ–¹å¼ï¼Œè¿™ä¸ªæ€è·¯æ˜¯å¯è¡Œçš„ã€‚è¿™é‡Œä¸è¿‡å¤šå±•å¼€ç»†èŠ‚ (æœ¬æ–‡å·²ç»å¤Ÿé•¿äº†â€¦â€¦)ï¼Œå¤§è‡´å¯ä»¥æŒ‰ä»¥ä¸‹æ­¥éª¤è®©Â uaf_timer->sigq  
æ›´å®¹æ˜“è¢«å¦ä¸€ä¸ª timer é‡æ–°åˆ†é…ï¼š  
1. åˆ†é…Â uaf_timer  
æ—¶ pin åˆ°ç‰¹å®š CPU (æˆ‘ç”¨ CPU 3)ã€‚  
  
1. ç¡®ä¿åœ¨æ­¤ä¹‹åè¯¥ CPU ä¸Šä¸å†å‘ç”Ÿå…¶å®ƒÂ sigqueue  
åˆ†é…ï¼Œè®©Â uaf_timer->sigq  
ç•™åœ¨ä¸€ä¸ª "active" slab page ä¸Šã€‚  
  
1. å½“Â uaf_timer  
åœ¨ç«äº‰çª—å£å†…è¢«é‡Šæ”¾æ—¶ï¼Œtimer->sigq  
ä¼šè¢«æ”¾åˆ°è¯¥ active slab page freelist çš„è¡¨å¤´ã€‚  
  
1. æ­¤æ—¶å†åˆ†é…Â realloc_timer  
ï¼Œsigqueue_alloc()  
ä¼šå– freelist è¡¨å¤´çš„ entry æ¥æ»¡è¶³åˆ†é…ï¼Œè€Œå®ƒæ°å¥½å°±æ˜¯ä¸Šä¸€æ­¥åˆšé‡Šæ”¾çš„Â uaf_timer->sigq  
ã€‚  
  
> **æ³¨æ„**  
> uaf_timer  
æ˜¯ UAF timerï¼Œrealloc_timer  
æ˜¯é‡æ–°åˆ†é…å¾—åˆ°çš„ timerï¼Œå®ƒçš„Â ->sigq  
ä¼šå¤ç”¨Â uaf_timer->sigq  
çš„åŒä¸€å—å†…å­˜ã€‚  
  
  
åªè¦ free ä¸ reallocation å‘ç”Ÿåœ¨åŒä¸€é¢— CPU ä¸Šï¼Œå¹¶ä¸”éµå¾ªä¸Šé¢çš„ç¬¬ 2 æ­¥ï¼Œrealloc_timer->sigq  
å°±èƒ½ä¿è¯å¤ç”¨Â uaf_timer->sigq  
çš„åŒä¸€å—å†…å­˜ã€‚  
  
ä½†è¿™åˆ°åº•èƒ½å¸¦æ¥ä»€ä¹ˆï¼Ÿrealloc_timer->sigq  
æœ€ç»ˆåªæ˜¯ä½œä¸ºä¸€ä¸ª signal è½åœ¨ç›®æ ‡ task çš„Â pending  
(æˆ–Â shared_pending  
) list é‡Œã€‚ä»æ•ˆæœä¸Šçœ‹ï¼Œè¿™åªæ˜¯ä¸€ä¸ªâ€œæ­£å¸¸åˆ†é…â€çš„ signalï¼Œåœ¨è¿™é‡Œå¹¶ä¸ä¼šå‘ç”Ÿ memory corruptionâ€¦â€¦  
  
æŠŠè¿™ä¸ªæƒ³æ³•è®°ä½ï¼Œå› ä¸ºæœ€ç»ˆå¯ç”¨çš„ç­–ç•¥å®é™…ä¸Šå°±æ˜¯ä»è¿™é‡Œå»¶ä¼¸å‡ºæ¥çš„ï¼ğŸ˜‰  
### ç¬¬ä¸€ä¸ªæƒ³æ³•ï¼šæ½œåœ¨çš„â€œèµ¢å¾—ç«äº‰â€æ£€æµ‹æœºåˆ¶ï¼Ÿ  
  
ä¸è¿‡åœ¨å®ç°è¿™ä¸ª PoC æ—¶ï¼Œæˆ‘æ„è¯†åˆ°ä¸€ä»¶äº‹ï¼šrealloc_timer->sigq  
å…¶å®å¯ä»¥è¢«è®¾ç½®ä¸ºå‘é€ä¸åŒçš„ signal! å› æ­¤æˆ‘ä»¬å¯ä»¥æŒ‰ä»¥ä¸‹æ­¥éª¤æ£€æµ‹ï¼šæ˜¯å¦å‘½ä¸­äº†ç«äº‰çª—å£ï¼Œå¹¶æˆåŠŸé‡æ–°åˆ†é…äº†Â uaf_timer->sigq  
ï¼š  
1. è®©å…¨éƒ¨ 19 ä¸ª timers (18 ä¸ª stall timers + UAF timer) éƒ½å‘ thread group å‘é€Â SIGUSR1  
ã€‚  
  
1. åœ¨ç«äº‰çª—å£å†… free å¹¶é‡æ–°åˆ†é… UAF timerï¼Œä½†æŠŠé‡æ–°åˆ†é…å¾—åˆ°çš„ timer è®¾ç½®ä¸ºå‘é€Â SIGUSR2  
ã€‚  
  
1. å¯¹Â SIGUSR2  
çš„Â signalfd  
åš pollã€‚å¦‚æœæ”¶åˆ°äº†Â SIGUSR2  
ï¼Œè¯´æ˜ timer æˆåŠŸè¢«é‡æ–°åˆ†é… (send_sigqueue()  
çœ‹åˆ°äº†é‚£ä¸ªä¼šå‘é€Â SIGUSR2  
çš„ re-allocatedÂ timer->sigq  
)ï¼Œä¹Ÿå°±æ„å‘³ç€èµ¢å¾—äº†ç«äº‰ã€‚  
  
1. å¦‚æœæ²¡æœ‰è§‚å¯Ÿåˆ°Â SIGUSR2  
ï¼Œåˆ™è¯´æ˜ç«äº‰å¤±è´¥ã€‚  
  
è¿™å…¶å®å°±æ˜¯æˆ‘åœ¨æœ€ç»ˆ exploit ä¸­å®ç°çš„â€œèµ¢å¾—ç«äº‰â€æ£€æµ‹æœºåˆ¶ã€‚åé¢ä¼šè¯¦ç»†å±•å¼€ï¼  
### ç¬¬äºŒä¸ªæƒ³æ³•ï¼šé‡æ–°åˆ†é…ä¸ºÂ struct msg_msg  
  
è¿™ä¸ªæƒ³æ³•èµ·æºäºæˆ‘æ³¨æ„åˆ°ï¼šstruct sigqueue  
çš„Â list_head  
æŒ‡é’ˆä½äº offset 0ã€‚äºæ˜¯æˆ‘å»æ‰¾å…¶å®ƒåŒæ ·åœ¨ offset 0 å¤„åŒ…å«Â list_head  
æŒ‡é’ˆçš„ç»“æ„ä½“ï¼Œæœ€åæ‰¾åˆ°äº†Â struct msg_msg  
ã€‚ç›®æ ‡æ˜¯æŠŠÂ struct msg_msg  
type-confuse æˆÂ struct sigqueue  
ï¼Œå¹¶è®©å®ƒè¢«æ’å…¥åˆ°ç›®æ ‡ task çš„ pending list ä¸­ã€‚  
  
æˆ‘å¯¹æ¯”äº†Â struct sigqueue  
(code) ä¸Â struct msg_msg  
(code)ï¼Œå‘ç°ï¼š  
1. list_head  
æŒ‡é’ˆéƒ½åœ¨ offset 0ã€‚  
  
1. sigqueue->flags  
çš„ offset ä¸Â msg_msg->m_type  
å¯¹é½ï¼Œè€ŒÂ m_type  
åœ¨ userland å¯æ§ï¼å› æ­¤å¯ä»¥æŠŠÂ SIGQUEUE_PREALLOC  
ç½®ä½ã€‚  
  
è¿™çœ‹èµ·æ¥ç®€ç›´å®Œç¾ï¼šæˆ‘å¯ä»¥ç”¨ cross-cache exploitation æŠ€æœ¯ï¼ŒæŠŠ UAF çš„Â sigqueue  
slab page é‡Šæ”¾å› page allocatorï¼Œç„¶åæŠŠå®ƒé‡æ–°åˆ†é…æˆä¸€æ•´é¡µçš„Â struct msg_msg  
å¯¹è±¡ï¼Œä»è€Œè·å¾— type-confusion primitive!  
  
â€¦â€¦å¯¹å§ï¼Ÿ  
  
ä½†å…¶å®ä¸è¡Œã€‚è¿™æ¡è·¯æœ‰ä¸å°‘é—®é¢˜ï¼Œè€Œæˆ‘ç…§ä¾‹åˆèŠ±äº†å¾ˆå¤šå°æ—¶æ‰æŠŠè¿™äº›é—®é¢˜ç†æ¸… ğŸ˜…  
  
ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šå½“Â struct msg_msg  
è¢«åˆ†é…æ—¶ï¼Œlist_head->next  
æŒ‡é’ˆä¼šè¢«è®¾ç½®ä¸ºÂ NULL  
(code)ã€‚æ­¤å¤–ï¼Œè¿™ä¸ªÂ list_head  
åªä¼šè¢«æ’å…¥åˆ°æŸä¸ª list ä¸­ï¼Œæˆ–é€šè¿‡Â list_del()  
åˆ é™¤ (è€Œä¸æ˜¯Â list_del_init()  
ï¼›åè€…åœ¨åˆ é™¤çš„åŒæ—¶ä¼šæŠŠ list æ ‡è®°ä¸ºç©º)ã€‚  
  
è¿™ä¼šå¸¦æ¥ä¸€ä¸ªå¤§é—®é¢˜ï¼šsend_sigqueue()  
ä¸­æœ‰ä¸€ä¸ªÂ !list_empty()  
æ£€æŸ¥ï¼Œé™¤éæ»¡è¶³Â list_head->next == &list_head  
ï¼Œå¦åˆ™æ£€æŸ¥å°±ä¼šå¤±è´¥ (code):  
```
intsend_sigqueue(structÂ sigqueue *q,Â structÂ pid *pid,Â enumÂ pid_type type){// [ ... ]ifÂ (unlikely(!list_empty(&q->list))) {// [ ... ]gotoÂ out;Â }// [ ... ]out:// [ ... unlock sighand lock and return ... ]}staticinlineintlist_empty(conststructÂ list_head *head){returnREAD_ONCE(head->next) == head;}
```  
  
åœ¨è¿™é‡Œï¼Œå¯¹äºÂ struct msg_msg  
æ¥è¯´ï¼Œè¿™ä¸ªæ¡ä»¶Â æ°¸è¿œ  
ä¸ä¼šæˆç«‹ (ä¹Ÿå°±æ˜¯è¯¥ listÂ æ°¸è¿œ  
ä¸ä¼šä¸ºç©º)ã€‚  
  
ä¸å¹¸çš„æ˜¯ï¼Œå‘½è¿å¼„äºº ğŸ˜… â€”â€” è¿™æ°å¥½æ˜¯æˆ‘æœ€åæ‰æ„è¯†åˆ°çš„ç‚¹ã€‚  
  
å¦ä¸€ä¸ªé—®é¢˜æ›´éšè”½ï¼šåœ¨ kernelÂ **v5.10.157**  
ä¸­ï¼Œstruct msg_msg  
æ˜¯ä»æ™®é€šçš„Â kmalloc-X  
caches åˆ†é…çš„ã€‚è¿™ä¸ª cache å¯èƒ½æ˜¯Â kmalloc-64  
ï¼Œä¹Ÿå¯èƒ½ä¸€è·¯åˆ°Â kmalloc-1k  
æˆ–Â kmalloc-2k  
(æˆ‘ä¸ç¡®å®šÂ struct msg_msg  
çš„æœ€å¤§ size èƒ½åˆ°å¤šå¤§)ã€‚  
  
ä»Â kmalloc-X  
cache åˆ†é…å‡ºæ¥çš„æ¯ä¸ªå¯¹è±¡ï¼Œå³ä¾¿å®é™…åªç”¨åˆ°æ›´å°‘ bytesï¼Œä¹Ÿä¼šåœ¨é¡µé¢é‡Œå ç”¨å›ºå®šçš„Â X  
bytesã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªÂ 48  
bytes çš„å¯¹è±¡ä¼šä»Â kmalloc-64  
åˆ†é…ï¼Œå¹¶åœ¨æ¯æ¬¡åˆ†é…æ—¶å ç”¨Â 64  
bytesã€‚slab sizes å¯ä»¥è¿™æ ·æŸ¥çœ‹ï¼š  
```
/ # cat /sys/kernel/slab/kmalloc-64/slab_size64/ # cat /sys/kernel/slab/kmalloc-96/slab_size96
```  
  
è¿™é‡Œçš„é—®é¢˜åœ¨äºï¼šstruct sigqueue  
æ˜¯ä»ä¸€ä¸ªåä¸ºÂ sigqueue_cachep  
çš„ä¸“ç”¨Â kmem_cache  
ä¸­åˆ†é…çš„ã€‚struct sigqueue  
çš„å¤§å°æ˜¯Â 80  
bytesã€‚ç›´è§‰ä¸Šä½ ä¼šä»¥ä¸ºå®ƒçš„ slab size ä¼šæ˜¯Â 96  
bytesï¼Œå¯¹å§ï¼Ÿ  
```
/ # cat /sys/kernel/slab/sigqueue/object_size80/ # cat /sys/kernel/slab/sigqueue/slab_size80
```  
  
å¥½å§ï¼Œè¿™å°±å°´å°¬äº†ã€‚è¿™æ„å‘³ç€ï¼šå³ä¾¿æˆ‘ä»¬ç”¨ä¸€æ•´é¡µÂ struct msg_msg  
å¯¹è±¡å»è¦†ç›–æ€§åœ°é‡æ–°åˆ†é… UAFÂ sigqueue  
ï¼Œä¹Ÿæ— æ³•ä¿è¯æŸä¸ªÂ struct msg_msg  
ä¼šæ°å¥½è½åœ¨ UAFÂ sigqueue  
åŸæœ¬åˆ†é…çš„ä½ç½®ã€‚å¹¶ä¸” Android kernel è¿˜è®¾ç½®äº†Â CONFIG_SLAB_FREELIST_RANDOM=y  
ï¼Œè¿™ä¼šé˜»æ­¢æˆ‘ä»¬æ§åˆ¶Â uaf_timer->sigq  
åœ¨é¡µé¢ä¸­çš„å…·ä½“åˆ†é…ä½ç½®ã€‚  
  
åœ¨ç”¨ LLM è¾…åŠ©åšäº†ä¸€äº›æ•°å­¦æ¨ç®— (å°è¯•è®©Â 80  
bytes çš„åˆ†é…ä¸ slab page ä¸­çš„Â 16  
ã€32  
ã€64  
ã€96  
ã€128  
ã€256  
bytes å¯¹è±¡åˆ†é…è¿›è¡Œå¯¹é½) æ¥åˆ¤æ–­è¯¥æ–¹æ¡ˆæ˜¯å¦å¯è¡Œä¹‹åï¼Œæˆ‘å¾—å‡ºç»“è®ºï¼šè¿™ä¸ªæƒ³æ³•çš„å¯é æ€§è¿œä¸è¶³ä»¥æ”¯æ’‘ä¸€ä¸ª exploitã€‚  
  
æ‰€ä»¥â€¦â€¦æ¢ä¸ªæ€è·¯ï¼  
### ç¬¬ä¸‰ä¸ªæƒ³æ³•ï¼šç¬¬äºŒä¸ªã€æ›´å°çš„ç«äº‰çª—å£ï¼Ÿ  
  
å°±åœ¨è¿™æ—¶ï¼Œæˆ‘çªç„¶æ„è¯†åˆ°ä» ç¬¬ä¸€ä¸ªæƒ³æ³• å»¶ä¼¸å‡ºçš„ä¸€ä¸ªå…³é”®ç‚¹ï¼šç”±äºÂ struct k_itimer  
ä¼šåœ¨Â æ›´æ™š  
çš„æ—¶é—´é€šè¿‡ RCU é‡Šæ”¾ï¼Œå› æ­¤åœ¨ timer è¢«é‡æ–°åˆ†é…åï¼Œæˆ‘ä»¬å®é™…ä¼šå¤„äºå¦‚ä¸‹çŠ¶æ€ï¼š  
  
![UAF and reallocated timer relationship](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCPaZqqxK9GYFKIeFLPqibZSkzKlFLGkmlOevlrMhHzJsQlWuic5gM5Ly59SSc2WVAaGJHaoiaib2f5wibA/640?wx_fmt=png&from=appmsg "UAF and reallocated timer relationship")  
  
è¿™é‡Œçš„å…³é”®ç‚¹æ˜¯ï¼šuaf_timer->sigq == realloc_timer->sigq  
ï¼Œä½†Â uaf_timer != realloc_timer  
ã€‚  
  
ä¸ºä»€ä¹ˆè¿™å¾ˆé‡è¦ï¼Ÿ**å› ä¸ºå®ƒä»¬çš„Â ->it_lockä¸åŒ!**  
  
å¦‚æœæˆ‘ä»¬æˆåŠŸæŠŠÂ uaf_timer  
é‡æ–°åˆ†é…æˆÂ realloc_timer  
ï¼Œé‚£ä¹ˆå½“Â handle_posix_cpu_timers()  
è·å–Â timer->it_lock  
(code) æ—¶ï¼Œå®ƒå®é™…è·å–çš„æ˜¯Â uaf_timer->it_lock  
ï¼Œå› ä¸ºæœ¬åœ°Â firing  
list é‡Œæ”¶é›†åˆ°çš„è¿˜æ˜¯åŸæ¥çš„é‚£ä¸ª timer!  
  
è¿™ä¼šå¯¼è‡´Â realloc_timer->it_lock  
æ²¡æœ‰è¢«è·å–ï¼Œä»è€Œåœ¨Â send_sigqueue()  
å†…éƒ¨æ‰“å¼€äº†ç¬¬äºŒä¸ªç«äº‰çª—å£ (code):  
```
intsend_sigqueue(structÂ sigqueue *q,Â structÂ pid *pid,Â enumÂ pid_type type){// [ ... ]BUG_ON(!(q->flags & SIGQUEUE_PREALLOC));// [ ... race window starts ... ]Â ret = -1;rcu_read_lock();Â t =Â pid_task(pid, type);// [ ... race window ends ... ]ifÂ (!t || !likely(lock_task_sighand(t, &flags)))gotoÂ ret;// [ ... ]}
```  
  
è¿™ä¸ªç«äº‰çª—å£ä»Â BUG_ON()  
ä¹‹åç«‹åˆ»å¼€å§‹ã€‚åœ¨è¯¥çª—å£é‡Œï¼Œuaf_timer->it_lock  
æ­£è¢«æŒæœ‰ï¼Œä½†æˆ‘ä»¬ä»ç„¶å¯ä»¥å¯¹Â realloc_timer  
è°ƒç”¨Â timer_delete()  
ï¼Œå› ä¸ºÂ realloc_timer->it_lock  
å¹¶æ²¡æœ‰è¢«æŒæœ‰ã€‚è¿™æ ·å°±èƒ½ä»¥åŒæ ·çš„æ–¹å¼é‡Šæ”¾Â realloc_timer->sigq  
(åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œrealloc_timer  
æ˜¯é€šè¿‡Â kmem_cache_zalloc()  
åˆ†é…çš„ï¼Œå¹¶ä¸ä¼šè¢«æ ‡è®°ä¸ºÂ firing  
)ã€‚  
  
ä½†â€¦â€¦è¿™ä¸ªçª—å£æå…¶çŸ­ï¼Œå¹¶ä¸”æ²¡æœ‰åŠæ³•å»¶é•¿ã€‚æˆ‘ä»¬å·²ç»å¤„åœ¨ scheduler interrupt é‡Œï¼Œæ— æ³•åœ¨çª—å£å†…å†è§¦å‘å¦ä¸€ä¸ªä¸­æ–­ï¼›è€Œä¸”Â rcu_read_lock()  
ä¸Â pid_task()  
ä¹Ÿæ²¡æœ‰ä»»ä½•èƒ½æ¶ˆè€—â€œå¯æ§ CPU timeâ€çš„é‡æ´»ã€‚  
  
å°½ç®¡å¦‚æ­¤ï¼Œæˆ‘è¿˜æ˜¯åœ¨è¿™ä¸ªçª—å£é‡Œæ‰“äº†ä¸€ä¸ªÂ 500  
ms çš„å»¶è¿Ÿ patchï¼Œå¹¶æŠŠÂ free_timer_thread  
æ”¹æˆè¿™æ ·ï¼š  
```
voidfree_func(void) {// [ ... ]structÂ pollfd pfd = {Â  Â  Â  Â  .fdÂ = sigusr1_sfds[0],Â  Â  Â  Â  .eventsÂ = POLLINÂ  Â  };// Poll for SIGUSR1.forÂ (;;) {intÂ ret =Â poll(&pfd,Â 1,Â 0);// Got SIGUSR1 from the first stall timer, in race window now.ifÂ (pfd.reventsÂ & POLLIN) {SYSCHK(timer_delete(uaf_timer));// re-allocate `uaf_timer->sigq`SYSCHK(timer_create(/* ... */, &realloc_timer));// Sleep 250ms to be inside our patched race window for sureusleep(250Â *Â 1000);SYSCHK(timer_delete(realloc_timer));break;Â  Â  Â  Â  }// [ ... ]Â  Â  }}
```  
  
åœ¨è¿™ç§çŠ¶æ€ä¸‹è¿è¡Œ PoCï¼Œæˆ‘å¯ä»¥ç¡®è®¤è¢«é‡Šæ”¾çš„Â uaf_timer->sigq  
ç¡®å®è¢«æ’å…¥åˆ°äº†ç›®æ ‡ task çš„Â pending  
list ä¸­ (æˆ‘ç”¨ GDB æŸ¥çœ‹Â uaf_timer->sigq  
åœ¨Â sigqueue_cachep->offset  
å¤„çš„å†…å®¹ï¼›å¦‚æœå¯¹è±¡è¢« freeï¼Œslab freelist pointers ä¼šå†™åœ¨è¿™ä¸ª offset ä¸Š)ã€‚  
> **æç¤º**  
> åˆ›å»º timer æ—¶ï¼Œä½ å¯ä»¥æŠŠÂ struct sigevent  
çš„Â .sigev_value.sival_ptr  
è®¾ç½®æˆä¸€ä¸ªå”¯ä¸€å€¼ (ä¾‹å¦‚Â 0x4141414141414141  
)ã€‚ç„¶åä½ å¯ä»¥åœ¨Â do_timer_create()  
é‡Œæ‰“ä¸€ä¸ª kernel patchï¼Œæ£€æŸ¥è¿™ä¸ªå€¼ï¼Œå¹¶ç”¨Â printk()  
æ‰“å°å‡ºæ‰€åˆ†é…çš„Â timer->sigq  
åœ°å€ï¼Œæ–¹ä¾¿è°ƒè¯•ã€‚ä½ ä¼šåœ¨æˆ‘æœ€ç»ˆ exploit çš„æ³¨é‡Šä»£ç é‡Œçœ‹åˆ°æˆ‘å°±æ˜¯è¿™ä¹ˆåšçš„ã€‚ ğŸ˜‰  
  
  
æ­¤æ—¶çœŸæ­£çš„é—®é¢˜ä¸æ˜¯â€œçª—å£å¤ªå°â€ï¼Œè€Œæ˜¯Â BUG_ON()  
ã€‚å¦‚æœæ²¡æœ‰è¿™ä¸ªÂ BUG_ON()  
ï¼Œæˆ‘å°±å¯ä»¥åå¤æ‰§è¡Œè¿™ä¸ªæ­¥éª¤ï¼Œå¹¶è°ƒæ•´å»¶è¿Ÿï¼Œæ€»æœ‰æœºä¼šå‘½ä¸­é‚£ä¸ªå¾®å°çª—å£ã€‚  
> **æ³¨æ„**  
> å®é™…ä¸Šï¼Œåœ¨ä¸åŠ è¿™ä¸ª kernel patch äººå·¥å»¶è¿Ÿçš„æƒ…å†µä¸‹ï¼Œæˆ‘åœ¨æµ‹è¯•é‡Œä¹Ÿå‘½ä¸­è¿‡è¿™ä¸ªçª—å£ä¸å°‘æ¬¡ã€‚å®ƒå¾ˆä¸ç¨³å®šï¼Œè€Œä¸”è§¦å‘Â BUG_ON()  
çš„æ¬¡æ•°å‡ ä¹å’Œèµ¢å¾—ç«äº‰çš„æ¬¡æ•°ä¸€æ ·å¤šï¼Œä½†è‡³å°‘è¯æ˜å®ƒç¡®å®èƒ½å·¥ä½œï¼  
  
  
ä½†ç”±äº CPU æ¶ˆè€—ä»æ¥ä¸æ˜¯ 100% ç¨³å®šï¼Œtimer_delete(realloc_timer)  
è°ƒå¾—å¤ªæ—©å‡ ä¹ä¸å¯é¿å…ï¼Œå› æ­¤è¿™ä¸ªæ€è·¯å¹¶ä¸é€‚åˆæœ€ç»ˆ exploitã€‚  
  
æ‰€ä»¥â€¦â€¦æˆ‘åˆèŠ±äº†å¾ˆå¤šå°æ—¶å°è¯•å„ç§åŠæ³•æ¥å¢å¤§è¿™ä¸ªçª—å£ã€‚  
  
æˆ‘å°è¯•è¿‡çš„ä¸€ä»¶äº‹ï¼Œæ˜¯ç”¨åŒæ ·çš„Â signalfd_notify()  
æŠ€å·§ï¼šåœ¨Â send_sigqueue()  
è¿è¡Œæ—¶å”¤é†’å¦ä¸€ä¸ª threadï¼Œè®©å®ƒå»è°ƒç”¨Â timer_delete(realloc_timer)  
ã€‚å› ä¸ºÂ signalfd_notify()  
åœ¨Â realloc->sigq  
è¢«åŠ å…¥ task çš„ pending listÂ ä¹‹å‰  
å°±ä¼šè¢«è°ƒç”¨ï¼Œæ‰€ä»¥ç†è®ºä¸Šåº”è¯¥æœ‰è¶³å¤Ÿæ—¶é—´å”¤é†’å¦ä¸€ä¸ª threadï¼Œå¹¶åœ¨Â signalfd_notify()  
è¿”å›ä¹‹å‰é‡Šæ”¾Â realloc_timer->sigq  
ã€‚  
  
ä½†å®ƒå¹¶ä¸å¥æ•ˆâ€¦â€¦ç”±äºæŸç§åŸå› ï¼Œsigqueue_free()  
ä¸€ç›´æ— æ³•è·å–Â task->sighand->siglock  
ï¼Œç›´åˆ°Â handle_posix_cpu_timer()  
é‡Šæ”¾å®ƒä¸ºæ­¢ã€‚  
> **æç¤º**  
> æˆ‘é€šè¿‡åœ¨Â sigqueue_free()  
ä¸Â send_sigqueue()  
é‡Œæ’å…¥Â printk()  
æ¥å®šä½è¿™ä¸ªé”é—®é¢˜ã€‚  
  
  
ä½†ç›®æ ‡ task ä¸æ˜¯ä¸åŒçš„å—ï¼Ÿä¸ºä»€ä¹ˆä¼šæ‹¿ä¸åˆ°é”ï¼Ÿ  
  
è¿™æ—¶æˆ‘æ‰æ„è¯†åˆ°ï¼štask->sighand  
ç»“æ„ä½“å®é™…ä¸Šæ˜¯è¿›ç¨‹å†…æ‰€æœ‰ threads å…±äº«çš„ï¼å› æ­¤åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç”±äºÂ send_sigqueue()  
å†…çš„Â lock_task_sighand()  
è·å–çš„æ˜¯ç›®æ ‡ task çš„Â sighand  
lockï¼ŒåŒä¸€è¿›ç¨‹é‡Œçš„å…¶å®ƒ thread ä¸å¯èƒ½åœ¨æ­¤æœŸé—´é†’æ¥å¹¶åˆ é™¤ timerã€‚  
> **æ³¨æ„**  
> POSIX CPU timers ç»‘å®šåœ¨åˆ›å»ºå®ƒä»¬çš„è¿›ç¨‹ä¸Šã€‚è¿™æ„å‘³ç€åŒä¸€è¿›ç¨‹å†…çš„å…¶å®ƒ threads å¯ä»¥å¯¹å®ƒä»¬è°ƒç”¨Â timer_settime()  
/Â timer_delete()  
/ ç­‰ï¼Œä½†ä¸åŒè¿›ç¨‹æ— æ³•è¿™æ ·åšã€‚  
  
  
å¦‚æœæˆ‘æ²¡è®°é”™çš„è¯ï¼Œå½“æˆ‘æ„è¯†åˆ°è¿™ä¸€ç‚¹æ—¶å·²ç»å¿«å‡Œæ™¨ 5 ç‚¹äº†ã€‚æˆ‘å†³å®šå…ˆç¡è§‰ï¼Œç¬¬äºŒå¤©å†ç»§ç»­ã€‚  
  
ä¹Ÿå’Œå¾€å¸¸ä¸€æ ·ï¼Œèººä¸‹å‡†å¤‡ç¡è§‰æ—¶æˆ‘çš„è„‘å­åˆå¼€å§‹æŠŠå„ç§çº¿ç´¢ä¸²èµ·æ¥â€¦â€¦è€Œå…¶ä¸­ä¸€ä¸ªæƒ³æ³•ï¼Œæ°å¥½å¼•å‡ºäº†æˆ‘åœ¨æœ€ç»ˆ exploit ä¸­ä½¿ç”¨çš„ç­–ç•¥ï¼  
### ç¬¬å››ä¸ªæƒ³æ³•ï¼šDouble Insertion  
  
Linux kernel çš„ linked list å®ç°æ˜¯ä¸€ç§â€œIntrusive Linked Listâ€ã€‚å¦‚æœä½ ä»¥å‰æ²¡æ¥è§¦è¿‡ï¼Œå¼ºçƒˆå»ºè®®è¯»ä¸€ä¸‹è¿™ç¯‡æ–‡ç« ã€‚  
  
å…³äº intrusive linked listsï¼Œæœ€é‡è¦çš„ä¸€ç‚¹æ˜¯ï¼š  
> **é‡è¦**  
> æ°¸è¿œä¸è¦è®©åŒä¸€ä¸ªå¯¹è±¡å¼•ç”¨åœ¨åŒä¸€æ—¶é—´å­˜åœ¨äºå¤šäºä¸€ä¸ª linked list ä¸­ (åŒ…æ‹¬å®ƒè‡ªå·±)!  
  
  
äº‹å®ä¸Šï¼Œsend_sigqueue()  
é‡Œçš„Â !list_empty()  
æ£€æŸ¥æ­£æ˜¯ä¸ºè¿™ä¸ªåŸå› è€Œå­˜åœ¨çš„ï¼š  
```
intsend_sigqueue(structÂ sigqueue *q,Â structÂ pid *pid,Â enumÂ pid_type type){// [ ... ]ifÂ (unlikely(!list_empty(&q->list))) {// [ ... ]gotoÂ out;Â }// [ ... ]out:// [ ... unlock sighand lock and return ... ]}
```  
  
ä¸‹å›¾å±•ç¤ºäº† double-insertedÂ struct sigqueue  
åœ¨å†…å­˜ä¸­çš„æ ·å­ (å‡è®¾å®ƒå…ˆè¢«æ’å…¥ task 1ï¼Œç„¶åè¢«æ’å…¥ task 2ï¼Œå¹¶ä¸” pending lists ä¸­æ²¡æœ‰å…¶å®ƒ signals):  
  
![double inserted sigqueue](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCPaZqqxK9GYFKIeFLPqibZSkw02FdsgbE0QAt1iaKvhl6BnQMp381x1oC9I6wqCWicLF8uicl5pmQHTZA/640?wx_fmt=png&from=appmsg "double inserted sigqueue")  
  
æœ¬è´¨ä¸Šï¼Œè¿™ä¼šå¯¼è‡´ä¸€ç§çŠ¶æ€ï¼šstruct sigqueue  
â€œä»¥ä¸ºâ€è‡ªå·±åœ¨ task 2 çš„ pending list é‡Œï¼Œä½† task 1 å’Œ task 2 éƒ½â€œä»¥ä¸ºâ€Â struct sigqueue  
åœ¨å„è‡ªçš„ pending list é‡Œã€‚  
  
é—®é¢˜ä¼šåœ¨ç¨åå‘ç”Ÿï¼šå½“è¿™ä¸ªÂ struct sigqueue  
ä» pending list ä¸­è¢«ç§»é™¤æ—¶ (ä¾‹å¦‚å¯¹Â signalfd  
è°ƒç”¨Â read()  
)ã€‚æ­¤æ—¶ä¼šç”¨Â collect_signal()  
æ¥ dequeueÂ struct sigqueue  
(code)ï¼šå®ƒä¼šå…ˆç”¨Â list_del_init()  
æŠŠÂ struct sigqueue  
ä»çœŸå®çš„ pending list ä¸­ç§»é™¤ï¼Œç„¶åå†è°ƒç”¨Â __sigqueue_free()  
é‡Šæ”¾å®ƒã€‚  
```
staticvoidcollect_signal(intÂ sig,Â structÂ sigpending *list,Â kernel_siginfo_tÂ *info,boolÂ *resched_timer){// [ ... ]still_pending:list_del_init(&first->list);// [ ... ]ifÂ (first) {__sigqueue_free(first);Â }Â elseÂ {// [ ... ]Â }}
```  
  
list_del_init()  
çš„é€»è¾‘å¦‚ä¸‹ï¼š  
1. è®¾ç½®Â sigqueue->next->prev = sigqueue->prev  
ã€‚  
  
1. è®¾ç½®Â sigqueue->prev->next = sigqueue->next  
ã€‚  
  
1. è®¾ç½®Â sigqueue->next = &sigqueue  
ä¸”Â sigqueue->prev = &sigqueue  
ã€‚  
  
å›çœ‹ä¸Šé¢çš„å›¾ï¼Œé—®é¢˜å°±å¾ˆæ˜æ˜¾äº†ï¼šæ— è®ºå“ªä¸ª list æ¥ dequeue è¿™ä¸ªÂ struct sigqueue  
ï¼Œtask 1 çš„ pending list é‡Œçš„æŒ‡é’ˆéƒ½æ°¸è¿œä¸ä¼šè¢«æ›´æ–°ã€‚å¹¶ä¸”ç”±äºÂ struct sigqueue  
çš„Â .next  
ä¸Â .prev  
è¢«æ›´æ–°ä¸ºæŒ‡å›è‡ªèº«ï¼Œè¿™ä¸ªÂ struct sigqueue  
ä¼šæ°¸è¿œå¡åœ¨ task 1 çš„ pending list é‡Œ (å¦‚æœÂ __sigqueue_free()  
çœŸçš„æŠŠå®ƒ free äº†ï¼Œé‚£å®ƒç”šè‡³å¯èƒ½ä»¥â€œå·²é‡Šæ”¾å¯¹è±¡â€çš„å½¢å¼å¡åœ¨é‚£é‡Œ)!  
  
ä¸‹å›¾å±•ç¤ºäº†è¿™ç§æƒ…å†µï¼š  
  
![double inserted then freed](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCPaZqqxK9GYFKIeFLPqibZSk4usfpllNmqoImrdm3aGU01IrxfGCJyTLQkFDcvUsWibI5I3r8GTUSJA/640?wx_fmt=png&from=appmsg "double inserted then freed")  
  
æ‰€ä»¥ï¼Œåœ¨ç¡äº†ä¸€è§‰ã€è®©å¤§è„‘æŠŠè¿™äº›çº¿ç´¢ä¸²èµ·æ¥ä¹‹åï¼Œæˆ‘æœ€ç»ˆæå‡ºäº†è¿™æ ·ä¸€ä¸ªè®¡åˆ’ï¼š  
1. è¿›å…¥ç«äº‰çª—å£å¹¶ freeÂ uaf_timer  
â€” ä¸ä¹‹å‰ç›¸åŒã€‚  
  
1. ä¸åœ¨åŒä¸€è¿›ç¨‹å†…é‡æ–°åˆ†é…Â realloc_timer->sigq  
ï¼Œè€Œæ˜¯ä¸å¦ä¸€ä¸ªè¿›ç¨‹é€šä¿¡ (åœ¨æˆ‘çš„ exploit ä¸­æ˜¯â€œparentâ€è¿›ç¨‹)ï¼Œè®©å®ƒæ¥é‡æ–°åˆ†é…Â realloc_timer->sigq  
(å¿…é¡»åœ¨åŒä¸€ CPU ä¸Šï¼Œå› ä¸º slab freelists æ˜¯ per-CPU çš„)ã€‚  
  
1. ç¡®ä¿Â realloc_timer->sigq  
ä¼šå‘é€Â SIGUSR2  
ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½æ£€æµ‹æ˜¯å¦èµ¢å¾—äº†ç«äº‰ã€‚  
  
1. parent è¿›ç¨‹ä½¿ç”¨Â usleep()  
ç¡ä¸€ä¸ªå¯é…ç½®çš„æ—¶é•¿ï¼Œè®© child è¿›ç¨‹æœ‰æ—¶é—´å¸¦ç€Â uaf_timer->sigq  
è¿›å…¥Â send_sigqueue()  
ã€‚å¦‚æœç«äº‰å¤±è´¥ï¼Œæ¯æ¬¡é‡è¯•éƒ½ä¼šæŒ‰Â PARENT_SETTIME_DELAY_US_DELTA  
è°ƒæ•´è¿™ä¸ªå¯é…ç½®æ—¶é•¿ã€‚  
  
1. parent è¿›ç¨‹åœ¨ sleep ä¹‹åç«‹åˆ»è°ƒç”¨Â timer_settime(realloc_timer)  
ï¼Œå¹¶å¸¦ä¸ŠÂ TIMER_ABSTIME  
æ ‡å¿—ï¼Œä¸”å°†Â struct itimerspec  
è®¾ç½®ä¸ºâ€œè¿‡å»çš„æ—¶é—´â€ã€‚  
  
1. ç”±äºè®¾ç½®çš„æ˜¯è¿‡å»çš„æ—¶é—´ï¼Œä¼šå¯¼è‡´Â posix_cpu_timer_set()  
å†…ç«‹å³è°ƒç”¨Â cpu_timer_fire()  
(code)ã€‚  
  
1. å¦‚æœ parent çš„ sleep æ—¶é•¿æ°åˆ°å¥½å¤„ï¼Œchild è¿›ç¨‹æ­¤æ—¶åº”è¯¥æ­£å¤„äºæºå¸¦Â uaf_timer->sigq  
çš„Â send_sigqueue()  
å†…éƒ¨ã€‚  
  
æ­¤æ—¶ï¼Œä¸¤ä¸ªè¿›ç¨‹ä¼šåœ¨æŒæœ‰ä»¥ä¸‹ locks çš„æƒ…å†µä¸‹è¿›å…¥Â send_sigqueue()  
ï¼š  
- **å­è¿›ç¨‹**  
- uaf_timer->it_lock  
- è‡ªå·±è¿›ç¨‹çš„Â sighand->siglock  
  
- **çˆ¶è¿›ç¨‹**  
- realloc_timer->it_lock  
- è‡ªå·±è¿›ç¨‹çš„Â sighand->siglock  
  
å¦‚ä½ æ‰€è§ï¼Œè¿™äº› locks éƒ½ä¸ç›¸åŒï¼Œå› æ­¤ parent ä¸ child åœ¨Â send_sigqueue()  
ä¸­å¹¶å‘æ‰§è¡Œä¸ä¼šå‘ç”Ÿé”å†²çªã€‚  
  
child è¿›ç¨‹è¿˜éœ€è¦é¢å¤–å‡†å¤‡ä¸€ä»¶äº‹ï¼šåŒæ ·ä¸ºÂ SIGUSR2  
çš„Â signalfd  
æŒ‚ä¸Š 50,000 ä¸ª epoll waitersã€‚è¿™æ ·å¯ä»¥å»¶é•¿ç¬¬äºŒä¸ªç«äº‰çª—å£ï¼Œå› ä¸º child è¿›ç¨‹åœ¨æŠŠ signal queue åˆ°è‡ªå·± task çš„ pending list ä¹‹å‰ä¼šå…ˆè°ƒç”¨Â signalfd_notify()  
(code)ï¼Œè€ŒÂ signalfd_notify()  
ä¼šèŠ±ä¸å°‘æ—¶é—´å»å”¤é†’è¿™ 50,000 ä¸ª epoll waitersã€‚  
> **é‡è¦**  
> ä¹‹æ‰€ä»¥ä½¿ç”¨Â timer_settime()  
æ¥åš double insertionï¼Œè€Œä¸æ˜¯åœ¨ (å¦‚ä»Šç¨é•¿çš„) ç«äº‰çª—å£é‡Œç›´æ¥åˆ é™¤ timerï¼Œå¦ä¸€ä¸ªåŸå› æ˜¯ï¼šè¿™æ ·å¯ä»¥é¿å…æ„å¤–è§¦å‘Â BUG_ON()  
ã€‚  
  
  
å½“å‰ exploit ä¸­å°±å®ç°äº†è¿™ä¸€ç‚¹ (ä¸ºç®€æ´èµ·è§çœç•¥å¤§é‡ä»£ç )ã€‚free_func()  
thread ä¸€æ—¦çœ‹åˆ°Â SIGUSR1  
signal å°±ç«‹åˆ»åˆ é™¤Â uaf_timer  
ï¼Œç„¶åé€šè¿‡ pipe ä¸ parent è¿›ç¨‹é€šä¿¡ã€‚parent éšåé‡æ–°åˆ†é…Â realloc_timer  
ï¼ŒsleepÂ parent_settime_delay  
ï¼Œå†ç”¨ä¸€ä¸ªâ€œè¿‡å»çš„æ—¶é—´â€è°ƒç”¨Â timer_settime()  
:  
```
// In child process's `free_func()` threadforÂ (;;) {intÂ ret =Â poll(&pfd,Â 1,Â 0);// Got SIGUSR1 from the first stall timer, in race window now.ifÂ (pfd.reventsÂ & POLLIN) {SYSCHK(timer_delete(uaf_timer));// Change CPUs so the parent process can continue using our// CPU to re-allocate the same `uaf_timer->sigq`.pin_on_cpu(0);SYSCHK(write(exploit_child_to_parent[1], SUCCESS_STR,Â 1));Â // sync 4.SUCCESS// Barrier used for unrelated synchronizationpthread_barrier_wait(&barrier);Â // barrier 4break;Â  Â  }}// In parent process, pin to the same CPU as the `uaf_timer` was freed on,// then wait for the child to tell us to re-allocate.pin_on_cpu(3);SYSCHK(read(exploit_child_to_parent[0], &m,Â 1));Â // sync 4ifÂ (m == SUCCESS_CHAR) {// reallocateSYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &realloc_evt, &realloc_timer));// configurable sleep timeusleep(parent_settime_delay);// Call `cpu_timer_fire()`SYSCHK(timer_settime(realloc_timer, TIMER_ABSTIME, &fire_ts,Â NULL));
```  
## å¿«é€Ÿå£°æ˜ï¼šExploit å¤æ‚åº¦  
  
åˆ°è¿™é‡Œï¼Œexploit çš„å¤æ‚åº¦å·²ç»åˆ°äº†ä¸€ä¸ªç›¸å½“é«˜çš„æ°´å¹³ï¼Œä¸»è¦åŸå› æ˜¯è¿™æ˜¯ä¸€ä¸ªç«äº‰æ¡ä»¶æ¼æ´ï¼Œå¹¶ä¸”ä¸ºäº†è®© exploit æˆç«‹ï¼Œparent ä¸ child è¿›ç¨‹ä¹‹é—´éœ€è¦è¿›è¡Œå¤§é‡é€šä¿¡ä¸åŒæ­¥ã€‚  
  
å¾ˆé—æ†¾ï¼Œæˆ‘æ— æ³•åƒå‰ä¸¤ç¯‡æ–‡ç« è®² PoC é‚£æ ·ï¼Œå¯¹ exploit åšé€è¡Œè®²è§£ã€‚è¯´å®è¯ï¼Œå³ä¾¿æˆ‘å†™äº†å¤§é‡æ³¨é‡Šï¼Œæˆ‘æœ‰æ—¶ä»ç„¶å¾ˆéš¾æŠŠè‡ªå·±çš„ exploit å‘è‡ªå·±è§£é‡Šæ¸…æ¥šâ€¦â€¦ ğŸ˜…  
  
ç†è§£è¿™ä¸ª exploit çš„æœ€ä½³æ–¹å¼æ˜¯ï¼šå…ˆæŠŠè¿™ç¯‡åšå®¢è¯»å®Œï¼Œå†é€šè¯»æˆ‘çš„ exploitï¼Œç„¶åç”¨ä½ è‡ªå·±çš„æ–¹å¼é‡å†™ä¸€éï¼Œå¹¶æŒ‰ä½ è®¤ä¸ºå¯è¡Œçš„æ–¹å¼å»åŒæ­¥ä¸¤ä¸ªè¿›ç¨‹ã€‚  
  
å½“ç„¶ï¼Œå¦‚æœä½ å¯¹ exploit çš„æŸäº›å…·ä½“éƒ¨åˆ†æœ‰ç–‘é—®ï¼Œä¹Ÿæ¬¢è¿åœ¨ X ä¸Šç§ä¿¡æˆ‘ï¼Œæˆ‘ä¼šå°½åŠ›å¸®ä½ è§£ç­”ï¼  
## æˆ‘åœ¨å“ªä¸ª List é‡Œï¼Ÿ  
  
åˆ°è¿™é‡Œï¼Œè¯·è®°ä½Â realloc_timer  
æ˜¯ç”± parent è¿›ç¨‹è®¾ç½®è§¦å‘çš„ã€‚å‡è®¾Â realloc_timer->sigq == uaf_timer->sigq  
ï¼Œé‚£ä¹ˆä¼šæœ‰å››ç§å¯èƒ½çš„ç»“æœï¼š  
1. èµ¢å¾—ç¬¬äºŒæ¬¡ç«äº‰ï¼šrealloc_timer->sigq  
å…ˆè¢«æ’å…¥ parent è¿›ç¨‹ï¼Œç„¶åæ’å…¥ child è¿›ç¨‹ã€‚  
  
1. èµ¢å¾—ç¬¬äºŒæ¬¡ç«äº‰ï¼šrealloc_timer->sigq  
å…ˆè¢«æ’å…¥ child è¿›ç¨‹ï¼Œç„¶åæ’å…¥ parent è¿›ç¨‹ã€‚  
  
1. ç«äº‰å¤±è´¥ï¼šparent è°ƒç”¨Â timer_settime()  
å¤ªÂ æ—©  
ï¼Œå› æ­¤ parent æˆåŠŸæ’å…¥ï¼Œä½† child æœªèƒ½æ’å…¥åˆ°è‡ªå·±çš„ listã€‚  
  
1. ç«äº‰å¤±è´¥ï¼šparent è°ƒç”¨Â timer_settime()  
å¤ªÂ æ™š  
ï¼Œå› æ­¤ parent æ’å…¥å¤±è´¥ï¼Œä½† child æˆåŠŸæ’å…¥åˆ°è‡ªå·±çš„ listã€‚  
  
é—®é¢˜æ˜¯ï¼š**æˆ‘ä»¬å¦‚ä½•åˆ¤æ–­è‡ªå·±å¤„äºè¿™å››ç§æƒ…å†µä¸­çš„å“ªä¸€ç§ï¼Ÿ**  
### ç«äº‰å¤±è´¥ï¼šToo Early æˆ– Too Late?  
  
å…ˆçœ‹ç¬¬ 3ã€4 ç§æƒ…å†µï¼Œå› ä¸ºå®ƒä»¬æ›´å®¹æ˜“è§£é‡Šã€‚æ³¨æ„ï¼š**æˆ‘ä»¬å·²ç»é€šè¿‡åœ¨ child è¿›ç¨‹é‡Œ pollÂ SIGUSR2ï¼Œç¡®è®¤äº† free -> re-allocation æ˜¯å¦æˆåŠŸè§¦å‘ã€‚**  
  
åœ¨Â send_sigqueue()  
ä¸­ï¼Œå¦‚æœÂ !list_empty()  
æ£€æŸ¥å¤±è´¥ï¼Œä¼šå‘ç”Ÿå¦‚ä¸‹è¡Œä¸º (code):  
```
intsend_sigqueue(structÂ sigqueue *q,Â structÂ pid *pid,Â enumÂ pid_type type){// [ ... ]ifÂ (unlikely(!list_empty(&q->list))) {BUG_ON(q->info.si_codeÂ != SI_TIMER);Â  q->info.si_overrun++;Â  result = TRACE_SIGNAL_ALREADY_PENDING;gotoÂ out;Â }// [ ... ]out:// [ ... ] unlock and exit}
```  
  
å…³é”®å°±åœ¨è¿™ä¸€è¡Œï¼šq->info.si_overrun++  
ã€‚å®ƒæ˜¯ä¸€ä¸ªå¯ä»¥ç”¨æ¥åˆ¤æ–­â€œtimer_settime()  
è°ƒå¾—å¤ªæ—©è¿˜æ˜¯å¤ªæ™šâ€çš„ primitiveã€‚  
  
è¦ç†è§£å®ƒä¸ºä»€ä¹ˆæœ‰ç”¨ï¼Œå¯ä»¥å…ˆè€ƒè™‘ï¼šparent è¿›ç¨‹è°ƒç”¨Â timer_settime()  
å¹¶è®© timer ç«‹åˆ»è§¦å‘ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œåªæœ‰Â ä¸€ç§  
åœºæ™¯ä¼šè®©Â realloc_timer->sigq  
(å‘é€Â SIGUSR2  
) æ— æ³•è¢« queue åˆ° parent è¿›ç¨‹çš„ pending listï¼šå®ƒè¿‡æ—©åœ°è¢« queue åˆ° child è¿›ç¨‹çš„ pending list ä¸­ï¼Œè¿™æ„å‘³ç€Â timer_settime()è°ƒå¾—å¤ªæ™šã€‚  
  
å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ä»¥ä¸‹æ–¹å¼åˆ¤æ–­ç¬¬ 3 ç§æƒ…å†µï¼š  
1. parent è°ƒç”¨Â timer_settime()  
ä¸” timer è§¦å‘åï¼Œè®© child è¿›ç¨‹ pollÂ SIGUSR2  
ã€‚  
  
1. å¦‚æœ child æ”¶åˆ°Â SIGUSR2  
ï¼Œè¯´æ˜Â realloc->sigq  
å·²è¢« queue åˆ° child çš„ pending listã€‚child å‘ parent å‘é€ "success"ã€‚  
  
1. æ­¤æ—¶ç¬¬äºŒæ¬¡ç«äº‰Â å¯èƒ½  
å·²ç»èµ¢äº†ã€‚  
  
1. å¦‚æœ child æ²¡æ”¶åˆ°Â SIGUSR2  
ï¼Œåˆ™ç¬¬äºŒæ¬¡ç«äº‰ç¡®å®šå¤±è´¥ã€‚child å‘ parent å‘é€ "fail"ã€‚  
  
1. æ­¤æ—¶è¦ä¹ˆåŸå§‹çš„ free -> re-allocation å¤±è´¥ï¼Œè¦ä¹ˆ parent è°ƒÂ timer_settime()  
å¤ªæ—©å¹¶å·²å…ˆæ’å…¥ï¼Œä»è€Œå¯¼è‡´ child æ— æ³•æŠŠÂ uaf_timer->sigq  
æ’å…¥åˆ°è‡ªå·±çš„ listã€‚  
  
1. ä¸ç®¡æ˜¯å“ªç§æƒ…å†µï¼Œparent çš„ pending list é‡Œä¸€å®šä¼šæœ‰Â SIGUSR2  
ï¼Œå› ä¸ºæ˜¯ parent è§¦å‘çš„ã€‚  
  
1. å¦‚æœ parent æ”¶åˆ° "success"ï¼Œåˆ™ parent å†æ£€æŸ¥è‡ªå·±æ˜¯å¦ä¹Ÿèƒ½æ”¶åˆ°Â SIGUSR2  
ã€‚  
  
1. å¦‚æœ parent ä¹Ÿæ”¶åˆ°äº†Â SIGUSR2  
ï¼Œè¯´æ˜ç«äº‰æˆåŠŸèµ¢å¾—ï¼šrealloc_timer->sigq  
åŒæ—¶å‡ºç°åœ¨ child ä¸ parent çš„ pending list ä¸­ã€‚  
  
1. å¦‚æœ parent æ²¡æ”¶åˆ°Â SIGUSR2  
ï¼Œåˆ™è¯´æ˜Â timer_settime()  
è°ƒå¾—å¤ªæ™šï¼šchild åœ¨ parent é€šè¿‡Â send_sigqueue()  
çš„Â !list_empty()  
æ£€æŸ¥ä¹‹å‰å°±å·²ç»å…ˆæ’å…¥äº†ã€‚  
  
å…³é”®åœ¨äºç¬¬ 3 æ­¥ï¼šä¸ºäº†åŒºåˆ†â€œparent çš„Â timer_settime()  
è°ƒå¾—å¤ªæ—©â€å’Œâ€œåŸå§‹ free -> re-allocation å¤±è´¥ (å› ä¸ºÂ handle_posix_cpu_timers()  
æ²¡åœ¨æ­£ç¡®æ—¶æœºè¢«è°ƒç”¨)â€è¿™ä¸¤ç§æƒ…å†µï¼Œæˆ‘ä»¬éœ€è¦ç”¨åˆ°ä¸Šé¢çš„Â q->info.si_overrun++  
primitiveã€‚  
  
åŸºæœ¬æ€è·¯å¦‚ä¸‹ï¼š  
- å¦‚æœ free -> re-allocation å¤±è´¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ ¹æœ¬æ²¡æœ‰è§¦å‘ä»»ä½• UAFã€‚ä¸ç®¡æ€æ ·ï¼Œrealloc_timer->sigq  
åªä¼šè¢« queue åˆ° parent çš„ listï¼Œchild æ°¸è¿œçœ‹ä¸åˆ°å®ƒã€‚  
  
- è¿™ä¼šå¯¼è‡´å…¶Â si_overrun  
ä¸º 0ï¼Œå› ä¸ºæ²¡æœ‰å…¶å®ƒè¿›ç¨‹å°è¯•åŒæ—¶ queue å®ƒã€‚  
  
- å¦‚æœ free -> re-allocation æˆåŠŸï¼Œä½† childÂ ä»ç„¶  
çœ‹ä¸åˆ°Â SIGUSR2  
ï¼Œé‚£å°±Â ä¸€å®š  
è¡¨ç¤º child å°è¯• queue åˆ°è‡ªå·±çš„ pending listï¼Œä½†åœ¨Â send_sigqueue()  
é‡Œæ²¡èƒ½é€šè¿‡Â !list_empty()  
æ£€æŸ¥ã€‚  
  
- è¿™ä¼šå¯¼è‡´ child æŠŠÂ si_overrun  
å¢åŠ åˆ° 1ï¼Œè€Œ parent å¯ä»¥æ£€æµ‹åˆ°è¿™ä¸€ç‚¹ã€‚  
  
å¦‚æœ parent çœ‹åˆ° child æ²¡æ”¶åˆ°Â SIGUSR2  
ï¼Œæ­¤æ—¶å°±å¯ä»¥æ£€æŸ¥Â si_overrun  
ã€‚å¦‚æœå‘ç°å®ƒå¤§äºÂ 0  
ï¼Œåˆ™è¯´æ˜Â timer_settime()  
è°ƒå¾—å¤ªæ—©ã€‚ä¸‹ä¸€æ¬¡é‡è¯•æ—¶å¯ä»¥å¢å¤§Â parent_settime_delay  
(åœ¨è°ƒç”¨Â timer_settime()  
å‰ sleep çš„å¾®ç§’æ•°)ã€‚  
  
å¯¹åº”åœ°ï¼Œå¦‚æœ child å·²ç»çœ‹åˆ°äº†Â SIGUSR2  
ï¼Œä½† parent å´çœ‹ä¸åˆ°ï¼Œè¯´æ˜Â timer_settime()  
è°ƒå¾—å¤ªæ™šï¼Œå› æ­¤ä¸‹ä¸€æ¬¡é‡è¯•è¦å‡å°Â parent_settime_delay  
ã€‚  
  
è‡³æ­¤ï¼Œæˆ‘ä»¬è¦†ç›–äº†ä¸Šé¢ç¬¬ 3ã€4 ç§â€œç«äº‰å¤±è´¥â€åœºæ™¯ã€‚é‚£æ¥ä¸‹æ¥ï¼Œå¦‚ä½•åˆ¤æ–­â€œèµ¢äº†ç«äº‰â€æ—¶åˆ°åº•æ˜¯å“ªä¸€ç§èµ¢æ³•ï¼Ÿ  
### ç«äº‰èƒœåˆ©ï¼šList æŒ‡å‘æ£€æµ‹  
  
å½“ parent ä¸ child éƒ½çœ‹åˆ°äº†Â SIGUSR2  
signal æ—¶ï¼Œæˆ‘ä»¬å°±èƒ½ç¡®å®šï¼šç«äº‰å·²ç»èµ¢äº†ã€‚æ¥ä¸‹æ¥è¦å¼„æ¸…æ¥šÂ realloc_timer->sigq->list  
æŒ‡é’ˆåˆ°åº•æŒ‡å‘å“ªé‡Œ â€”â€”Â **æ˜¯æŒ‡å‘ parent çš„ pending listï¼Œè¿˜æ˜¯ child çš„ pending list?**  
  
ä¸ºæ­¤ï¼Œæˆ‘æå‡ºäº†ä»¥ä¸‹ç­–ç•¥ï¼š  
1. åœ¨ parent ä¸­å…ˆè°ƒç”¨Â timer_delete(realloc_timer)  
ã€‚  
  
1. è¿™ä¼šé‡Šæ”¾ timerï¼Œä½†ä¸ä¼šé‡Šæ”¾Â realloc_timer->sigq  
ï¼Œå› ä¸ºå®ƒä»ç„¶å±äºæŸä¸ª task çš„ pending listã€‚  
  
1. ä»æ­¤ä»¥åï¼Œæˆ‘ä»¬æŠŠÂ realloc_timer->sigq  
ç§°ä¸ºÂ uaf_sigqueue  
ã€‚  
  
1. ç„¶ååœ¨ parent è¿›ç¨‹ä¸­å¯¹Â uaf_sigqueue  
è°ƒç”¨Â signalfd_read()  
æ¥ dequeueã€‚  
  
1. å¦‚æœÂ uaf_sigqueue->list  
æŒ‡é’ˆæŒ‡å‘ parentï¼Œé‚£ä¹ˆ parent çš„ pending list ä¼šå¤±å»å¯¹Â uaf_sigqueue  
çš„å¼•ç”¨ã€‚  
  
1. åä¹‹äº¦ç„¶ï¼šå¦‚æœæŒ‡å‘ childï¼Œåˆ™ child çš„ pending list ä¼šå¤±å»å¼•ç”¨ã€‚  
  
å›åˆ° double insertion çš„ä¾‹å­ï¼Œä¸‹å›¾å±•ç¤ºä¼šå‘ç”Ÿä»€ä¹ˆã€‚é¦–å…ˆæ˜¯ double insertion ä¹‹åï¼š  
  
![double inserted](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCPaZqqxK9GYFKIeFLPqibZSkw02FdsgbE0QAt1iaKvhl6BnQMp381x1oC9I6wqCWicLF8uicl5pmQHTZA/640?wx_fmt=png&from=appmsg "double inserted")  
  
ç„¶åæ˜¯ dequeue ä¹‹åï¼š  
  
![double insertion freed](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCPaZqqxK9GYFKIeFLPqibZSk4usfpllNmqoImrdm3aGU01IrxfGCJyTLQkFDcvUsWibI5I3r8GTUSJA/640?wx_fmt=png&from=appmsg "double insertion freed")  
> **æç¤º**  
> æ— è®ºå“ªä¸ª task æ¥ dequeueÂ struct sigqueue  
éƒ½æ— å…³ç´§è¦ï¼Œå…³é”®åªåœ¨äºÂ struct sigqueue  
çš„Â list  
æŒ‡é’ˆå½“å‰æŒ‡å‘å“ªé‡Œã€‚æœ€ç»ˆç»“æœæ€»æ˜¯ä¸€æ ·çš„ã€‚  
  
  
æ­¤æ—¶ parent è¿›ç¨‹å¯ä»¥æœ€åå†Â poll()  
ä¸€æ¬¡Â SIGUSR2  
ã€‚å¦‚æœå®ƒÂ ä»ç„¶  
èƒ½æ£€æµ‹åˆ°è¯¥ signalï¼Œå°±è¯´æ˜Â uaf_sigqueue->list  
æŒ‡é’ˆåŸæœ¬æŒ‡å‘çš„æ˜¯ child çš„ pending listã€‚ç°åœ¨ parent è¿›ç¨‹å¯ä»¥æ— é™æ¬¡ free è¿™ä¸ªÂ uaf_sigqueue  
ã€‚  
> **æ³¨æ„**  
> åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç»“åˆä¸Šå›¾ï¼Œparent è¿›ç¨‹å°±æ˜¯ task 1ã€‚  
  
  
å¦‚æœ parent æ— æ³•æ£€æµ‹åˆ°Â SIGUSR2  
ï¼Œå°±è¯´æ˜Â uaf_sigqueue->list  
æŒ‡é’ˆåŸæœ¬æŒ‡å‘ parent çš„ pending listã€‚æ­¤æ—¶ child è¿›ç¨‹å¯ä»¥æ— é™æ¬¡ freeÂ uaf_sigqueue  
ã€‚  
> **é‡è¦**  
> å¿…é¡»æŠŠè¿™ä»¶äº‹ææ¸…æ¥šï¼Œå› ä¸ºæˆ‘ä»¬å¯¹å·²é‡Šæ”¾Â uaf_sigqueue  
çš„å”¯ä¸€å¼•ç”¨æ¥è‡ª task çš„ pending listã€‚å¦‚æœæ— æ³•åˆ¤æ–­Â uaf_sigqueue  
åœ¨å“ªä¸ªè¿›ç¨‹çš„ pending list é‡Œï¼Œæˆ‘ä»¬å°±æ— æ³•ç»§ç»­ã€‚  
  
  
å†è¡¥å……ä¸€ç‚¹ï¼šåœ¨ç¬¬ 2 æ­¥ä¸­ï¼Œparent é€šè¿‡Â signalfd_read()  
dequeueÂ uaf_sigqueue  
ä¹‹åï¼Œuaf_sigqueue  
ä¼šè¢«é‡Šæ”¾ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬æ­¤å‰å·²ç»åˆ é™¤äº†Â realloc_timer  
ã€‚  
## Cross-caching å›åˆ° Page Allocator  
  
åœ¨æˆ‘çš„ exploit ä¸­ï¼Œè¿™é‡Œä¼šè¿›å…¥Â second_stage_exploit()  
ã€‚  
  
å…³äº cross-cache exploitation æŠ€æœ¯ï¼Œæˆ‘ä¸ä¼šå±•å¼€å¤ªå¤šï¼Œå› ä¸ºå¾ˆå¤šæ–‡ç« ä¸åšå®¢å·²ç»è®²è¿‡ã€‚æ›´å…·ä½“çš„å®ç°ç»†èŠ‚å¯ä»¥å‚è€ƒ exploit ä¸­ä»¥ä¸‹å‡½æ•°åŠå…¶è°ƒç”¨ç‚¹ï¼š  
1. sigqueue_crosscache_preallocs()  
â€” åœ¨åˆ†é…Â uaf_timer  
ä¹‹å‰æ‰§è¡Œ pre-allocationsã€‚  
  
1. sigqueue_crosscache_postallocs()  
â€” åœ¨Â uaf_sigqueue  
è¢« dequeue å¹¶é‡Šæ”¾åæ‰§è¡Œ post-allocationsã€‚  
  
1. free_crosscache_sigqueues()  
â€” æŒ‰ç‰¹å®šé¡ºåºé‡Šæ”¾ pre-allocations ä¸ post-allocationsï¼ŒæŠŠÂ uaf_sigqueue  
çš„ slab page é€å› page allocatorã€‚  
  
> **æç¤º**  
> ä½ å¯ä»¥ç”¨ GDB GEF çš„Â xslab -r <addr>  
å‘½ä»¤ï¼Œæ‰¾åˆ°æŸä¸ª slab allocation å¯¹åº”çš„Â struct page *  
åœ°å€ã€‚  
  
> **æç¤º**  
> ä½ å¯ä»¥åœ¨Â discard_slab()  
ä¸Šä¸‹æ–­ç‚¹ï¼Œå¹¶å°†å…¶Â page  
å‚æ•°ä¸ç›®æ ‡ slab allocation çš„Â struct page *  
åœ°å€è¿›è¡Œæ¯”å¯¹ï¼Œç”¨äºè°ƒè¯•ä½ çš„ cross-cache å®ç°ã€‚  
  
## è·å–å †æ³„æ¼  
  
ç”±äºÂ sigqueue_cachep  
åˆ†é…çš„æ˜¯ order-0 pagesï¼Œæˆ‘å†³å®šæŠŠÂ uaf_sigqueue  
è¿™é¡µé‡æ–°åˆ†é…æˆ pipe buffer data page (ä¹Ÿå°±æ˜¯å¯¹ pipefd è°ƒç”¨Â write()  
æ—¶å†™å…¥æ•°æ®çš„é‚£ä¸€é¡µ)ã€‚  
> **æç¤º**  
> ä½ å¯ä»¥åœ¨Â prep_new_page()  
ä¸Šè®¾ç½®æ¡ä»¶æ–­ç‚¹ (b prep_new_page if page == <target_alloc_page_addr>  
)ï¼Œç”¨å®ƒæ¥ç¡®è®¤ç›®æ ‡ page å…·ä½“æ˜¯å¦‚ä½•è¢«åˆ†é…å‡ºæ¥çš„ã€‚è¿™ä¸ªæ–­ç‚¹å‘½ä¸­åï¼ŒæŸ¥çœ‹ backtrace èƒ½å¸®åŠ©ä½ è°ƒè¯• cross-cache çš„å®ç°ã€‚  
  
  
å½“ pipe buffer data page è¢«åˆ†é…æ—¶ï¼Œå®ƒä¼šè¢«æ¸…é›¶ (page allocator ä¼šè‡ªåŠ¨è¿™ä¹ˆåš)ã€‚æˆ‘ä»¬çš„ç›®æ ‡ï¼Œæ˜¯è®©ä¸€äº›å †æŒ‡é’ˆè¢«å†™è¿›è¿™é¡µé‡Œï¼Œä»è€Œèƒ½å¤Ÿé€šè¿‡ pipe æŠŠå®ƒè¯»å‡ºæ¥ã€‚  
  
æ—¢ç„¶æˆ‘ä»¬çŸ¥é“Â uaf_sigqueue  
å°±åœ¨è¿™é¡µ pipe buffer data page å†…ï¼Œæˆ‘ä»¬å®é™…ä¸Šå°±æœ‰åŠæ³•æ³„æ¼ä»¥ä¸‹åœ°å€ï¼š  
1. å¦ä¸€ä¸ªçœŸå®çš„Â struct sigqueue  
çš„åœ°å€ã€‚æˆ‘æŠŠå®ƒç§°ä¸ºÂ other_sigqueue  
ã€‚  
  
1. å¼•ç”¨Â uaf_sigqueue  
çš„é‚£ä¸ª task pending list çš„åœ°å€ã€‚  
  
1. æˆ‘ä»¬è‡ªå·±çš„Â uaf_sigqueue  
çš„åœ°å€ â€”â€” å¦‚æœåç»­éœ€è¦åœ¨ kernel heap é‡Œä¼ªé€ å¯¹è±¡ï¼Œè¿™ä¸ªåœ°å€ä¼šå¾ˆæœ‰ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬èƒ½å®Œå…¨æ§åˆ¶æ•´é¡µå†…å®¹ã€‚  
  
> **æ³¨æ„**  
> è™½ç„¶æˆ‘çš„ exploit ä¼šæ³„æ¼ä¸Šè¿°ä¸‰ä¸ªåœ°å€ï¼Œä½†å®Œæˆåˆ©ç”¨å…¶å®åªéœ€è¦Â other_sigqueue  
çš„åœ°å€ã€‚å› æ­¤åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œexploit è¿˜å¯ä»¥è¿›ä¸€æ­¥ç®€åŒ–ï¼  
  
  
å¯¹äº (1)ï¼Œæˆ‘ä»¬åªéœ€è¦å‘è¯¥ task å‘é€ä¸€ä¸ª real-time signal (æˆ‘åœ¨ exploit é‡Œç”¨çš„æ˜¯Â SIGRTMIN+1  
ï¼Œä¹Ÿå°±æ˜¯Â other_sigqueue  
)ã€‚å®ƒä¼šè¢«è¿½åŠ åˆ° pending list çš„å°¾éƒ¨ã€‚ç”±äºÂ pending->list.prev == uaf_sigqueue  
ï¼Œå› æ­¤Â uaf_sigqueue->list.next  
ä¼šè¢«å†™æˆè¯¥ real-time signal çš„Â struct sigqueue  
å¯¹è±¡åœ°å€ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å¯¹ UAF pipe è°ƒç”¨Â read()  
ä»é¡µé¢é‡Œè¯»å‡ºå®ƒ (åœ¨é¡µé¢é‡Œæ‰«æç¬¬ä¸€ä¸ªéÂ NULL  
çš„å­—èŠ‚å³å¯å®šä½)ã€‚  
  
å¯¹äº (2)ï¼Œæˆ‘ä»¬éœ€è¦å›åˆ° exploit çš„æœ€å¼€å§‹ï¼šåœ¨çœŸæ­£å¼€å§‹ä¹‹å‰ï¼Œå°±å…ˆå‘æœ¬è¿›ç¨‹çš„ pending list å…¥é˜Ÿä¸€ä¸ª real-time signal (æˆ‘ç”¨çš„æ˜¯Â SIGRTMIN+2  
)ã€‚éšåÂ uaf_sigqueue  
ä¼šåœ¨åç»­è¢«å…¥é˜Ÿ (double inserted)ã€‚  
  
æœ€åï¼Œå½“æˆ‘ä»¬æ‹¿åˆ°Â other_sigqueue  
çš„åœ°å€å (å¦‚ä¸Šæ‰€è¿°)ï¼Œå°±å¯ä»¥é€šè¿‡å¯¹ UAF pipe è°ƒç”¨Â write()  
æ¥è®¾ç½®Â uaf_sigqueue->list.next = &other_sigqueue  
ï¼ŒæŠŠ list ç»„ç»‡æˆè¿™æ ·ï¼š  
```
pending_list -> SIGRTMIN+2 -> uaf_sigqueue -> other_sigqueue -> pending_list
```  
  
æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡Â signalfd_read()  
æŠŠÂ SIGRTMIN+2  
è¿™ä¸ª signal dequeue æ‰ã€‚è¿™ä¼šè®©Â uaf_sigqueue->list.prev  
è¢«è®¾ç½®ä¸ºÂ &pending_list  
ï¼Œéšåæˆ‘ä»¬å°±èƒ½ç”¨ UAF pipe ä»é¡µé¢é‡ŒæŠŠå®ƒè¯»å‡ºæ¥ã€‚  
  
å®Œæˆä»¥ä¸Šæ­¥éª¤åï¼Œå½“å‰çš„ list å½¢æ€å¦‚ä¸‹ï¼š  
```
pending_list -> uaf_sigqueue -> other_sigqueue -> pending_list
```  
  
æ­¤æ—¶ï¼Œå¦‚æœæˆ‘ä»¬æŠŠÂ uaf_sigqueue->list.prev  
å’ŒÂ uaf_sigqueue->list.next  
éƒ½æ”¹æˆÂ other_sigqueue  
ï¼Œå°±å¯ä»¥é€šè¿‡Â signalfd_read()  
dequeueÂ uaf_sigqueue  
ï¼Œä½†åŒæ—¶ä»ç„¶è®© task çš„ pending list é‡Œä¿ç•™ä¸€ä¸ªå¯¹å®ƒçš„å¼•ç”¨ã€‚  
  
è¿™æ¬¡ dequeue æœ€ç»ˆä¼šå¯¹Â uaf_sigqueue  
è°ƒç”¨Â list_del_init()  
(code)ï¼Œä»è€ŒæŠŠÂ uaf_sigqueue->list.prev = uaf_sigqueue->list.next = &uaf_sigqueue  
ã€‚  
  
æ­¤æ—¶ï¼Œæˆ‘ä»¬å°±èƒ½ç”¨ UAF pipe ä»å®ƒè‡ªèº«è¯»å‡ºÂ uaf_sigqueue  
çš„åœ°å€ã€‚  
  
åœ¨æˆ‘çš„ exploit ä¸­ï¼Œæ³„æ¼ç»“æœçš„è¾“å‡ºå¦‚ä¸‹ï¼š  
```
[+] Stage 2 - Cross-cache the UAF sigqueue's slabÂ  Â  Â  Â  [+] Reallocated UAF sigqueue slab as a pipe buffer data pageÂ  Â  Â  Â  [+] Cleaning up all cross-cache allocations to prepare for next cross-cacheÂ  Â  Â  Â  [+] Preparing task pending list for heap leaksÂ  Â  Â  Â  [+] Heap leaks:Â  Â  Â  Â  Â  Â  Â  Â  - UAF sigqueue page offset 0x500Â  Â  Â  Â  Â  Â  Â  Â  - Other sigqueue 0xffff9da44507a550Â  Â  Â  Â  Â  Â  Â  Â  - Task pending list addr 0xffff9da4412b1710Â  Â  Â  Â  Â  Â  Â  Â  - UAF sigqueue address 0xffff9da443420500
```  
> **è­¦å‘Š**  
> åœ¨ä¸Šè¿°æ³„æ¼Â uaf_sigqueue  
åœ°å€çš„è¿‡ç¨‹ä¸­ï¼Œå®ƒå®é™…ä¸Šä¼šç ´åÂ other_sigqueue  
çš„Â list  
æŒ‡é’ˆ (å®ƒä»¬éƒ½ä¼šå›æŒ‡åˆ°Â &other_sigqueue  
ï¼Œå°½ç®¡ task pending list çš„Â .prev  
æŒ‡é’ˆä¹Ÿè¢«è®¾ç½®æˆäº†Â &other_sigqueue  
)ã€‚  
  
## åˆ©ç”¨åŸè¯­  
  
æˆ‘å†³å®šç¨å¾®åœä¸‹æ¥æƒ³ä¸€æƒ³ï¼šåŸºäºÂ uaf_sigqueue  
ï¼Œæˆ‘ä»¬åˆ°åº•æœ‰ä»€ä¹ˆåˆ©ç”¨åŸè¯­ï¼Ÿæˆ‘ä»¬å·²ç»çŸ¥é“å¯ä»¥æ— é™æ¬¡ dequeue å®ƒï¼Œä½†è¿™å…·ä½“èƒ½å¸¦æ¥ä»€ä¹ˆèƒ½åŠ›ï¼Ÿ  
  
çºµè§‚Â struct sigqueue  
åœ¨ kernel é‡Œçš„æ‰€æœ‰ç”¨æ³•ï¼Œè¯´å®è¯â€¦â€¦å¹¶ä¸å¤šã€‚åŸºæœ¬åªæœ‰å››ç±»å¯èƒ½æœ‰ä»·å€¼çš„è¡Œä¸ºï¼š  
1. è¢« enqueue åˆ° task çš„ pending list ä¸­ã€‚  
  
1. ä» task çš„ pending list ä¸­è¢« dequeueã€‚  
  
1. è¢«é‡Šæ”¾ (free)ã€‚  
  
1. æŸäº›å­—æ®µä¼šè¢«è‡ªå¢ / è‡ªå‡ / å†™å…¥ (ä¾‹å¦‚Â send_sigqueue()  
é‡Œçš„Â q->info.si_overrun++  
)ã€‚  
  
### Dequeue åˆ°ç±»å‹æ··æ·†  
  
æ¥ä¸‹æ¥å‡ ä¸ªå°æ—¶ï¼Œæˆ‘çš„ç›®æ ‡æ˜¯ï¼šå†æ¬¡ä½¿ç”¨ cross-cacheï¼ŒæŠŠÂ other_sigqueue  
çš„ slab page é€å› page allocatorï¼Œå¹¶æŠŠå®ƒé‡æ–°åˆ†é…æˆæŸç§å…¶å®ƒå¯¹è±¡ç±»å‹ã€‚ç„¶åæŠŠÂ uaf_sigqueue->list  
æŒ‡é’ˆæŒ‡å‘è¿™ä¸ªâ€œå…¶å®ƒå¯¹è±¡â€ï¼Œå†é€šè¿‡ dequeue è®©â€œå…¶å®ƒå¯¹è±¡â€ä»¥Â struct sigqueue  
çš„èº«ä»½è¢«æ’å…¥ task çš„ pending listã€‚  
  
ä½†å¦‚å‰æ‰€è¿°ï¼Œstruct sigqueue  
çš„ç”¨é€”éå¸¸æœ‰é™ã€‚æœ€å¤šä¹Ÿå°±æ˜¯å°è¯•å» free é‚£ä¸ªâ€œå…¶å®ƒå¯¹è±¡â€ï¼Œä½†è¿™è¦æ±‚è¯¥å¯¹è±¡æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š  
1. æˆ‘å¿…é¡»èƒ½æ§åˆ¶ offset 0 å¤„çš„ 8 å­—èŠ‚ (sigqueue->list.next  
)ï¼Œå¹¶æŠŠå®ƒè®¾ç½®ä¸ºåŒä¸€ä¸ª task pending list çš„åœ°å€ã€‚  
  
1. å®ƒåœ¨ offset 72 (sigqueue->user  
) å¤„å¿…é¡»æ˜¯ä¸€ä¸ªæœ‰æ•ˆä¸”å¯å†™çš„ kernel æŒ‡é’ˆã€‚  
  
1. é‡Šæ”¾è¯¥å¯¹è±¡çš„è·¯å¾„ä¸èƒ½å— offset 72 è¿™ä¸ªæŒ‡é’ˆå½±å“ã€‚  
  
1. offsetÂ sigqueue->info.signo  
å¤„çš„å€¼å¿…é¡»èƒ½è¢«è®¾ç½®ä¸ºå½“å‰ pending list ä¸Šå·²ç»å­˜åœ¨çš„æŸä¸ª signal number (å¦åˆ™Â collect_signal()  
æ°¸è¿œä¸ä¼šè¢«è°ƒç”¨æ¥é‡Šæ”¾å®ƒ)ã€‚  
  
ç†è®ºä¸Šï¼Œè¿™èƒ½ç»™æˆ‘ä»¬ä¸€ä¸ªä»»æ„ free (arbitrary free) åŸè¯­ â€”â€” é€šè¿‡æŠŠå¦ä¸€ä¸ªå¯¹è±¡ä»¥Â struct sigqueue  
çš„èº«ä»½æŒ‚åˆ° task pending list ä¸Šï¼Œç„¶å dequeue æ‰å®ƒï¼Œæˆ‘ä»¬æœ¬è´¨ä¸Šç›¸å½“äºåœ¨å¦ä¸€ä¸ªå¯¹è±¡ä¸Šåˆ¶é€ äº†ä¸€ä¸ª UAF!  
  
ä½†ä¸ä»…å¬èµ·æ¥æå…¶å¤æ‚ï¼Œæˆ‘åœ¨ç¿»äº†å¤§é‡ç»“æ„ä½“ä¹‹åä¹Ÿæ²¡æ‰¾åˆ°ä¸€ä¸ªèƒ½æ»¡è¶³æ‰€æœ‰æ¡ä»¶çš„å¯¹è±¡ã€‚  
  
è€Œä¸”æˆ‘æ‰¾è¿™äº›ç»“æ„ä½“æ—¶ä¹Ÿæ²¡æœ‰ç”¨ä»€ä¹ˆç³»ç»ŸåŒ–æ–¹æ³• â€”â€” åªæ˜¯æ‰‹å·¥æ‰«æˆ‘è®¤ä¸ºâ€œå€¼å¾—æ‹¿æ¥åš UAFâ€çš„ä¸€äº› kernel ç»“æ„ä½“ã€‚ç¬¬ä¸€è½®æ‰«æè¿‡åæˆ‘æ„è¯†åˆ°ï¼š  
1. è¿™äº›æ¡ä»¶å¤ªè‹›åˆ»äº†ã€‚  
  
1. å³ä¾¿çœŸèƒ½æ‰¾åˆ°æ»¡è¶³å››ä¸ªæ¡ä»¶çš„ç»“æ„ä½“ï¼Œä¹Ÿæ— æ³•ä¿è¯åç»­å¯¹é‚£ä¸ªå¯¹è±¡çš„ UAF åˆ©ç”¨ä¼šå®¹æ˜“ã€‚  
  
äºæ˜¯æˆ‘å†³å®šæ”¾å¼ƒï¼šæˆ‘ä¸æƒ³è´¹è¿™ä¹ˆå¤§åŠ²ï¼Œæœ€åè¿˜è¦å†å»åˆ©ç”¨å¦ä¸€ä¸ªåŒæ ·å›°éš¾çš„ UAFã€‚  
  
ä¸è¿‡è¿™æ®µå°è¯•ä¹Ÿä¸æ˜¯å®Œå…¨æ²¡æœ‰æ”¶è· â€”â€” åœ¨æ‰«æç»“æ„ä½“çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘è¿˜æ›´ä»”ç»†åœ°çœ‹äº†çœ‹Â __sigqueue_free()  
ï¼Œå¹¶æ„è¯†åˆ°å®ƒé‡Œé¢å…¶å®è—ç€ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„åŸè¯­ï¼  
### ä»»æ„å‡ä¸€ (Arbitrary Decrement) åŸè¯­  
  
__sigqueue_free()  
å®é™…ä¸Šç»™äº†æˆ‘ä»¬ä¸€ä¸ªä»»æ„ decrement çš„åŸè¯­ (code):  
```
staticvoid__sigqueue_free(structÂ sigqueue *q){ifÂ (q->flags & SIGQUEUE_PREALLOC)return;ifÂ (atomic_dec_and_test(&q->user->sigpending))free_uid(q->user);kmem_cache_free(sigqueue_cachep, q);}
```  
  
å®ƒä¼šå¯¹Â q->user->sigpending  
æ‰§è¡Œå‡ä¸€ã€‚å€ŸåŠ©æˆ‘ä»¬æ§åˆ¶çš„ UAF pipe buffer pageï¼Œæˆ‘ä»¬å·²ç»å¯ä»¥å®Œå…¨æ§åˆ¶Â q->user  
ï¼Œè€ŒÂ q->user  
ç»“æ„ä½“é‡Œçš„Â sigpending  
å­—æ®µä½äº offsetÂ 8  
ã€‚  
  
å› æ­¤ï¼Œåªè¦æŠŠÂ q->user  
è®¾ç½®ä¸ºÂ target_addr - 8  
ï¼Œæˆ‘ä»¬å°±èƒ½å¯¹è¯¥åœ°å€å¤„çš„å€¼æ‰§è¡Œå‡ä¸€ (å®ƒæ˜¯ä¸€ä¸ªÂ atomic_t  
ï¼Œä¹Ÿå°±æ˜¯ 4 å­—èŠ‚çš„Â int  
)!  
  
æˆ‘å½“æ—¶å·²ç»å…³é—­äº† KASLRï¼Œäºæ˜¯æˆ‘ç«‹åˆ»å°è¯•é€šè¿‡è®¾ç½®Â uaf_sigqueue->user = &core_pattern - 8  
æ¥ decrementÂ &core_pattern  
çš„é¦–å­—èŠ‚ã€‚æœç„¶ï¼Œå®ƒä» "core" å˜æˆäº† "bore"ï¼Œè¯æ˜è¿™ä¸ªæ€è·¯æ˜¯å¯è¡Œçš„ã€‚  
## å¯»æ‰¾ Kernel Text æ³„æ¼  
  
å…ˆå‰§é€ä¸€ä¸‹ â€”â€” å®Œæˆ exploit å¹¶ä¸éœ€è¦ kernel text leakã€‚å¦‚æœä½ æƒ³ç›´æ¥è·³åˆ°ä¸‹ä¸€èŠ‚ï¼Œå¯ä»¥ç‚¹ è¿™é‡Œã€‚  
  
åœ¨è¿™ä¸ªé˜¶æ®µï¼Œæˆ‘ä¸‹å®šå†³å¿ƒè¦æ‰¾åˆ°æŸä¸ªå †å¯¹è±¡ï¼šå®ƒèƒ½è¢«é‡æ–°åˆ†é…åˆ°Â other_sigqueue  
çš„ slab page ä¸Šï¼Œç„¶åæˆ‘èƒ½ç”¨ä»»æ„ decrement åŸè¯­å»æ³„æ¼ä¸€ä¸ª kernel text åœ°å€ã€‚æˆ‘åœ¨è¿™ä¸€æ­¥èŠ±äº†å¥½å‡ ä¸ªå°æ—¶ã€‚  
  
åœ¨ç¿»äº†å¤§é‡å¯¹è±¡ä¹‹åï¼Œå°½ç®¡æˆ‘çœ‹åˆ°äº†ä¸å°‘æ½œåœ¨å€™é€‰ï¼Œä½†è¿˜æ˜¯æƒ³ä¸å‡ºä¸€ä¸ªåŠæ³•èƒ½ç”¨ä»»æ„ decrement æ¥æ³„æ¼åœ°å€ã€‚å¦‚æœæˆ‘ä½¿ç”¨å‰é¢æåˆ°çš„ dequeue åˆ°ç±»å‹æ··æ·† åŸè¯­ï¼Œç¡®å®èƒ½é€šè¿‡Â copy_siginfo()  
èµ°åˆ°ä¸€æ¬¡Â copy_to_user()  
ï¼Œä½†è¦æŠŠå®ƒå®Œç¾åœ°å¸ƒç½®å‡ºæ¥ä¼¼ä¹éå¸¸å›°éš¾ï¼Œè€Œä¸” kernel text æŒ‡é’ˆè¿˜å¿…é¡»ä½äºä¸€ä¸ªéå¸¸è‹›åˆ»çš„ offset...  
  
å› æ­¤æˆ‘æŠŠæ³¨æ„åŠ›è½¬å‘ reference countã€‚å¦‚æœæˆ‘èƒ½æŠŠÂ other_sigqueue  
çš„ slab page é‡æ–°åˆ†é…æˆæŸä¸ªå¸¦å¼•ç”¨è®¡æ•°çš„å¯¹è±¡ï¼Œå°±å¯ä»¥å¾ˆå®¹æ˜“å¯¹é‚£ä¸ªå¯¹è±¡è§¦å‘ UAFã€‚ç›¸æ¯”å‰é¢â€œä»»æ„ freeâ€çš„æ€è·¯ï¼Œè¿™æ¡è·¯çº¿æ˜æ˜¾ç®€å•å¾—å¤šï¼Œè€Œä¸”ä¹Ÿä¸è¦æ±‚é‚£ä¸ªå¯¹è±¡æ»¡è¶³ç‰¹æ®Šçš„ç»“æ„å¸ƒå±€æ¡ä»¶ã€‚  
  
äºæ˜¯æˆ‘åˆå¼€å§‹æ‰« kernelï¼Œè¿™æ¬¡ä¸“é—¨æ‰¾ï¼šå¼•ç”¨è®¡æ•°ç»“æ„ä½“ã€ä¸”èƒ½ä»Â kmalloc-256  
æˆ–æ›´å°çš„ cache åˆ†é…å‡ºæ¥çš„å¯¹è±¡ (kmalloc-512  
ä½¿ç”¨ order-1 pagesï¼Œå› æ­¤ä¸è€ƒè™‘)ï¼Œä»¥åŠæ‰€æœ‰ä½¿ç”¨ order-0 pages çš„ä¸“ç”¨Â kmem_cache  
åˆ†é…ã€‚  
  
ç»“æœæˆ‘ç¡®å®æ‰¾åˆ°äº†å¾ˆå¤šæ½œåœ¨å€™é€‰ (ä¾‹å¦‚Â struct file *  
)ã€‚ä½†åœ¨çœ‹è¿™äº›å€™é€‰æ—¶ï¼Œæˆ‘åˆå¿ä¸ä½å¼€å§‹çƒ¦ï¼šéš¾é“æˆ‘çœŸè¦åœ¨ä¸€ä¸ªå…¨æ–°çš„å¯¹è±¡ä¸Šå†åšä¸€é UAF åˆ©ç”¨å—ï¼Ÿå³ä¾¿å¯é€‰å¯¹è±¡ç±»å‹æ›´å¤šäº†ï¼Œéš¾é“å°±æ²¡æœ‰ä¸€ç§æ›´ç®€å•çš„æ–¹å¼ï¼Œèƒ½ç”¨è¿™ä¸ªä»»æ„ decrement ç›´æ¥æ‹¿åˆ° root å—ï¼Ÿ  
  
äºæ˜¯æˆ‘å†³å®šå…ˆä¼‘æ¯ä¸€ä¸‹ï¼Œç¨åå†å›æ¥ç»§ç»­ã€‚æˆ‘åå¤æ€è€ƒè¯¥å¦‚ä½•ç”¨è¿™ä¸ªä»»æ„ decrement å»ä¿®æ”¹æŸäº› kernel æ•°æ®ï¼Œå¹¶æœ€ç»ˆå¯¼å‘ root æƒé™ã€‚  
> **é‡è¦**  
> å¦‚æœä½ è¯»åˆ°è¿™é‡Œï¼Œå¹¶ä¸”ä½ çŸ¥é“æŸä¸ªå¸¦å¼•ç”¨è®¡æ•°ã€ä¸”éå¸¸å®¹æ˜“é€šè¿‡è§¦å‘ UAF æ¥åˆ©ç”¨çš„å¯¹è±¡ç±»å‹ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼æˆ‘å¾ˆæƒ³å­¦ä¹ æ›´å¤šè¿™æ–¹é¢çš„æŠ€å·§ã€‚  
  
  
å¹¸è¿çš„æ˜¯ï¼Œæˆ‘å¹¶æ²¡æœ‰èŠ±å¤ªä¹…å°±æƒ³åˆ°äº†æœ€ç»ˆ exploit é‡Œä½¿ç”¨çš„ç»“æ„ä½“ã€‚  
## credæ•‘åœº  
  
åœ¨å‰ä¸€èŠ‚é‡Œæ‰«æå¯ç”¨ç»“æ„ä½“æ—¶ï¼Œæˆ‘å…¶å®æ—©å°±è§è¿‡Â struct cred  
ã€‚ä½†æˆ‘èŠ±äº†ä¸€ç‚¹æ—¶é—´æ‰æŠŠçº¿ç´¢ä¸²èµ·æ¥ï¼Œæ„è¯†åˆ°ï¼šæˆ‘å¯ä»¥ç”¨ä»»æ„ decrement åŸè¯­ï¼ŒæŠŠÂ struct cred  
çš„Â .euid  
å­—æ®µå‡åˆ° 0ï¼Œç„¶åç›´æ¥æ‹¿åˆ°ä¸€ä¸ª root shellã€‚  
  
å¦å¤–ï¼Œæ™®é€šç”¨æˆ·çš„Â struct cred  
çš„ capabilities é€šå¸¸æ˜¯ 0ã€‚æˆ‘è¿˜å¯ä»¥å¯¹å…¶ decrementï¼Œè§¦å‘æ•´æ•°ä¸‹æº¢ï¼Œä»è€Œè·å¾—å®Œæ•´ capabilitiesã€‚  
  
ä¸€å¼€å§‹æˆ‘å°è¯•ç”¨Â fork()  
æ¥ sprayÂ struct cred  
ï¼Œä½†äº‹å®è¯æ˜Â fork()  
åœ¨åˆ†é…Â struct cred  
ä¹‹å‰ï¼Œä¼šå…ˆä¸º kernel thread stack åˆ†é…å¤šé¡µå†…å­˜ã€‚è¿™è®©è®¡åˆ’å˜å¾—ä¸å¤ªå¯è¡Œï¼Œå› ä¸ºæˆ‘æ ¹æœ¬ä¸çŸ¥é“å½“å‰Â struct cred  
çš„ active slab page æ˜¯ä»€ä¹ˆçŠ¶æ€ã€‚  
  
ä¸è¿‡ï¼Œåœ¨æŸ¥çœ‹Â prepare_cred()  
(åˆ†é…Â struct cred  
çš„å‡½æ•°) çš„æ‰€æœ‰è°ƒç”¨ç‚¹ä¹‹åï¼Œæˆ‘å‘ç°ï¼šåœ¨ä¸€ä¸ª fork å‡ºæ¥çš„è¿›ç¨‹é‡Œè°ƒç”¨Â setresuid(-1, -1, -1)  
æ˜¯ä¸€ä¸ªå®Œç¾çš„ spray â€”â€” å®ƒåªåˆ†é…ä¸€ä¸ªÂ struct cred  
ç„¶åç«‹åˆ»è¿”å›ã€‚  
  
è‡³æ­¤ï¼Œæœ€ç»ˆçš„ exploit è®¡åˆ’å·²ç»æˆå½¢ã€‚æˆ‘ä¼šåœ¨ä¸‹ä¸€èŠ‚æŠŠæ‰€æœ‰æ­¥éª¤åˆ—å‡ºæ¥ã€‚  
## æœ€ç»ˆåˆ©ç”¨æ­¥éª¤  
  
ä¸€è·¯èµ°æ¥å¾ˆæ¼«é•¿ï¼Œä½†æˆ‘ä»¬ç»ˆäºåˆ°ç»ˆç‚¹äº†ã€‚ç”±äºæˆ‘åœ¨ "Cross-caching å›åˆ° Page Allocator" è¿™ä¸€èŠ‚ä¹‹å‰å·²ç»æŠŠæ¯ä¸€æ­¥éƒ½è®²å¾—å¾ˆæ¸…æ¥šäº†ï¼Œè¿™é‡Œæˆ‘åªåšç®€è¦æ¦‚è¿°ã€‚  
1. æ­å»º parent å’Œ child è¿›ç¨‹ï¼Œä»¥åŠè§¦å‘æ¼æ´æ‰€éœ€çš„ child threadsã€‚  
  
1. åœ¨ child è¿›ç¨‹ä¸­è§¦å‘æ¼æ´ -> é‡Šæ”¾Â uaf_timer  
-> åœ¨ parent è¿›ç¨‹ä¸­æŠŠå®ƒé‡æ–°åˆ†é…ä¸ºÂ realloc_timer  
ã€‚  
  
1. åœ¨æ°å½“çš„æ—¶æœºåœ¨ parent è¿›ç¨‹ä¸­è°ƒç”¨Â timer_settime()  
ï¼Œè®©Â uaf_timer->sigq  
åŒæ—¶è¢«æ’å…¥ parent å’Œ child çš„ pending listã€‚  
  
1. åˆ é™¤ timerï¼Œå¹¶åœ¨ parent è¿›ç¨‹ä¸­ dequeueÂ uaf_timer->sigq  
ã€‚æœ€ç»ˆä½ ä¼šåœ¨ parent æˆ– child çš„ pending list ä¸­å¾—åˆ°ä¸€ä¸ªå¯¹Â uaf_timer->sigq  
çš„æ— é™å¼•ç”¨ã€‚  
  
1. åœ¨ task pending list ä¸­è·å¾—å¯¹Â uaf_sigqueue  
çš„æ— é™å¼•ç”¨åï¼Œä½¿ç”¨ cross-cache exploitation æŠ€æœ¯æŠŠå®ƒçš„ page é€å› page allocatorã€‚  
  
1. æŠŠè¯¥ page é‡æ–°åˆ†é…æˆ pipe buffer data pageã€‚  
  
1. ä»¥ç‰¹å®šæ–¹å¼åœ¨ task pending list ä¸­æ’å…¥å¹¶ dequeue signalsï¼Œä»¥è·å¾—å †æ³„æ¼ (è§ "è·å–å †æ³„æ¼" ä¸€èŠ‚)ã€‚  
  
1. ç‰¹åˆ«é‡è¦çš„æ˜¯æ‹¿åˆ°å¦ä¸€ä¸ªçœŸå®Â struct sigqueue  
å¯¹è±¡ (å³Â other_sigqueue  
) çš„å †åœ°å€ï¼›å…¶å®ƒæ³„æ¼æ²¡é‚£ä¹ˆå…³é”®ã€‚  
  
1. å‡†å¤‡ç¬¬äºŒæ¬¡ cross-cache æ”»å‡» â€”â€” ç›®çš„æ˜¯æŠŠÂ other_sigqueue  
çš„ page é€å› page allocator (æˆ‘åœ¨å¦ä¸€ä¸ª CPU ä¸Šåšè¿™ä»¶äº‹)ã€‚  
  
1. åœ¨å®Œæˆç¬¬äºŒæ¬¡ cross-cache ä¹‹å‰ï¼Œè°ƒç”¨Â fork()  
åˆ›å»º 1000 ä¸ª child processesï¼Œå¹¶è®©å®ƒä»¬åœ¨ pipe ä¸Šé˜»å¡ã€‚  
  
1. ç°åœ¨æŠŠÂ other_sigqueue  
çš„ page é‡Šæ”¾å› page allocatorã€‚  
  
1. é€ä¸ªå”¤é†’ç¬¬ 9 æ­¥é‡Œ fork å‡ºæ¥çš„å­è¿›ç¨‹ï¼Œè®©å®ƒä»¬è°ƒç”¨Â setresuid(-1, -1, -1)  
ã€‚è¿™æ ·æ¯ä¸ªå­è¿›ç¨‹éƒ½ä¼šåˆ†é…ä¸€ä¸ªÂ struct cred  
ã€‚  
  
1. åŸºæœ¬å¯ä»¥ä¿è¯ï¼šother_sigqueue  
çš„ page ä¼šè¢«å…¶ä¸­æŸä¸€æ‰¹Â struct cred  
ç»“æ„ä½“å¤ç”¨ã€‚  
  
1. ä½¿ç”¨ä»»æ„ decrement åŸè¯­ï¼ŒæŠŠæŸä¸ªÂ struct cred  
çš„Â euid  
å­—æ®µå‡åˆ° 0ã€‚  
  
1. æˆ‘ä»¬å·²ç»çŸ¥é“Â other_sigqueue  
çš„åœ°å€ï¼Œä¹ŸçŸ¥é“å®ƒæ‰€åœ¨çš„ page ä¼šè¢«è¿™äº›Â struct cred  
ç»“æ„ä½“å ç”¨ã€‚  
  
1. å†é€ä¸ªå”¤é†’è¿™äº›å­è¿›ç¨‹ï¼Œè®©å®ƒä»¬ç”¨Â geteuid()  
æ£€æŸ¥è‡ªå·±çš„ EUIDã€‚å¦‚æœä¸æ˜¯ 0ï¼Œå°±å›æŠ¥å¹¶æ°¸ä¹…é˜»å¡ã€‚  
  
1. å½“ EUID ä¸º 0 çš„å­è¿›ç¨‹é†’æ¥åï¼Œè®©å®ƒä¾æ¬¡è°ƒç”¨Â setresgid(0,0,0)  
å’ŒÂ setresuid(0,0,0)  
ï¼Œç„¶åè°ƒç”¨Â system("/bin/sh")  
ã€‚  
  
å®Œæˆæœ€åä¸€æ­¥åï¼Œä½ å°±ä¼šå¾—åˆ°ä¸€ä¸ª root shell!  
## ç»“è¯­  
  
æœ€ç»ˆ exploit åœ¨æˆ‘çš„ Github ä¸Šã€‚  
  
æˆ‘å¤§çº¦èŠ±äº† 1.5 å‘¨çš„æ—¶é—´æ¥åˆ†æå¹¶ç¼–å†™è¿™ä¸ªæ¼æ´çš„å®Œæ•´ exploitã€‚è¿™æ˜¯è¿„ä»Šä¸ºæ­¢æˆ‘å†™è¿‡æœ€ç²¾ç»†ã€æœ€å¤æ‚çš„ exploitã€‚æˆ‘å¾ˆç¡®å®šæˆ‘å¾ˆå¿« (å¤§æ¦‚ä¸€å‘¨å†…) å°±ä¼šå¼€å§‹å¿˜è®°ä¸€äº›ç»†èŠ‚ï¼Œæ‰€ä»¥å¦‚æœä½ æƒ³é—®æˆ‘é—®é¢˜ï¼Œè¯·å°½å¿«ï¼ğŸ˜›  
  
æ€»ä½“æ¥è¯´ï¼Œè¿™æ˜¯ä¸€æ®µéå¸¸æ£’çš„å­¦ä¹ ç»å†ï¼Œä¹Ÿå†æ¬¡å°è¯äº†æˆ‘çš„è§‚ç‚¹ï¼šç”¨è¿‡å»çš„æ¼æ´æ¥æ·±å…¥å­¦ä¹ æ–°çš„ç›®æ ‡ä¸å­ç³»ç»Ÿï¼Œæ”¶ç›Šå·¨å¤§ã€‚  
  
äº‹å®ä¸Šï¼Œæˆ‘ç°åœ¨å¯¹ä»¥ä¸‹å†…å®¹çš„ç†è§£ï¼Œæ¯”ä»¥å‰æ·±å¾—å¤šï¼š  
1. CPU è°ƒåº¦å™¨å†…éƒ¨æœºåˆ¶  
  
1. è¿›ç¨‹ä¸çº¿ç¨‹çš„å·¥ä½œæ–¹å¼  
  
1. signal çš„å·¥ä½œæ–¹å¼  
  
1. å¦‚ä½•æ£€æµ‹å¹¶å»¶é•¿ç«äº‰çª—å£  
  
1. åˆ©ç”¨æŠ€æœ¯ (Exploitation) çš„ä¸€èˆ¬æ–¹æ³•  
  
æˆ‘å¼ºçƒˆå»ºè®®ä»»ä½•æƒ³è¿›å…¥å®‰å…¨ç ”ç©¶çš„äººéƒ½å°è¯•è¿™ç§æ–¹å¼ã€‚å¦‚æœä½ ä¸çŸ¥é“å¦‚ä½•å¼€å§‹ï¼Œæˆ–è€…å®Œå…¨æ²¡æœ‰å¤´ç»ªï¼Œå°±æŒ‘ä¸€ä¸ªæ¼æ´ç„¶åç›´æ¥é’»è¿›å»åˆ†æã€‚  
  
ä½ ç”šè‡³ä¸éœ€è¦åƒæˆ‘ä¸€æ ·æŠŠå®ƒå†™æˆä¸€ä¸ªå®Œæ•´ exploit! åªè¦å¼€å§‹åšï¼Œçœ‹çœ‹ä¼šèµ°åˆ°å“ªé‡Œã€‚æœ‰æ—¶å€™ï¼Œè¿™å°±è¶³å¤Ÿäº†ã€‚  
  
---  
> Part 3 - Uncovering Chronomaly  
> å…è´£å£°æ˜ï¼šæœ¬åšå®¢æ–‡ç« ä»…ç”¨äºæ•™è‚²å’Œç ”ç©¶ç›®çš„ã€‚æä¾›çš„æ‰€æœ‰æŠ€æœ¯å’Œä»£ç ç¤ºä¾‹æ—¨åœ¨å¸®åŠ©é˜²å¾¡è€…ç†è§£æ”»å‡»æ‰‹æ³•å¹¶æé«˜å®‰å…¨æ€åŠ¿ã€‚è¯·å‹¿ä½¿ç”¨æ­¤ä¿¡æ¯è®¿é—®æˆ–å¹²æ‰°æ‚¨ä¸æ‹¥æœ‰æˆ–æ²¡æœ‰æ˜ç¡®æµ‹è¯•æƒé™çš„ç³»ç»Ÿã€‚æœªç»æˆæƒçš„ä½¿ç”¨å¯èƒ½è¿åæ³•å¾‹å’Œé“å¾·å‡†åˆ™ã€‚ä½œè€…å¯¹å› åº”ç”¨æ‰€è®¨è®ºæ¦‚å¿µè€Œå¯¼è‡´çš„ä»»ä½•è¯¯ç”¨æˆ–æŸå®³ä¸æ‰¿æ‹…ä»»ä½•è´£ä»»ã€‚  
  
  
  
