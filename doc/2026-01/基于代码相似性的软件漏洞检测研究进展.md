#  基于代码相似性的软件漏洞检测研究进展  
原创 信通传媒  网络与信息安全学报   2026-01-14 02:27  
  
点击蓝字  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/JaFvPvvA2J3MKYVlmXC32WtRJEYsPM9zbyZQtPicnOVfKibj5PuaiarJibbQgR5WWf52x1FicLIhiaweLvCoqia0TGibqg/640?wx_fmt=gif "")  
  
  
关注我们  
  
  
李晴浩 刘春玲 唐永鹤 董卫宇  
（  
信息工程大学，河南 郑州 450001  
 ）  
  
摘 要  
软件漏洞是长期困扰网络与信息安全领域的一类关键威胁，而漏洞检测是缓解此类威胁的首要技术手段。基于代码相似性的漏洞检测具有可规模化、低成本的优势；特别是与图神经网络、循环神经网络等人工智能技术结合后，其准确性与适用性进一步提升，正成为该领域的研究热点。系统梳理了近7年来基于代码相似性的软件漏洞检测进展：从数据集角度，剖析了漏洞样本数据集的类别、粒度、规模及其平衡性；从代码预处理角度，总结了代码清理与标准化、反汇编与中间语言表示等两类方法；从代码表征角度，归纳了基于代码片段、哈希、树、图、指标及混合表征6种方案的检测机制、优缺点与适用场景，并在统一评测指标下对比其检测性能与开销；进一步提炼了所用机器学习技术的类别与特点。最后，总结了该研究面临的挑战，并展望了未来的研究方向。  
  
关键词  
漏洞检测  
；  
代码相似性  
；  
机器学习  
；  
代码表征  
；  
图神经网络  
；  
循环神经网络  
  
## DOI：10.11959/j.issn.2096-109x.2025065引用本文：李晴浩, 刘春玲, 唐永鹤, 等. 基于代码相似性的软件漏洞检测研究进展[J]. 网络与信息安全学报, 2025, 11(6): 36-62.LI Q H, LIU C L, TANG Y H, et al. Research progress on detection of software vulnerabilities based on code similarity[J]. Chinese Journal of Network and Information Security, 2025, 11(6): 36-62.  
  
## 0引言  
  
  
软件是计算机数据与指令的集合，其在设计、开发、运行与维护等环节的缺陷均可能引入漏洞。网络攻击者利用这些漏洞实施信息窃取、拒绝服务、越权访问等恶意行为，严重威胁国家与公民的信息、财产安全。因此，必须开展软件漏洞检测研究，以便及时、高效地发现并修补漏洞，从而消除安全隐患，提升软件安全性。  
  
对此，研究者提出了模糊测试[1-2]  
、符号执行[3-4]  
、污点分析[5-6]  
及代码相似性分析等多种技术。其中，模糊测试、符号执行和污点分析要求代码完整、可执行，且需适配的软硬件环境，难以应用于大规模或源码残缺的场景。相比之下，代码相似性分析通过传统相似性算法或机器学习框架，计算代码在语法、语义、控制流、数据流及函数调用等特征上与已知漏洞样本的相似度，具备速度快、可扩展、低成本等优势。  
  
基于代码相似性的软件漏洞检测技术发展迅速。自2006年Li等[7]  
提出利用重复代码特定标记检测代码错误的工具CP-Miner以来，相关研究逐年递增；2018年后，图神经网络（graph neural network, GNN）、循环神经网络（recurrent neural network, RNN）、对比学习等人工智能技术被大规模引入，迄今已有数百种有效方法被提出，显著推动了该领域发展。鉴于工业方案普遍闭源，其方法论与学术成果存在显著差异，本文聚焦于学术界公开发表的检测方法。  
  
为系统收集文献，本文以“code similarity”、“machine learning”、“vulnerability detection”等为关键词，在Google Scholar、IEEE Xplore、ACM Digital Library、Springer、arXiv、DBLP、CNKI等数据库检索，获得2 462条高相关记录；经关键词过滤、摘要筛查与人工复核，最终选取2006—2024年发表的447篇核心论文。统计显示，论文数量呈显著上升趋势，如  
图1  
所示。进一步分析发现，2018年起，受人工智能第三次浪潮和开源代码生态繁荣的影响，该领域研究出现质性跃迁，涌现出诸多技术新颖、高效可扩展的方法。因此，本文重点研究2018—2024年发表于CCS、NDSS等会议与期刊的75篇代表性论文。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4EPawtBVuGS2EQrZWSwbl0w6yXLTsL9NkBQQic0xYicM6DY9VTRuZia0Dw/640?wx_fmt=jpeg&from=appmsg "")  
  
图1  
     
不同年份的论文数量分布  
  
本文从漏洞样本数据集、代码预处理、代码表征与漏洞检测3个方面对现有方法进行技术特征剖析，梳理关键机制，归纳领域挑战，并展望未来的研究方向。  
  
（1）相关术语  
  
1) 代码类型  
  
依据代码形态，软件代码通常划分为源代码与二进制代码两类。  
  
源代码：指C、C++、C#、Java、Python等高级语言编写的原始程序文件，既可以是开源项目，也可以是闭源项目。  
  
二进制代码：指源代码在x86、ARM、MIPS等指令集架构下，经GCC、Clang等特定版本编译器、在不同优化等级（-O0~-O3）下生成的可执行文件或库代码。  
  
2) 代码相似性  
  
又称代码克隆。若两段或多段代码在词法、语法、语义、控制流或数据流层面具有高度一致性，即可认为彼此相似。  
  
3) 代码相似性检测技术  
  
该技术通过文本对比、语法分析、语义分析等手段衡量代码间的相似程度，最早可追溯至1988年Whale[8]  
提出的克隆检测框架。经过三十余年发展，现已形成包含代码预处理、代码表征、相似性判定等环节的完整技术体系。典型工作涵盖跨源代码与二进制两种模态的CodeCMR[9]  
：该方法提取代码的控制流图（control flow graph, CFG）特征，利用GNN同时捕获源代码与二进制代码中的字符串常量与整数字面量特征，实现跨模态相似代码检测。  
  
源代码侧，DéjàVu[10]  
通过哈希指纹快速定位克隆，CrystalBLEU[11]  
则基于序列相似度精细度量代码接近程度。  
  
二进制侧，MIRROR[12]  
将变量恢复任务转化为Token级二分类问题，并借助概率推导预测变量具体取值，进而支撑后续相似性判定。  
  
（2）基于代码相似性的漏洞检测技术  
  
基于代码相似性的漏洞检测通用流程如  
图2  
所示：①构建规模化的漏洞样本数据集；②依据检测对象（源代码或二进制代码）对样本与待测代码进行统一预处理与表征；③利用相似性检测框架训练得到的漏洞检测模型对待测代码执行比对，输出检测结果。代码克隆产生的漏洞广泛存在于软件系统中。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4kOkStwGrJJ8uqmX2P5KAHB3n93Y7wUy6EhKltPCENP39YmAnuicdWiag/640?wx_fmt=jpeg&from=appmsg "")  
  
图2  
     
基于代码相似性的漏洞检测通用流程  
  
Islam等[13]  
对34个软件系统共870万行代码进行克隆与漏洞关联分析，发现17%的漏洞由代码克隆引入。随着开源生态繁荣，开发者频繁复用相似代码实现重复功能，导致克隆漏洞迅速扩散。Synopsys《开源安全与风险分析报告》指出，在其检查的1 250个商业代码库中，70%的代码源自开源项目，其中75%至少存在一个已知开源漏洞[14]  
。可见，基于代码相似性的漏洞检测已成为保障软件供应链安全的现实需求。  
  
（3）相关综述  
  
已有综述工作从不同侧面梳理了相似性与深度学习在漏洞检测中的进展：2019年，李珍等[15]  
系统回顾了基于代码相似性的漏洞检测方法；2020—2021年，李韵等[16]  
、Lin等[17]  
、Chakraborty等[18]  
相继从深度学习视角调研通用软件漏洞检测技术；2022—2023年，Steenhovek等[19]  
、Lipp等[20]  
对多种深度学习漏洞检测模型开展了实证评估，于颖超等[21]  
专门分析了2015—2020年面向二进制代码的34种检测方法；Nong等[22]  
、邓枭等[23]  
进一步比较了2021年及之前提出的基于深度学习的源代码漏洞检测方案。  
  
前人综述均聚焦2022年及以前的文献，且大多仅关注深度学习方法；除李韵等[16]  
外，其余研究均将源代码与二进制代码方法割裂讨论。本文面向2018—2024年最新进展，系统梳理跨模态、源代码及二进制代码场景下的传统方法与深度学习方法；从数据集、预处理、代码表征3个维度对基于代码相似性的技术路线进行特征分析与总结，并进一步阐述该领域面临的挑战与未来研究方向。  
  
## 1 漏洞样本数据集  
  
  
漏洞样本：包含漏洞代码片段的完整函数或文件。  
  
漏洞样本数据集：由数量达到一定规模的漏洞样本构成，涵盖多种漏洞类型及上下文信息，可用于训练与评估各类漏洞检测模型。  
  
源代码漏洞样本数据集：以C、C++、Java 等高级语言编写并公开标注的漏洞代码集合，代表数据集有SARD、Big-Vul、Devign等。  
  
二进制漏洞样本数据集：受指令集架构（x86/ARM/MIPS）、编译器家族（GCC/Clang/MSVC）及优化等级（O0～O3）多重因素影响，目前尚无统一、公开的通用数据集。学术界普遍采用两类方案：小规模闭源真实环境数据集；将现有源代码漏洞样本按目标平台/编译器/优化等级交叉编译后生成的合成数据集。  
  
### 1.1 数据集的类别  
  
  
依据来源不同，漏洞样本数据集可分为：基于专家经验的数据集和真实环境的数据集。  
  
（1）基于专家经验的数据集  
  
基于专家经验的数据集通过人工方式构造，典型代表为SARD[24]  
。该测试集由SAMATE项目维护，包含自动生成、人工合成及学术研究提供的带漏洞源代码，涵盖C、C++、C#、Java等高级语言，对应150余种通用弱点枚举（common weakness enumeration, CWE）。每个函数被标注为good（无漏洞）、bad（含漏洞）或mixed（同时给出漏洞与修补版本）。  
图3  
展示了源代码漏洞样本示例，SARD来源的漏洞样本CWE121_01（基于堆栈的缓冲区溢出）示例如  
图3  
（a）所示，在CWE121_Stack_Based_Buffer_Overflow_01_bad 函数中，字符数组data被初始化为大于字符数组dest长度缓冲区，这将使SNPRINTF函数在执行时产生可能的缓冲区溢出漏洞。在CWE121_Stack_Based_Buffer_Overflow_01_good函数中，字符数组data初始化长度小于字符数组dest，表明缓冲区溢出漏洞被修补。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4IVVX9ZP8cFl2uxUeRILcbvbHZhvviclSZYfXPTlpxUiasjOefeIIV5Mg/640?wx_fmt=jpeg&from=appmsg "")  
  
图3  
     
源代码漏洞样本示例  
  
（2）真实环境的数据集  
  
真实环境数据集主要来源于美国国家漏洞库库[25]  
（national vulnerability database, NVD），NVD是全球最大的公开漏洞情报源，与通用漏洞披露（common vulnerabilities and exposures, CVE）系统[26]  
同步，为每个漏洞分配唯一CVEID。然而，NVD仅提供有限的元数据，往往只有来源于Github[27]  
的开源项目（OSS）漏洞包含漏洞以及修补代码超链接信息。因此，研究者通常利用爬虫从GitHub获取带CVE ID的开源项目漏洞文件及其对应补丁，构建真实源码漏洞样本。NVD来源的漏洞样本CVE-2020-1967示例如  
图3  
（b）所示，CVE-2020-1967是开源软件OpenSSL的一个空指针取消引用漏洞，通常会导致软件进程崩溃或者失败。在tls1_check_sig_alg函数中，对指针sigalg是否为空判断的缺失，将导致此漏洞，增加指针判断语句sigalg!=NULL将修补此漏洞。  
  
NVD[25]  
样本除标注漏洞行外，还保留其前后上下文代码；对库函数/API调用类漏洞，这些上下文提供了关键的调用关系与数据流信息，可显著提升检测精度。相比之下，SARD[24]  
样本虽然漏洞特征明确，但上下文信息有限，难以满足真实场景下大规模代码的需求，也限制了模型的泛化能力。  
  
### 1.2 数据集粒度与规模  
  
  
数据集粒度与规模直接影响漏洞检测模型的效能与泛化能力。本文所调研的73.3%文献明确给出了数据集信息，其采用的样本粒度分为文件、函数、切片3类。由于来源与类型差异，跨数据集简单横向比较并无意义。为此，本文从“同粒度规模最大”和“被应用次数最多”两个维度遴选典型通用数据集，并单独列出独立数据集研究。  
表1  
汇总了各代表集的核心指标：CWE列给出覆盖的通用缺陷枚举数量；规模列仅统计含漏洞样本数（不含良性/修补样本）；“—”表示原文未披露；“*”表示混合数据集。  
  
表1  
     
典型漏洞样本数据集的规模情况  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf41htuuYBCyQkWiaH12eXMYbtBtMAicuua4uEibHDH2bzDJTu1KUefrBr9g/640?wx_fmt=jpeg&from=appmsg "")  
  
  
现有源代码漏洞检测文献情况如下。  
  
（1）规模  
  
切片级：AutoVAS[28]  
使用14 194条NVD切片，为目前最大。  
  
文件级：AMPLE[29]  
含22 278个NVD文件，数量居首。  
  
函数级：MVP[30]  
提供34 378个NVD漏洞函数，规模最大。  
  
混合集：FUNDED[31]  
构建150 950个漏洞函数的SARD+NVD混合集，其中SARD函数超过13万。  
  
（2）通用性  
  
SARD[24]  
原始数据集被21篇文献（28%）用作基准；Devign[32]  
（FFmpeg+Qemu）与Big-Vul[33]  
分别被13篇（17.3%）和12篇（16%）文献采用；Reveal[34]  
（Chrome+Debian）亦被12篇（16%）文献用于性能比较。  
  
独立数据集按样本形态可分为两类。①同源源代码集：Wang等[35]  
通过特定URL爬取1999—2019年GitHub C/C++项目，获4 076对漏洞/补丁，经最近链接搜索与过采样扩展为23 742条的PatchDB并开源；Big-Vul[33]  
仅爬GitHub得到3 754个漏洞、覆盖91种CWE；Chen等[36]  
发布含18 945个漏洞函数、覆盖150种CWE的数据集；Zhou等[37]  
基于SARD构造含Token、AST等多表征的样本集。②同源二进制集：ROMEO[38]  
将SARD的C/C++源码经多编译器/优化等级编译后反汇编为汇编代码，保留链接时间优化等指令信息，适用于源代码不可见的黑盒分析。  
  
实证研究方面。Lipp等[20]  
在27个项目（115万行代码、192个CVE）上评估发现，92%的漏洞集中在同一函数内，确认函数粒度是CVE数据集的合适抽象层次。Steenhoek等[19]  
进一步指出，数据集存在“规模效应”：仅需1 134个漏洞函数即可使模型达到良好性能（F  
1≈70%）；随后规模扩大10倍，F  
1仅提升约5%。  
  
综上，函数粒度被证实为最优样本单元，当前数据集规模两极分化，构建大规模、多类型数据集仍是研究重点。与此同时，随着样本量增加，模型性能呈“先快后慢”的边际效应增长趋势。  
  
### 1.3 数据集的平衡性  
  
  
一个平衡的数据集，其中的漏洞样本和修补样本在数量和规模上通常处于平衡状态。平衡的数据集将减少过拟合和欠拟合、缓解检测偏见问题，并有助于增强模型的泛化能力。20%的现有方法提及并解决了数据集的平衡性问题，其中Jeon等[28]  
、陈小全等[41]  
均采用基于SMOTE[42]  
的过采样方法SMOTEENN[43]  
或GraphSMOTE[44]  
来进行数据集平衡。VulChecker[45]  
采用漏洞样本等比采样的方式来平衡数据集。  
  
具体来说，SMOTE过采样算法通过在漏洞样本（少数类）和其随机最近的漏洞邻居之间进行插值来构建新的合成样本。SMOTEENN是对SMOTE的改进，增加了ENN欠采样。GraphSMOTE则先用GNN学习节点特征，执行SMOTE过采样后用GNN进行分类，确定合适少数类样本，在性能上优于SMOTE、SMOTEENN以及边界线-SMOTE。但由于该算法需要进行多次迭代和计算，因此在处理大规模有向图数据时仍然面临效率问题。  
  
从Steenhoek等[19]  
对数据集的实证研究可知，让漏洞检测模型达到同一性能，所需要的不平衡数据集规模取决于少数类（通常是漏洞样本类而非修补样本类）的规模，即如果少数类仅占总数的10%，那么不平衡数据集规模通常是少数类对应的平衡数据集的10倍。因此，平衡的数据集在增强泛化能力的基础上，还可降低检测模型对于数据集规模的需求，提高机器学习类模型的学习效率。  
  
## 2 代码预处理  
  
  
代码预处理主要包括代码清理与标准化、反汇编与中间语言表示，旨在增强检测模型理解代码数据的有效性。在  
图2  
中，对于输入数据（待测源代码/二进制代码、源代码/二进制代码漏洞样本），进行代码预处理将为代码表征、漏洞检测环节提供高信息量的有效数据。  
  
### 2.1 代码清理与标准化  
  
  
代码清理通常指删除待测代码中的注释、换行、字符串等冗余代码。标准化指将待测代码中的函数名、变量名等进行统一标准化命名，或将所有符号进行规范化等。现有方法的代码清理与标准化见  
表2  
。  
  
表2  
     
现有方法的代码清理和标准化  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4HGYeskeErjPFKibPItERDjdpcibMpGX1ia9Wm9as2tRy7dpaLTZdwF2sw/640?wx_fmt=jpeg&from=appmsg "")  
  
  
代码清理方面，VulDeePecker[47]  
、AutoVAS[28]  
对非ASCII字符、注释进行删除，部分方法对空行、空格、换行符、制表符进行删除，VulBERTa[50]  
仅删除注释。需要注意的是，在源代码方法中，由于字符串在源代码中的定位作用，因此未涉及对字符串的删除，而二进制代码方法Asteria[53]  
和VulANalyzeR[57]  
则均对字符串进行了删除。  
  
代码标准化方面，55.6%的方法对变量名进行归一化，即将其映射为VAR_0、VAR_1等形式。需注意，该操作通常仅适用于源代码，因为汇编级二进制代码基本不存在变量名符号信息。此外，源代码标准化规则还包括：函数名→FUN、字符串→STRING、形参→PARAM、字母转小写、序列等长补齐等。二进制代码侧则采用：字符串→str、立即数→addr、跳转目标→JA等缩写规范。跨模态研究中，Tao等[39]  
通过指令-寄存器对齐实现汇编与源码的同步表示。  
图4  
给出VulDeePecker[47]  
（源码侧）与jTrans[55]  
（二进制侧）的清理-标准化示例：红色区域为标准化结果，绿色区域为已清理内容。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4SoSliaI3cdOwYX3JXfGcYDmVwoQE9lOokt80CDcnFibubDztedckh6bA/640?wx_fmt=jpeg&from=appmsg "")  
  
图4  
     
代码清理及标准化示例  
  
代码清理旨在降低检测开销。空格、换行符、制表符等符号在检测中通常属于无效字符；对于二进制代码，不同汇编输出的字符串和常量亦存在较大差异。此外，未被执行的死代码对检测模型而言属于干扰噪声，应一并剔除。  
  
代码标准化的目的在于缓解词汇表外（out-of-vocabulary, OOV）问题。OOV问题指输入符号在词典或预训练模型中不存在、导致无法识别的情况。不同源代码的变量名、函数名差异显著，若缺乏标准化，检测模型需处理的词项数量将大幅增加；一旦超出处理能力，就会引发 OOV并延长处理时间。  
  
### 2.2 反汇编与中间语言表示  
  
  
反汇编与中间语言表示用于转换代码形态。反汇编是指借助逆向工具将二进制机器码转换为汇编语言；中间语言表示则通过逆向工具或中间语言编译器将汇编语言/源代码转换为中间表示（intermediate representation, IR）。反汇编主要应用于二进制代码方法。  
表3  
汇总了现有方法的反汇编与中间语言表示。  
  
表3  
     
现有方法的反汇编与中间语言表示  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4rx19MZoiaFcw9XF1mgac3VGmnvl2ahHmwPpPWnm0TN96XIeyD1A0F7w/640?wx_fmt=jpeg&from=appmsg "")  
  
  
BinVulDet[40]  
等15种方法使用IDA Pro[58]  
对二进制机器码进行反汇编，占全部反汇编方法的78.9%。IDA Pro为商业逆向工具，具备较强的反汇编与反编译能力，常被学术界和工业界用于二进制代码逆向分析、代码混淆、加解密及漏洞检测等任务。MDSAE[59]  
和PalmTree[52]  
分别采用Capstone[60]  
和Binary Ninja[61]  
进行反汇编。Capstone与Binary Ninja属于轻量级逆向工具，在准确率、完整率和覆盖率方面均略逊于IDA Pro。  
  
然而，即便通用逆向工具IDA Pro，也无法处理某些特殊编译的二进制文件，例如加密文件、被插入花指令或经过代码混淆的文件、部分残缺的文件。此外，IDA Pro在处理由部分编译器（如Clang设置PIC选项）生成的二进制文件时，也无法分析其中的子分支函数。同时，IDA Pro作为递归下降反汇编器，仍面临效率挑战。为确保效率，IDA Pro基于特征算法区分数据与代码，并通过派生变量和函数名尽可能注释反汇编结果，从而最大限度减少原始机器码数量，显著增加符号化信息。尽管如此，IDA Pro仍无法将汇编代码完全还原，可能存在部分信息丢失或错误。  
  
在中间语言表示方面，ContraFlow[69]  
与VulChecker[45]  
利用LLVM将源代码转换为IR，以生成前向和后向切片，在损失部分信息的同时实现跨语言检测；VulHawk[56]  
使用IDA Pro将二进制代码转换为IR以供后续表征；VulSeeker-Pro[67]  
与BinSeeker[68]  
采用PyVEX将二进制代码转换为VEX-IR进行模拟执行，以缓解静态检测的假阳性。  
  
综上，反汇编与中间语言表示作为关键预处理环节，旨在将代码由专用形态转为通用形态，虽然可能带来信息损失、误差及额外开销，但能显著提升检测模型的通用性与适配性，以应对复杂代码类型和多样化检测需求。  
  
## 3 代码表征与漏洞检测  
  
  
代码表征作为基于代码相似性的漏洞检测关键环节，旨在通过具体表示方式对代码的语法、控制流、数据流等特征进行刻画，使检测模型可据此完成漏洞识别。综合现有研究[15-23]  
，表征方式通常包括：代码片段（切片、序列）、图（CFG、CPG[70]  
等）、树（AST等）、哈希（模糊哈希、局部敏感哈希等）。同时，机器学习类模型在这些表征基础上进行嵌入，如图嵌入、词嵌入、代码嵌入，将具体表示映射至特征空间，供神经网络学习理解。  
  
漏洞检测模型，指在代码表征基础上，结合传统算法或机器学习与代码相似性技术形成的有效检测框架。其中机器学习模型一般包括前期嵌入模型、预训练任务和训练检测模型3部分，其效果将于下文分析。  
  
本文根据文献[  
15-23  
]研究及近7年相关实际工作，将代码表征方式分为6类，具体见  
表4  
。  
  
表4  
     
代码表征方式分类  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ChD72TJELtghxfibQ57uGe9rwyHIWp9OTaSzDLKKUU3ic5BreOzj086w/640?wx_fmt=jpeg&from=appmsg "")  
  
  
同时，依据表征方式差异，把现有工作划分为：基于代码片段、基于哈希、基于树、基于图、基于指标、基于混合表征的方法，如  
图5  
所示。涵盖源代码（source code, SC）方法、二进制代码（binary code, BC）方法及跨模态方法（同时处于SC与BC）  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4LFKf3Z9ugLykRmh1IQ1rRmT6vwzRWOPsBl4dbybLicaJSQYdl0sMibxQ/640?wx_fmt=jpeg&from=appmsg "")  
  
图5  
     
现有工作分类  
  
### 3.1 基于代码片段的漏洞检测  
  
  
基于代码片段的漏洞检测方法，指将代码片段嵌入向量后，利用相似性算法或机器学习模型计算/预测待测向量与漏洞样本向量的相似度，从而识别疑似漏洞片段。  
  
代码片段是代码的直接片段表示，通常仅体现序列化词法特征，包括序列、切片、部件等形式：代码序列指有序代码元素构成的序列；代码切片指对序列进行特定规则提取的片段；代码部件由语义相关但未必连续的代码行组成，可反映行间关联。  
  
本文从表征方式、机器学习技术、末端相似性检测、数据集、性能与特性等方面汇总基于代码片段的漏洞检测方法，具体信息见  
表5  
。因篇幅所限，表中仅列典型方法：数据集列中S代表SARD样本，N代表NVD样本；性能为文献自报精确率（Pre）、召回率（Rec）、F  
1值，且受数据集类型、规模及参数设置影响，带*号数据仅供参考。  
  
表5  
     
基于代码片段的典型漏洞检测方法  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ptCVoB59a2QIGjFObpWr9qN7vvHibLOoLKRDxWyyKt3PXZBQLazukBg/640?wx_fmt=jpeg&from=appmsg "")  
  
注：  
*表示仅供参考。  
  
  
（1）源代码方法  
  
Li等[47]  
首次提出面向深度学习的漏洞样本数据集，并基于此设计VulDeePecker。该方法用代码部件将源代码中的关键行组织成语义关联的前向和后向片段，经代码标准化及Word2Vec[115]  
词嵌入后生成漏洞样本向量；随后采用双向长短期记忆网络（bi-directional long short-term memory, BLSTM）捕获前向和后向信息，最后通过softmax分类器完成漏洞检测。softmax核心函数如  
式(1)  
所示，其中  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4udHsJxD0H58JeGWdpvPgNbg1RicGFeIyX7DGqJ5frW1YXp1g0Zicw4Yw/640?wx_fmt=jpeg&from=appmsg "")  
  
为第  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4gVf28aID3mu4vPEtnmykedj9exKWV4u8L2VjFzy8ZViaRNSSanzw5Qw/640?wx_fmt=jpeg&from=appmsg "")  
  
个节点的输出值，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4VcWR5TByeMt10SKuO6efuUfhOOKu9Ty1oFQC2nqzriaCsthm4tcgd6A/640?wx_fmt=jpeg&from=appmsg "")  
  
为输出节点的数量，即类别个数，通过softmax函数将多分类输出转换为(0,1)区间且和为1的概率分布：  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4H29dUg3COM4RRyxJzJ3xW30icJ8jaBPllbKBjibh2VHzXticrJb4kqXsQ/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.2798165137614679" data-type="jpeg" data-w="218" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 144.96px;background-color: transparent;" data-imgfileid="502988533" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(1)</span></span></span></td></tr></tbody></table>  
  
然而，VulDeePecker的代码部件仅部分反映执行顺序，缺乏更高层抽象与特征提取，难以完整刻画数据依赖和控制依赖，因此在逻辑型漏洞检测上仍面临挑战。  
  
VDSimilar[71]  
在VulDeePecker基础上改进，用孪生网络[116]  
结合欧氏距离取代softmax分类器。孪生网络可将两组输入耦合，直接通过损失函数计算向量间相似度。对于向量  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ElkAtJeYariaOTt6JvmSI1B50ic1SkUrQqYyDJ36DagcZDgTWbQiavaLA/640?wx_fmt=jpeg&from=appmsg "")  
  
和  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4gTRE9qc6ESDeiahlsANiaHUvsHDHPbsaTny4NxovEtjgjdcJUB47IvQg/640?wx_fmt=jpeg&from=appmsg "")  
  
，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4YN3ryDlcbibzgTdic90RtveNOnZ3vu8Hx6ibibAuLVdLWLIgHpgyzP0Naw/640?wx_fmt=jpeg&from=appmsg "")  
  
和  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4wLv7tFt6aX8yjdoJfajsY6NnVP84M7n8UiaAlp1PLpdgntUGK1KcCuA/640?wx_fmt=jpeg&from=appmsg "")  
  
分别是  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ElkAtJeYariaOTt6JvmSI1B50ic1SkUrQqYyDJ36DagcZDgTWbQiavaLA/640?wx_fmt=jpeg&from=appmsg "")  
  
和  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4gTRE9qc6ESDeiahlsANiaHUvsHDHPbsaTny4NxovEtjgjdcJUB47IvQg/640?wx_fmt=jpeg&from=appmsg "")  
  
的第  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4gVf28aID3mu4vPEtnmykedj9exKWV4u8L2VjFzy8ZViaRNSSanzw5Qw/640?wx_fmt=jpeg&from=appmsg "")  
  
个元素，采用欧氏距离及其相似度计算公式如下：  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4NpCB72laTV0j78B3mkpm5XoW5gZFCqHA8UeN6qVtDcZcTkgTSooHSQ/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.14" data-type="jpeg" data-w="300" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 199.68px;background-color: transparent;" data-imgfileid="502988542" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(2)</span></span></span></td></tr></tbody></table>  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4t2ZLmnA2OWiaEoU6jlOvdD9AtF4pwomIzKmh4LwcZibI7VWSA1T9X3Gg/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.15384615384615385" data-type="jpeg" data-w="299" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 199.36px;background-color: transparent;" data-imgfileid="502988545" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(3)</span></span></span></td></tr></tbody></table>  
  
陈小全等[41]  
以全连接神经网络（fully connected neural network, FCNN）为检测模型，末端相似性检测采用通用余弦相似度。对于向量  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ElkAtJeYariaOTt6JvmSI1B50ic1SkUrQqYyDJ36DagcZDgTWbQiavaLA/640?wx_fmt=jpeg&from=appmsg "")  
  
和  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4gTRE9qc6ESDeiahlsANiaHUvsHDHPbsaTny4NxovEtjgjdcJUB47IvQg/640?wx_fmt=jpeg&from=appmsg "")  
  
，计算式为：  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4noHNkaLTH2mCtcoaByHA8Vxfxow0A6pkCqlibZpHTeNIH7BfGYdk2CA/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.23958333333333334" data-type="jpeg" data-w="192" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 128px;background-color: transparent;" data-imgfileid="502988549" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(4)</span></span></span></td></tr></tbody></table>  
  
Thapa等[72]  
、VulBERTa[50]  
、LineVul[73]  
和AIBugHunter[74]  
采用Transformer[117]  
及其变体BERT[118]  
、RoBERTa[119]  
进行前期嵌入。相较于Word2Vec，Transformer的自注意力机制可充分学习代码上下文信息，支持LineVul与AIBugHunter的行级漏洞检测，在CWE-77（中和不当）、CWE-119（限制不当）、CWE-190（整型溢出）等简单非逻辑型漏洞上表现更优。同时，Thapa等、VulBERTa与LineVul使用BERT的掩码语言模型（masked language model, MLM）作为预训练任务：随机掩盖输入语料中的部分代码元素，并通过上下文预测该元素，从而强化模型对相邻元素关联的理解。  
  
（2）二进制代码方法  
  
αDiff[75]  
是首个将深度学习用于跨版本二进制相似性及漏洞搜索的方法。其采用CNN对汇编代码进行嵌入，并利用孪生网络计算CNN嵌入向量的三特征相似度；通过联合学习函数内、函数间、模块间三组特征，缓解二进制在架构、编译器及优化级别上的差异。对于两个待测函数  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf47PjDtZXTAVkibdTsWwVp14pBZ6T915hBXn9bjKBNQmL7navOBjy3Ozg/640?wx_fmt=jpeg&from=appmsg "")  
  
和  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4iaXm7opJYR0fgk40ORzee4lO7vHk5RpV5pESibAiaLUjM6FkWibrE1oRPw/640?wx_fmt=jpeg&from=appmsg "")  
  
，αDif使用了函数内距离  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4qjsypAWY1WEODAAaZzEEFa0mjbNmyaPPvIXCTr07ic16SsOQhn9iaaFQ/640?wx_fmt=jpeg&from=appmsg "")  
  
、函数间距离  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4PYzCDzPtToF0OITGyt9Oibvkjs8PA42G2cGjQyYfjZWm1zmcaW043CA/640?wx_fmt=jpeg&from=appmsg "")  
  
、模块间距离  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ico4Tq8umbljqLYhxkZzwLScYqiaW5uYptTsT4CDt2J4C07fBGygQVLw/640?wx_fmt=jpeg&from=appmsg "")  
  
计算相似度，其中  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf453tiaRnP0uOsX4Ificdic5piaklqpIOg6xfcyXfrAoQ5S6vsZS0UqNsKfw/640?wx_fmt=jpeg&from=appmsg "")  
  
是在(0,1)内预定义的超参数，用于抑制  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf40oaZKwmqouJnZAt83JiaR4S3TYbiaDxE3ZvQacavJaGaBgygKEcKTyibQ/640?wx_fmt=jpeg&from=appmsg "")  
  
的影响：  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4FRmuVicQSRLwRestf2r9UsSI3pvMD37gp3xN47WUVHTqZ4ldbX6gWbw/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.07971014492753623" data-type="jpeg" data-w="414" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 275.52px;background-color: transparent;" data-imgfileid="502988556" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(5)</span></span></span></td></tr></tbody></table>  
  
受卷积核感受野限制，αDiff[75]  
所用CNN更关注局部特征，难以捕获长距离依赖；而无论源代码或二进制代码，函数间的控制与数据依赖常跨越较长距离，故漏洞检测中CNN需与其他网络结合以弥补该缺陷。  
  
HAN-BSVD[54]  
融合Text-CNN与BGRU并引入注意力模块，在SARD数据集上取得较好性能。  
  
Trex[76]  
通过强制执行二进制获取汇编指令序列的动态值，并实施MLM预训练，以强化模型对二进制动态执行近似语义的理解；微调后，Trex在跨架构、优化及混淆函数匹配任务中表现突出。  
  
HAformer[77]  
通过融合十六进制机器码序列与汇编指令序列，缓解不同架构下二进制代码在反汇编及标准化时产生的信息损失，适用于跨架构漏洞检测。  
  
（3）基于代码片段的方法小结  
  
一般流程：代码→代码片段→嵌入向量→机器学习/特征算法→相似性计算→漏洞检测。  
  
优势及适用场景：处理简单直接，契合面向序列的神经网络，检测效率高，适合大规模代码检测。  
  
弱点：片段表示难以捕捉结构、语法、语义相似的漏洞特征，依赖嵌入模型对序列化词法特征的建模能力；所分析方法中50%（6∶12）采用Transformer自注意力机制。  
  
### 3.2 基于哈希的漏洞检测  
  
  
基于哈希的漏洞检测方法，指利用哈希算法结合漏洞特征进行漏洞检测的方法。哈希，指哈希算法生成的代码唯一映射散列值，具有指纹属性；哈希算法作为一种压缩映射的代码表征方式，直接将原始代码映射为固定长度哈希值，以高度压缩形式表征代码的序列化词法特征。基于哈希的典型漏洞检测方法具体信息见  
表6  
，表格说明与  
表5  
一致。  
  
表6  
     
基于哈希的典型漏洞检测方法  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4fmUOJmcF0vUXeEunI7lnDWMeaxiaI8YsmJ4o25kBBhjrSscDZEnJfLg/640?wx_fmt=jpeg&from=appmsg "")  
  
注：  
*表示仅供参考。  
  
  
（1）源代码方法  
  
CCAligner[48]  
采用e编辑距离检测大间隙克隆，e编辑距离定义为代码行插入/删除/替换的最小操作次数。在此基础上，CCAligner使用MurmurHash算法将不同代码映射为不同哈希值并存储，进而定义非对称Dice相似系数计算待测代码哈希与哈希库之间的相似度，计算式如下。  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4VichpackV21eK1OkM8n3OCUP7dEnm6t2WR73aOsqkgt6rDGhHwkX0Hg/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.23636363636363636" data-type="jpeg" data-w="220" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 176px;background-color: transparent;" data-imgfileid="502988557" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(6)</span></span></span></td></tr></tbody></table>  
  
其中，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf41CS4jRBSjn2icqXicq5LhsMqh2aaLuVM8dWUOmRelgo3rsQIOQbOCgEA/640?wx_fmt=jpeg&from=appmsg "")  
  
和  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4PmKDbBUXCYOJMeVI0fsLvg0Z30nbdlmIlFdSz03pxwhU7jibx3msxYA/640?wx_fmt=jpeg&from=appmsg "")  
  
是代码块  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4QDAodM897pa0dYFUTbQjkQcE6ibVFO2Xa0dhXcGroHb8Z8dB7eWg4icg/640?wx_fmt=jpeg&from=appmsg "")  
  
和  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4KPpYudj9WQFdxaOcaWNaoyuN0gR11o15Hiciac9WHfRh1ujw1fqlGYibw/640?wx_fmt=jpeg&from=appmsg "")  
  
的代码窗口集，min函数将对较小代码块中包含的窗口数量的相似度得分进行标准化。  
  
李赞等[78]  
引入代码切片技术去除漏洞样本中的无关代码，通过代码标准化及HashPJW算法将漏洞特征代码映射为固定长度哈希值以计算相似度。鉴于HashPJW算法本身强度较低，生成的哈希值更易遭受碰撞攻击，可能对搜索结果的准确率造成潜在负面影响。  
  
Centris[80]  
对代码进行冗余消除和编码分割以区分开源组件，再通过局部敏感哈希（locality sensitive Hash, LSH）签名匹配，可缓解因代码分割不准确导致的假阳性问题。  
  
V0Finder[49]  
是检测漏洞零（vulnerability zero, VZ）的框架，通过构建漏洞传播图并结合趋势科技局部敏感哈希（trend micro locality sensitive Hash, TLSH）追踪漏洞传播，发现潜在克隆漏洞。  
  
V1SCAN[79]  
是Woo等[80]  
基于V0Finder[49]  
改进的1-day漏洞精确检测方法，沿用Centris和Ctags[120]  
完成组件识别，并利用TLSH检测漏洞。V1SCAN将V0Finder的假阴性率由55%降至9%，具备可扩展性。为缓解TLSH对微小差异的忽略，Woo等[80]  
对漏洞代码进行细粒度行级处理，显著提升检测性能。  
  
（2）二进制代码方法  
  
作为一种大规模跨平台同源二进制文件检索方法，陈昱等[81]  
采用GloVe将多架构、多编译器及多优化等级的机器码漏洞样本进行词嵌入，通过BGRU与孪生网络框架计算余弦相似度以判定二进制文件漏洞同源性，并利用LSH算法实现同源文件快速检索。然而，该方法检测粒度为文件级，无法精确定位代码文件内的漏洞位置。  
  
（3）基于哈希的方法小结  
  
一般流程：代码→哈希算法→哈希值→相似性计算→漏洞检测。  
  
优势及适用场景：得益于哈希算法的高效性，正向计算开销小，适用于快速、大批量的漏洞搜索任务。  
  
弱点：表征方式仅反映代码的直接顺序排列特征；66.7%（4∶6）的检测方法未采用机器学习技术，仅依赖匹配算法。检测性能与匹配算法阈值设置强相关：阈值过低易因无法区分漏洞样本与修补样本的微小差异而产生误报；阈值过高则使模型泛化能力大幅下降。李赞等[78]  
、V0Finder[49]  
均设置极高阈值以保持高精确率，此时模型基本不具有泛化性。  
  
### 3.3 基于树的漏洞检测  
  
  
基于树的漏洞检测方法，一般指从漏洞样本数据集提取AST及其派生树形结构，并利用机器学习模型学习节点与边特征，实现漏洞检测。  
  
AST以层级细分树形结构反映代码词法、语法特征及部分控制流、数据流信息，但不直接表示所有执行路径与数据依赖。  
  
基于树的典型漏洞检测方法的具体信息见  
表7  
，表格说明与  
表5  
一致。  
  
表7  
     
基于树的典型漏洞检测方法  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4sYsdJ2r5VhWeiaC444kptiasNTB6mTgdVu3IeZ22kPV6o9qZxuk45dTw/640?wx_fmt=jpeg&from=appmsg "")  
  
注：  
*表示仅供参考。  
  
  
（1）源代码方法  
  
Lin等[82]  
提出一种异构深度学习漏洞检测框架，使用两组BLSTM学习代码AST的词嵌入向量，并将其输入随机森林（random forest, RF）分类器进行分类。RF的计算式见  
式(7)  
。  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4fvD6EhmjLHzZUegon8YCuK9gQwzLxYBPs0E4OjHt3v82KStmWA2cWw/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.30538922155688625" data-type="jpeg" data-w="167" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 111.04px;background-color: transparent;" data-imgfileid="502988564" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(7)</span></span></span></td></tr></tbody></table>  
  
其中，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4FjOUonR47DS8tSGHkZOKGWoaAESricgdmvGMnxw8vLj33vKRP4vBF1Q/640?wx_fmt=jpeg&from=appmsg "")  
  
表示每个决策树的权重，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4GZQpO1WPysZjsDcRdGVkMUYHtQNSibPhDVv7d5hawPdQX5b7w8Nj2VA/640?wx_fmt=jpeg&from=appmsg "")  
  
表示每个决策树的输出值。  
  
CD-VulD[83]  
同样以BLSTM作为特征学习核心，引入度量迁移学习框架[121]  
（metric transfer learning framework, MTLF）学习AST的跨域表示，最终通过马氏距离配合线性判别分析（linear discriminant analysis, LDA）完成漏洞检测。两个向量和之间的马氏距离计算式为：  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4nsdEGYTricDpQyjmhALJibfh1bZBfOvYib9siaW38cqzADXfDVM2iaqxIJg/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.1245674740484429" data-type="jpeg" data-w="289" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 192.64px;background-color: transparent;" data-imgfileid="502988570" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(8)</span></span></span></td></tr></tbody></table>  
  
尽管Lin等[82]  
、CD-VulD[83]  
认为BLSTM克服了传统RNN的梯度消失问题，但在处理超长序列时，BLSTM仍面临梯度消失挑战。  
  
EPVD[84]  
提出基于AST构建CFG的方法，设计贪心算法从CFG中选择典型执行路径，使用CodeBERT[122]  
将路径嵌入向量，再利用CNN学习并用MLP分类。与αDiff[75]  
类似，EPVD[84]  
受CNN卷积核限制，难以检测含长距离执行路径的漏洞。  
  
（2）二进制代码方法  
  
Asteria[53]  
提出AST编码方法，用Tree-LSTM[123]  
将标准化后的反汇编二进制代码编码为向量，再用孪生网络计算相似度。针对函数内联问题，Asteria[53]  
过滤汇编指令数低于阈值的被调用函数，并以被调用函数集大小校准相似度。  
  
（3）基于树的方法小结  
  
一般流程：代码→树形结构→嵌入向量→机器学习→相似性计算→漏洞检测。  
  
优势及适用场景：AST对语法特征表征全面，且提取技术成熟，信息损失少；泛化性好且适用于跨领域任务，如CD-VulD[83]  
支持跨域检测，Asteria[53]  
可跨ARM、x86、PowerPC架构检测二进制函数。  
  
弱点：AST多级语法细分导致节点冗余，计算开销大。以Devign[32]  
（27 318个函数样本）为例，Joern提取的AST平均节点数为10 639个，而CFG平均节点数仅1 603个，约为AST的15.1%。  
  
### 3.4 基于图的漏洞检测  
  
  
基于图的漏洞检测方法，指从漏洞样本数据集提取图形结构，利用机器学习模型学习图的节点特征、边特征及结构关联特征，并借助神经网络实现有效漏洞检测；亦可结合图形结构特征与传统相似性算法完成检测。  
  
图形结构是一种比树形结构更灵活的非线性结构：树形结构必须严格定义父子关系，而图形结构允许任意网状连接（包括环路和双向边）。在代码表征中，图形结构涵盖CFG、数据流图（data flow graph, DFG）、程序依赖图（program dependence graph, PDG）等，可准确刻画控制流与数据流；研究者在CFG、PDG基础上进一步设计出属性控制流图（attribute control flow graph, ACFG）、边程序依赖图（edge program dependence graph, ePDG）等，扩展了图形结构的特征范围与表达能力。  
  
基于图的典型漏洞检测方法的具体信息见  
表8  
，表格说明与  
表5  
一致。  
  
表8  
     
基于图的典型漏洞检测方法  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf44Xq5iayb3J6rdwuStEhtUiaxtNKiaHnfoK1IfwVl0m6b2fZSJ8Ot6Az8w/640?wx_fmt=jpeg&from=appmsg "")  
  
注：  
*表示仅供参考。  
  
  
（1）跨模态方法  
  
BugGraph[46]  
是一种基于图三元组损失网络（graph triplet-loss network, GTN）的跨模态漏洞检测方法。该方法以汇编代码作为源代码与二进制代码的中间表示：先将二进制代码反汇编为汇编代码，提取ACFG，再用GNN将其嵌入GTN进行训练。ACFG在CFG基础上增加了变量值等属性信息，可更全面描述程序执行过程。同时，BugGraph[46]  
利用Origin[124]  
识别待测二进制代码的编译选项，实现跨编译器、跨优化的检测目标。  
  
（2）源代码方法  
  
CFG类型。CFG用于表征代码的控制流。Wang等[85]  
在CFG基础上增加数据依赖图（data dependence graph, DDG）来表征代码的数据依赖关系。  
  
DDG类型。DDG侧重表征代码的数据依赖特征。Tracer[96]  
将源代码DDG的静态污点信息与漏洞数据集进行相似性比较，用于搜索整数溢出、格式化字符串、命令注入等数据流相关漏洞。  
  
PDG类型。PDG用于表征代码的控制依赖和数据依赖特征。µVulDeePecker[86]  
是VulDeePecker[47]  
的改进，其为每个训练样本生成系统依赖图（system dependence graph, SDG），SDG包含一组PDG。VulCNN[88]  
、mVulPreter[89]  
、VulChecker[45]  
以及SPIDER[99]  
也采用PDG进行代码表征。需要注意的是，VulChecker将源代码编译成LLVM IR，生成更接近底层表示的ePDG，用于解决源代码在数据类型、临时变量和存储位置方面的歧义。  
  
CPG类型。CPG作为一种综合图，同时包含AST、CFG、PDG信息，因此在表征词法、语法、控制流、数据流方面具有显著优势，但也面临高于AST的计算开销。VGRAPH[94]  
、段旭等[87]  
、Reveal[34]  
、mVulPreter[89]  
、GraphSPD[91]  
、CPVD[92]  
、VulGDA[93]  
以及MAGNET[98]  
均以CPG作为主要表征方式。其中VGRAPH通过三元组匹配算法使漏洞样本与待测代码进行CPG子图匹配，在泛化性方面存在挑战。  
  
其他图类型。CarrotsBlender[95]  
构建漏洞调用图（vulnerability call graph, VCG）来追踪漏洞相关函数的调用关系，旨在确定漏洞函数在空间维度（文件粒度）中的分布。给定一个VCG  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4Lp3h2EnibDR86l77gwRaKxVkmgS5mmXaJm4wb6JYbHr2UY8n4KgU1lw/640?wx_fmt=jpeg&from=appmsg "")  
  
，其中  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4q5QnK21meqGEhEUxejE8E5bibiatUvy94h7sdpkGkOGZl6UO0dVImZTA/640?wx_fmt=jpeg&from=appmsg "")  
  
是一个非空的有限函数集，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ee75OMbKXvPoicZfBefsQz3TUKPgKR4KiaJhMD1e1RM9D5zoW9bBgknA/640?wx_fmt=jpeg&from=appmsg "")  
  
是一个非空的有限的脆弱函数集，其中  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ee75OMbKXvPoicZfBefsQz3TUKPgKR4KiaJhMD1e1RM9D5zoW9bBgknA/640?wx_fmt=jpeg&from=appmsg "")  
  
⊆  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4q5QnK21meqGEhEUxejE8E5bibiatUvy94h7sdpkGkOGZl6UO0dVImZTA/640?wx_fmt=jpeg&from=appmsg "")  
  
，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4J325r9dGyEBADwt7ibKa4OOJ1YYTHWugG9mOOFWjia0DsIPeyS6d1pGg/640?wx_fmt=jpeg&from=appmsg "")  
  
⊆  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4IIvMdu6d7oAbbwEdfEGAH1kUKHjyibfmVFriamZ0vo7UMibicoMiar7PuMg/640?wx_fmt=jpeg&from=appmsg "")  
  
是函数调用。对于两个漏洞函数  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4OibniaicCe1OQbrZ9yCyOrLia5I2W9K9PVmLFja6ibn3ouKOR30XELMPUSA/640?wx_fmt=jpeg&from=appmsg "")  
  
和  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4jtWRRGPiasJIy7UhcYvMjHohNh3e2WtAQKaEic6SH124OphBibp4eCKrw/640?wx_fmt=jpeg&from=appmsg "")  
  
，其中  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4ythvFCicgpicu3KTiakfF49lrHYTibqIy74zucwPDWTcWDu9meL2lLC0XQ/640?wx_fmt=jpeg&from=appmsg "")  
  
，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4LJficBAYHa9xNWWKc68rDt4JAQ8gQrk2gcKs6zd4FCPryF6eJIRQy4Q/640?wx_fmt=jpeg&from=appmsg "")  
  
，  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4cia2j0wg9u3op831T2waFgUny6VDDHEmWziccsG524iacGH5e0I6Rg5rA/640?wx_fmt=jpeg&from=appmsg "")  
  
，且  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4qC04OS16KP20Pyku8nyaVNvpf0ZB7y5K1stu2Y8vFZWDUgNuSTSzibQ/640?wx_fmt=jpeg&from=appmsg "")  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4J325r9dGyEBADwt7ibKa4OOJ1YYTHWugG9mOOFWjia0DsIPeyS6d1pGg/640?wx_fmt=jpeg&from=appmsg "")  
  
或者  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4uONWFba3k3RwZr3Pmh5cLVFzkZw8VD1JMES4SyhelI8vnVf3OHdupA/640?wx_fmt=jpeg&from=appmsg "")  
  
，计算距离公式如下：  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4iaibI4iaBfhuR7UBicWRPzHzzCM3o2736rNheUy1iaFVngT4W4zGiacF2nfg/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.10543130990415335" data-type="jpeg" data-w="313" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 208.32px;background-color: transparent;" data-imgfileid="502988584" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(9)</span></span></span></td></tr></tbody></table>  
  
（3）二进制代码方法  
  
CFG类型。VulSeeker[62]  
、VulSeeker-Pro[67]  
以及SMCSA[100]  
均从二进制汇编代码提取CFG嵌入向量，利用余弦相似度（  
式(4)  
）进行相似漏洞的代码检测。DEEPBINDIFF[65]  
提出一种k  
-hop贪婪匹配算法对基本块级的CFG嵌入向量进行漏洞搜索。BINKIT[66]  
通过CFG特征值的相对差值计算函数相似度。BINGO-E[63]  
、BinSeeker[68]  
则用Jaccard距离衡量待测代码与漏洞样本间的相似度，并通过仿真消除函数内联影响，增强模型的鲁棒性。对于集合A  
和B  
，Jaccard相似度计算公式如下：  
  
<table><tbody><tr style="margin: 0px;padding: 0px;"><td data-colwidth="45" width="45" style="margin: 0px;padding: 0px;border: none !important;"><section><span leaf=""><br/></span></section></td><td align="center" style="margin: 0px;padding: 0px;border: none !important;"><span style="margin: 0px;padding: 0px;"><span leaf=""><img data-src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4SCjzydpU7bKl36fI5VvWv5aZwBzPlpVUwET9fOYhSiaNWEWllBltTog/640?wx_fmt=jpeg&amp;from=appmsg" class="rich_pages wxw-img" data-ratio="0.15789473684210525" data-type="jpeg" data-w="304" style="margin: 2px 0px;padding: 0px;vertical-align: middle;max-width: 100%;width: 202.56px;background-color: transparent;" data-imgfileid="502988582" data-aistatus="1"/></span></span><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"></span></span></td><td data-colwidth="45" width="45" align="right" style="margin: 0px;padding: 0px;border: none !important;font-size: 13px;"><span style="margin: 0px;padding: 0px;"><span style="margin: 0px;padding: 0px;"><span leaf="">(10)</span></span></span></td></tr></tbody></table>  
  
DFG类型。PalmTree[52]  
在提取DFG的基础上设计上下文窗口预测（context window prediction, CWP）、定义使用预测（defuse prediction, DUP）预训练任务，在真实环境数据集上取得良好检测性能。  
  
（4）基于图的方法小结  
  
一般流程：代码→图形结构→嵌入向量→机器学习/特征算法→相似性计算→漏洞检测。  
  
优势及适用场景：图形结构依图类型可分别表征代码的语法、控制流、数据流、依赖或函数调用关系，覆盖率高，适用于检测结构、语义复杂漏洞。基于图的方法中，23.1%（6:26）具备可扩展性或鲁棒性，两类占比均高于其他表征方式。  
  
弱点：图形结构信息丰富且复杂，时空开销大，大规模检测面临挑战；提取工具（如Joern）的系统误差可能引入图信息偏差与遗漏；图神经网络潜在的过度平滑亦会使部分特征失效或噪声化，影响检测性能。  
  
### 3.5 基于指标的漏洞检测  
  
  
指标，即代码中各类元素的统计学特征，具体指计算漏洞特征指标得分或漏洞样本匹配指标得分。基于指标的方法通常结合代码相似性技术与统计学指标检测漏洞。  
  
基于指标的典型漏洞检测方法的具体信息见  
表9  
，表格说明与  
表5  
一致。  
  
表9  
     
基于指标的典型漏洞检测方法  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf47fQ3VG1XdWxV3ic5aXVqhJkuqNFSicJgwDYQmAvybVQy9t1e2Ep4XsSg/640?wx_fmt=jpeg&from=appmsg "")  
  
注：  
*表示仅供参考。  
  
  
（1）跨模态方法  
  
B2SFinder是Yuan等[101]  
提出的二进制到源代码匹配方法，选用字符串、输出函数、全局字符数组、全局整数数组、全局枚举数组、If/Else、Switch/Case 7项指标，并设计基于S-IDF（TF-IDF变体）的匹配算法，用于检测开源软件中指标显著的克隆漏洞。  
  
（2）源代码方法  
  
Leopard由Du等[102]  
提出，其使用两组指标：复杂度指标（函数、循环）与漏洞指标（依赖性、指针、控制结构），通过计算得分判断漏洞。敏感性分析表明，复杂度指标对Leopard贡献显著；相比漏洞指标，复杂度指标在整体相似度上提供粗粒度指向，并缓解单独使用漏洞指标带来的误报。  
  
Chinthanet等[103]  
针对JavaScript提出基于物料清单的开源组件识别方法以检测克隆漏洞，物料清单涵盖Node.js的包、模块、函数、类、方法及项目等指标，旨在提升JavaScript开源组件识别的可靠性。  
  
（3）基于指标的方法小结  
  
一般流程：代码->指标->特征算法->相似性计算->漏洞检测。  
  
优势及适用场景：统计学特征，具有直接性和全局性，更适于漏洞检测辅助；如Leopard[102]  
的疑似漏洞排序可为其他方法提供有效辅助，提升检测效率。  
  
弱点：指标设定主观且有限，难以检测复杂类型漏洞；如B2SFinder[101]  
仅7项匹配指标，无法覆盖复杂语义特征漏洞。  
  
### 3.6 基于混合表征的漏洞检测  
  
  
基于混合表征的漏洞检测方法，通常选取代码片段、哈希、树、图等表征中的两种或多种进行综合性表征，并结合机器学习模型或特征算法实施漏洞检测。  
  
基于混合表征的典型漏洞检测方法的具体信息见  
表10  
，表格说明与  
表5  
一致。  
  
表10  
     
基于混合表征的典型漏洞检测方法  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4yVCNrOHKjicsfbkictD72MsEYAYLsuiboBjsWYLrpYGuRiczjpRgX55jGg/640?wx_fmt=jpeg&from=appmsg "")  
  
注：  
*表示仅供参考  
  
  
（1）跨模态方法  
  
Tao等[39]  
以汇编代码为源-二进制中间表示，设计跨模态细粒度特征对齐算法实现漏洞检测；其对齐依赖带标注的编译过程，而编译过程受架构、编译器、优化选项等多因素影响，提升对其覆盖率仍面临挑战。  
  
（2）源代码方法  
  
树+图类型。Devign[32]  
、FUNDED[31]  
、ContraFlow[69]  
、AMPLE[29]  
、FBLD[109]  
、PDBERT[110]  
采用树-图混合表征。具体地，Devign[32]  
提出节点连通序列（node-connected sequence, NCS），按代码顺序连接AST相邻节点以保留序列特征；ContraFlow[69]  
在自监督对比学习中利用静态值流（static value-flow, SVF）生成值流图（value-flow graph, VFG），并用Z3模理论可满足性（satisfiability modulo theories, SMT）验证路径可行性；FBLD[109]  
提取漏洞语句的控制/数据依赖构建具有漏洞指向性的特征依赖图（feature dependence graph, FDG）；IVDetect[104]  
在Token级代码上提取AST与PDG，采用FA-GCN强化稀疏特征理解；PDBERT[110]  
设计CDP与DDP预训练任务，引导模型学习细粒度控制与数据依赖特征。  
  
哈希+树+图类型。MVP[30]  
、MOVERY[51]  
以签名化的代码特征为切入点，提取多种树/图结构并生成签名，便于快速匹配和搜索。  
  
代码片段+树+图类型。SySeVR[105]  
、MVD[106]  
、DeepVD[107]  
、VDoTR[108]  
、LIVABLE[111]  
、FVD-DPM[113]  
以及VulSim[114]  
均使用代码片段、树、图结构作为表征，以增强模型对多类型特征的学习。MVD[106]  
引入调用图（call graph, CG）以捕获更全面的代码语义；DeepVD[107]  
使用EFG（exception flow graph）表征控制流，包含异常处理流特征  
  
（3）二进制代码方法  
  
代码片段+树+图类型。Asm2Vec[64]  
是一种跨编译器、优化选项且抗混淆的表示学习模型，从汇编语言CFG提取执行路径，经Token化并添加伪逻辑后生成向量；然而，Asm2Vec未通过显式克隆子图或符号等价证明来解释结果，可解释性有限。BinVulDet[40]  
、jTrans[55]  
、VulHawk[56]  
与VulANalyzeR[57]  
联合嵌入汇编指令序列及树/图结构，以保证特征的充分表征。  
  
（4）基于混合表征的方法小结  
  
一般流程：代码→混合表征方式→嵌入向量→机器学习/特征算法→相似性计算→漏洞检测。  
  
优势及适用场景：代码表征方式具有可叠加性。基于混合表征的方法泛用性、鲁棒性强，检测性能较高，适用于多种类型且结构复杂的漏洞检测。12.5%（3:24）的方法具有鲁棒性，比值仅次于基于图的方法；41.7%（10:4）的方法检测粒度为切片/行，比值显著高于任意单一表征方式。此外，在二进制代码方法中，80%（4:5）的方法可跨优化等级，60%（3:5）的方法可跨架构、编译器差异。  
  
弱点：多类特征提取及预处理开销大。例如，FBLD[109]  
在提取AST、CDG、DDG的基础上再提取FDG，时间复杂度为O  
(n  
³)，远高于一般表征方式的预处理时间。此外，混合表征需处理较多噪声，并设计复杂的组合式神经网络以融合多类特征。例如，DeepVD[107]  
在提取AST、PDT、EFG后，采用GRU+Tree-LSTM+FCN的组合网络作为中间隐藏层，最终以MLP判别漏洞。  
  
### 3.7 漏洞检测中的机器学习技术  
  
  
鉴于现有漏洞检测模型在前期嵌入、预训练任务、训练检测环节均涉及机器学习技术，因此本文将对现有方法所采用的机器学习技术进行综合分析。具体分析见  
表11  
。  
  
表11  
     
现有方法的机器学习技术分析  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4xAX2VzF7GibS2TOOxTdliaVp89X1fpX6b747g4GuXfmnGbglO3HqQvBw/640?wx_fmt=jpeg&from=appmsg "")  
  
  
（1）前期嵌入  
  
词嵌入。机器学习类现有方法中42.1%的嵌入采用词嵌入方法Word2Vec[115]  
，占比最高。无监督的Word2Vec通过Skip-gram和连续词袋模型（continuous bag of words, CBOW）实现代码到向量的映射。但受限于向量的唯一性，无法处理多义代码。VulCNN[88]  
采用的Sent2Vec[125]  
与MVD[106]  
采用的Doc2Vec[126]  
均由Word2Vec派生。IVDetect[104]  
采用的GloVe[127]  
考虑全局信息，可缓解多义代码问题，但计算开销较高。  
  
图嵌入。mVulPreter[89]  
的Structure2Vec[128]  
和VulBG[90]  
的Node2Vec[129]  
在捕获节点上的代码信息的同时保留边关系特征，缺点是计算复杂度高，且对参数敏感。  
  
代码嵌入。Transformer衍生的BERT[118]  
、CodeBERT[122]  
、RoBERTa[119]  
被用于前期代码嵌入，这些模型均含自注意力机制，可充分学习代码上下文信息。  
  
（2）预训练任务  
  
使用预训练的方法中，75%采用MLM[118]  
作为预训练任务。MLM为BERT的默认任务，用以提升模型对代码相邻元素的理解与抽象。此外，PalmTree[52]  
针对汇编指令设计CWP与DUP任务，学习执行序列与数据依赖。  
  
jTrans[55]  
提出跳转目标预测（jump target prediction, JTP）任务，强化对jmp/js后跳转地址的学习；VulHawk[56]  
使用根操作数预测（root operand prediction, ROP）与相邻块预测（adjacent block prediction, ABP）任务，学习汇编操作数映射及基本块间数据流关系。  
  
（3）训练检测  
  
现有方法使用的机器学习模型主要来自前馈神经网络、CNN家族、RNN家族、GNN家族等。  
  
前馈神经网络。典型代表多层感知机（multilayer perceptron, MLP），通过组合多个感知机实现非线性映射，可处理异质特征并常与Softmax/Sigmoid配合完成检测阶段的分类。  
  
CNN家族。现有方法采用CNN、Text-CNN等；受卷积核限制，传统CNN侧重局部特征，需增加深度以捕捉长距离依赖。  
  
传统RNN家族。包括BLSTM、Tree-LSTM、GRU、BGRU等；RNN为顺序结构，沿序列方向链式连接节点，输入序列过长时易发生信息衰减。  
  
Transformer及其派生网络。Transformer并行计算，无信息衰减；现有方法使用Transformer、异构图Transformer[130]  
（heterogeneous graph transformer, HGT）、生成式预训练Transformer[131]  
（generative pre-trained transformer, GPT）等。自注意力层可并行关注多组特征，但随输入规模增大，时间和空间开销显著增加。GPT衍生出ChatGPT、GPT-4等，参数量达亿级，计算成本高昂。  
  
GNN家族。现有方法采用FS-GNN、GGNN[132]  
、GCN[133]  
、GAT[134]  
等；GNN擅长学习网状图结构的复杂节点特征，常与图表征结合，在控制依赖、数据依赖及调用关系理解上具优势。  
  
其他网络类型。孪生网络[115]  
耦合两种神经网络，可直接通过损失函数计算两组输入的相似度；对比学习则通过最大化相关样本、最小化无关样本的相似性来学习表示。  
  
### 3.8 漏洞检测的性能评估  
  
  
现有方法的漏洞检测性能评估指标包括：准确率、精确率、召回率、F  
1值等。75种方法在既定测试数据集下使用评估指标与同类基线方法进行比较，得出该方法的漏洞检测性能情况。由于不同文献的评估指标的测试数据集各异，因此前文表格中所列出的精确率、召回率、F  
1值无法直接用于横向比较。  
  
（1）漏洞检测任务类型和通用数据集  
  
本文从漏洞检测任务类型和通用数据集的角度出发，筛选可横向比较的评估指标。按末端相似性检测技术及任务应用，将75种方法分为两类：漏洞判别类、漏洞搜索类。  
  
漏洞判别类方法：以Softmax/Sigmoid分类器对单段代码给出“漏洞/良性”标签，共44种（58.7%，44:75），含可兼顾搜索的VulSim[114]  
与PalmTree[52]  
模型。  
  
漏洞搜索类方法：以余弦距离/欧氏距离/哈希算法对单段或多段代码返回数据集中相似漏洞，共33种（44%，33:75），含VulSim和PalmTree模型。  
  
通用漏洞测试数据集统计如下。  
  
漏洞搜索类无通用数据集：69.7%（23:33）使用自建小型孤立数据集，无法跨文献横向比对。  
  
漏洞判别类存在通用数据集：SARD[24]  
、Devign[32]  
、Big-Vul[33]  
、Reveal[34]  
分别被引用20、13、13、12次，居前4位，可用于直接横向比较。  
  
（2）漏洞判别类方法：精确率和召回率  
  
鉴于数据完整性与指标通用性，本文选用精确率、召回率对44种判别类方法在SARD、Devign、Big-Vul、Reveal上的文献结果进行横向比较。同一方法在同一数据集的多次结果取平均。共获得18、17、16、14种方法的可用数据；基于哈希与指标的方法均属搜索类，不纳入比较。  
  
具体评估指标如  
图6  
所示，深灰色条形柱Rec表示HAN-BSVD[54]  
和VDoTR[108]  
的指标数据仅在部分SARD数据集下获得。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4OYMyN5x7myBSqLSNBJrAgTAFiah02puiatp46vrL0WibLfvUiaWOTlNSgQ/640?wx_fmt=jpeg&from=appmsg "")  
  
图6  
     
漏洞判别类方法的评估指标  
  
（3）精确率和召回率评估  
  
分析  
图6  
发现，混合表征在Devign、Reveal平均精确率最高；代码片段与树表征分别在SARD、Big-Vul最高。事实上，漏洞特征通常较为复杂，混合表征能够较为全面地捕获这些特点，故平均精确率最优。其中FBLD[109]  
凭漏洞指向性FDG在Devign、Reveal中取得最高的精确率。SARD样本简短且人工构造，代码片段契合其简单特征，故精确率相对最佳。Big-Vul仅EPVD[84]  
一种树表征，其基于AST构造控制流，表现良好。  
  
混合表征在SARD、Devign平均召回率最高；树与图表征分别在Big-Vul、Reveal最优。混合表征覆盖多维度特征，故在简单SARD与复杂Devign均能查全较好，其中AMPLE[29]  
、VulANalyzeR[57]  
融合图结构与代码序列获最佳。图表征适应Reveal的复杂代码，VulGDA[93]  
以GRU学习CPG特征，召回率佳。代码片段因缺失结构特征，平均召回率在4种数据集下均未领先。  
  
综上，在4种数据集下，基于混合表征的方法总体优于基于代码片段、树、图表征的方法，分别在50%数据集取得最高平均精确率与最高平均召回率。  
  
### 3.9 漏洞检测的开销分析  
  
  
漏洞检测的开销贯穿各环节。对单个待测样本而言，代码预处理、表征、模型训练及检测（判别/搜索）均产生计算开销。  
  
在本文分析的75篇文献中，分别有25.3%（19:75）、54.7%（41:75）分别提及了预处理/表征/训练阶段和检测阶段的开销。由于实验平台、环境与测试集差异，单一文献数据无法直接横向比较。  
  
（1）锚点数据  
  
本文从锚点数据出发，对文献中可横向比对的开销信息进行分析。具体做法是：按检测任务（判别/搜索）分别筛选各文献与现有方法对比的开销数据，确定“锚点方法”（即被最多文献用于开销比较的方法），再以锚点方法的开销为基准，按比例调整其余参比数据，使不同文献结果具有同一比较基准，从而缓解实验平台、环境、数据集差异带来的不可横向对比问题。  
  
经统计，共确定2个锚点方法：漏洞判别类中，源代码方法Devign[32]  
以5次参比（共涉及10个方法）成为锚点；漏洞搜索类中，二进制方法Gemini[135]  
以4次参比（共涉及5个方法）成为锚点（Gemini系2017年工作，未纳入本文分析范围）。本文取FBLD[109]  
文献中Devign[32]  
开销（训练时间49 min/检测时间3.4 s）与VulSeeker-Pro[67]  
文献中Gemini[135]  
开销（嵌入处理时间0.15 s）为基准值1，计算其余方法的相对开销；同一方法存在多组数据时取均值，结果如  
图7  
所示，*标出锚点方法。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4Q8thDx8AXL0eeX23icGiad296Qg46mSZ57IckBfz0PUd7xd5IQkVxW6g/640?wx_fmt=jpeg&from=appmsg "")  
  
图7  
     
漏洞检测方法的相对开销情况  
  
（2）开销分析  
  
漏洞判别类源代码方法方面。由  
图7  
(a)可见，混合表征方法普遍训练与检测开销较高，因其需学习混合特征且依赖复杂组合网络，开销高符合预期。代码片段方法中，LineVul[73]  
的训练开销和检测开销分别高于81.8%和63.6%的参比方法，归因于其采用12头多层双向自注意力BERT，注意力层数与头数显著增加计算开销。值得注意的是，基于图的方法VulCNN[88]  
检测开销最低，因其检测阶段仅用CNN对图像化代码分类，无冗余处理。  
  
漏洞搜索类二进制代码方法方面。由  
图7  
(b)可见，基于图的VulSeeker-Pro[67]  
开销最高，因其额外引入模拟仿真环节；基于代码片段的 HAformer[77]  
开销最低，其直接处理汇编与机器码，无须构图提取结构特征。  
  
综上，基于混合表征、图的方法普遍计算开销较高，但需注意到神经网络/相似性算法本身设计存在多样性和复杂性，非混合/图的方法在实现层面亦可能出现高开销。  
  
### 3.10 代码表征与漏洞检测总结  
  
  
第3.1～3.9节已完成各类表征漏洞检测方法分析、机器学习技术分析、性能评估及开销分析。现总结代码表征与漏洞检测要点，按表征类型归纳所用机器学习技术、表征特点及整体特点，见  
表12  
。  
  
表12  
     
代码表征与漏洞检测总结  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/IgR5nfFgN9MAmzGU9Y6sYjcs4fdlaCf4K6BrbzzhCfXkcRgQX5Y8DiawaMiaibp9XFYjDsTFe7BT5D4mGicdFgiaUGw/640?wx_fmt=jpeg&from=appmsg "")  
  
  
## 4 研究挑战与展望  
  
  
### 4.1 面临的挑战  
  
  
尽管近年来基于代码相似性的软件漏洞检测技术取得长足发展，该领域仍面临以下挑战。  
  
1) 漏洞样本数据集规模不足且滞后。相较于NVD[25]  
等平台的漏洞总量，现有数据集规模仍显不足，且样本时间普遍早于文献公开时间，多数方法在发布后不再更新数据，导致检测真实代码的有效性下降。  
  
2) 代码标准化实证研究薄弱。除OOV问题外，虽有研究[21-22,122]  
初步探讨标准化策略对检测效果的影响，但缺乏系统的定量/定性实证，尚难形成统一标准。  
  
3) 代码表征需进一步细化、特化。当前表征多与克隆检测重合，未充分挖掘漏洞特有的结构与语义特征，难以适配多类型、多语义场景。  
  
4) 多维度表征计算开销大。混合表征通常综合词法、语法、控制流、数据流、调用关系等多维信息，时空资源消耗显著，难以兼顾速度与精度。  
  
5) 机器学习技术实证与泛化研究不足。随着技术迭代，漏洞检测需持续探究更具语义相关性与泛化性的模型。尽管Transformer衍生网络、GNN家族在多个数据集表现良好，其在真实场景、跨平台下的泛化能力与稳定性仍缺乏大规模验证。  
  
6) 跨语言漏洞检测仍待突破（源代码方法）。多数方法仅面向单一高级语言（如C/C++、Java），通用的跨语言检测方案仍是难题。  
  
7) 跨架构、编译器、优化等级及抗混淆能力需强化（二进制代码方法）。虽有Asm2Vec[64]  
、Trex[56]  
等缓解差异，但有效性有限；抗混淆方面，现有方法难以应对混合式混淆，问题仍多。  
  
8) 可解释性仍不足。黑盒模型难以给出数学自洽的解释，GNNExplainer[136]  
、Grad-CAM++[137]  
等解释器虽能够部分缓解此类问题，但本质仍为神经网络，且忽略边联合效应，解释结果不够忠实且冗长。  
  
9) 缺乏统一全面的评估标准。现有研究多聚焦精确率、准确率、召回率、AUC、F  
1等传统指标，忽视可扩展性、可解释性、泛化能力等关键特性，碎片化评估降低可比性，制约技术全面评价。  
  
10) 检测准确性问题（假阳性/假阴性）仍未有效缓解。漏洞表征差异大、模型泛化受限，导致实际应用中误报、漏报普遍，需从样本质量、特征学习及解释机制3个方面改进。  
  
### 4.2 未来的研究方向  
  
  
基于代码相似性的软件漏洞检测领域仍存挑战，但可在未来逐步解决。本文从技术融合趋势与基础设施建设两个视角提出可行研究方向。  
  
（1）推进跨模态、多语言、集成式神经网络等技术融合的检测模型设计  
  
现有模型多面向单一输入形式（源代码/二进制代码）与单一语言（如C/C++），通用性不足。跨模态、跨语言、多维融合的特征学习与集成建模更具表达力，将成为未来重要研究方向。  
  
跨模态特征统一建模。已有方法[41,46,101]  
较单模态方案更具普适性，且源码-二进制代码间并无不可逾越壁垒。随着反汇编、反编译、中间语言转换及特征映射技术成熟，跨模态检测将成为主流。研究建议：聚焦模态差异，采用“统一模态形式”或“同特征映射”。前者将源码与二进制转为统一表示（中间语言/汇编等）以消除词法、语法、结构差异；后者通过映射算法/神经网络实现同类特征对齐。现有方案包括：汇编统一[41,46]  
、中间语言统一[138]  
、跨模态映射算法[101]  
、基于GNN的结构映射[9]  
等；可辅以迁移学习或对比学习缓解分布差异，提升语义对齐。  
  
跨语言漏洞检测。当前方法集中于C/C++。CCAligner[48]  
支持C/Java，FUNDED[31]  
支持C/C++、Java、PHP、Swift。研究建议：在统一多语言特征基础上，引入中间语言（如LLVM IR）供模型学习，拓宽语言覆盖，增强适应性。  
  
多维且漏洞特化的代码表征。通用数据集评估表明，混合表征在精确率、召回率上优于单一表征，验证多维度特征有效性。鉴于漏洞形式化表征尚缺，已出现若干面向漏洞的特化方案：Leopard[102]  
设计漏洞关联指标；ContraFlow[69]  
以VFG+自注意力检测异常值流；CarrotsBlender[95]  
构建VCG追踪漏洞调用。研究建议：通过实证分析各表征的互斥性与互补性，设计有效耦合的多维融合机制，并构建面向漏洞特征的形式化表征。  
  
集成式的神经网络检测模型。CPVD[92]  
、VDoTR[108]  
、VulHawk[56]  
均采用集成式神经网络，在测试中表现良好。Transformer派生网络与GNN家族分别在序列、结构数据上具优势，将二者及其他先进网络融合可弥补单网络缺陷。此外，ChatGPT出现后，大语言模型（LLM）已被用于漏洞检测[139-140]  
。Zhang等[141]  
、Bakhshandeh等[142]  
发现LLM可增强检测能力，但尚未取得明显领先[143-144]  
，仍是重要研究方向。研究建议：在大规模实证基础上，构建契合漏洞语义的Transformer+GNN+LLM集成框架，探讨3类模型在表征、训练、解释上的协同优化，并对串联/并联/注意力加权等集成方式进行对比评估。  
  
高效简洁的模型可解释化方法。对图解释器，可通过最大归因化度量筛选边序列因果，使解释结果高效且忠实，如RC-Explainer[145]  
；对通用解释器，可通过遮蔽输入预测构建模型无关的LTX[146]  
，为Transformer和CNN提供简洁解释。研究建议：解析漏洞语义与模型学习机制的关联，构建高效简洁的解释器，提升黑盒模型的可用性与可信度。  
  
（2）建立统一、全面、真实语境下的大规模漏洞数据集与评估体系  
  
漏洞检测评估依赖样本集与有限指标，而现有数据集滞后、局限，评估体系不统一，难以公平对比与持续迭代。构建多类型、多领域有效数据集与统一评估体系将是未来重要研究方向。  
  
构建覆盖多漏洞类型、多语言、多领域、多源形式（源代码/二进制代码）的公开数据集。多语言、多类型漏洞集可显著提升模型泛用性；跨领域、跨模态数据集更具应用潜力。研究建议：在NVD、Big-Vul[33]  
、DiverseVul[36]  
等基础上扩展类型、领域、语言、形式，并推动学界与产业共享，确保保留真实上下文特征且验证标签的有效性。  
  
引入自动标注和人机协同标注机制。样本标注自动化、高效化契合规模扩展与质量提升。可利用静态/动态分析工具[147]  
初步筛选和标注，再经专家审核，扩大规模并提升质量，实现持续更新。研究建议：开发集成自动化工具与专家审核的智能标注平台，实现人机协同流程自动化、标准化。  
  
建立统一完备的评估指标体系。当前指标相对混乱、不全面，统一完备的鲁棒性、泛化性、数据敏感性、可扩展性、可解释性、效率等多维指标将提升横向可比性并降低评估复杂度。研究建议：在传统准确率、F  
1分数基础上，按适用场景设定上述多维指标。  
  
开展标准化benchmark竞赛机制。标准化竞赛可吸引研究者参与，推动领域发展。研究建议：建立公开透明平台，定期发布benchmark数据集与评估结果，鼓励模型在真实场景（开源项目漏洞、CTF数据）中实战测试。  
  
## 5 结束语  
  
  
为把握基于代码相似性的软件漏洞检测领域的研究进展，本文对近7年具有代表性的基于代码相似性的软件漏洞检测方法进行了系统性研究。本文从漏洞样本数据集、代码预处理、代码表征与漏洞检测3个方面出发，对现有方法进行了深入全面的特征总结、性能评估和开销分析，形成了对基于代码相似性的软件漏洞检测领域面临的挑战分析以及未来的研究方向展望。笔者期待今后能够有更多的研究人员对此领域进行研究，持续不断地推进此领域向前发展。  
  
  
  
**作者简介**  
## 李晴浩（1998- ），男，湖南邵阳人，信息工程大学博士生，主要研究方向为信息安全、代码相似性检测、漏洞检测。 刘春玲（1981- ），女，河南滑县人，信息工程大学讲师，主要研究方向为代码相似性检测、漏洞检测。 唐永鹤（1983- ），男，河南确山人，信息工程大学副教授，主要研究方向为计算机安全、恶意代码检测。 董卫宇（1976- ），男，辽宁沈阳人，信息工程大学教授，主要研究方向为计算机架构、系统虚拟化、计算机安全、漏洞检测。   
  
  
  
# 联系我们：  
  
  
**Tel:**  
010-53879078  
  
         
010-53879139****  
  
**E-mail:**  
cjnis@bjxintong.com.cn  
  
[http://www.cjnis.com.cn/](http://www.cjnis.com.cn/)  
  
  
  
**网络与信息安全学报**  
  
《网络与信息安全学报》是由工业和信息化部主管，人民邮电出版社主办的信息安全领域的学术刊物。办刊宗旨：汇聚安全创新思想，传播学术研究成果，提升科学研发实力，服务国家信息安全。  
  
  
![](https://mmbiz.qpic.cn/mmbiz_jpg/IgR5nfFgN9ORGRs7JJajOdYTBTWQBgyWrgichf9fMicxFysp4S26UeGVQaOaT3UCpYSxPdJJg6PU03yCvicbE2V3Q/640?wx_fmt=jpeg "网络与信息安全学报微信公众号二维码860.jpg")  
  
中国网络空间安全协会会刊  
  
中国计算机学会会刊  
  
中国科技核心期刊  
  
《计算领域高质量科技期刊分级目录》(T2类)  
  
《信息通信领域高质量科技期刊分级目录》（T2级）  
  
  
Scopus、DOAJ、JST、EBSCO、Ulrich PD收录期刊  
  
**关注我们，查看更多内容**  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/9v5IyrChCwIspaib7rkUW436AhtH9kGfmDFOscuvAbLsTbUuYaSRvy1pCH0ib483SyJIlPl9cwWsAQzuzKCyQibmg/640?wx_fmt=gif "")  
  
**点分享**  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/9v5IyrChCwIspaib7rkUW436AhtH9kGfmtRmmsZicicWfIYzmZdAlyicJIxMdvLmD4hjxUfaqrHIfEz5KTk5IibiaOiaQ/640?wx_fmt=gif "")  
  
**点收藏**  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/9v5IyrChCwIspaib7rkUW436AhtH9kGfmlTB0u5JLbbIEojzInKLxIfCbSUBDtLvN86v8qicBUO3SfxzoH1aqckg/640?wx_fmt=gif "")  
  
**点点赞**  
  
![](https://mmbiz.qpic.cn/mmbiz_gif/9v5IyrChCwIspaib7rkUW436AhtH9kGfmnsv6GtdTIYMXhpuADCNSWcaabkIo7EEF68x4g1889iaRO2SicjIrNXZw/640?wx_fmt=gif "")  
  
**点在看**  
  
  
  
